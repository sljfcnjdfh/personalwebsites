/*
 * MediaSave 
 * https://mediasave.ru/ 
 *
 * @ 2015, Linber LLC
 * License: https://mediasave.ru/info/license/ 
 * Every action with the software such as copying, modification, spread etc. without creator鈥檚 written permission is forbidden
*/

window.IsProduction = true;

var requirejs, require, define;

(function(global, setTimeout) {
    var req, s, head, baseElement, dataMain, src, interactiveScript, currentlyAddingScript, mainScript, subPath, version = "2.3.2", commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/gm, cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g, jsSuffixRegExp = /\.js$/, currDirRegExp = /^\.\//, op = Object.prototype, ostring = op.toString, hasOwn = op.hasOwnProperty, isBrowser = !!(typeof window !== "undefined" && typeof navigator !== "undefined" && window.document), isWebWorker = !isBrowser && typeof importScripts !== "undefined", readyRegExp = isBrowser && navigator.platform === "PLAYSTATION 3" ? /^complete$/ : /^(complete|loaded)$/, defContextName = "_", isOpera = typeof opera !== "undefined" && opera.toString() === "[object Opera]", contexts = {}, cfg = {}, globalDefQueue = [], useInteractive = false;
    function commentReplace(match, singlePrefix) {
        return singlePrefix || "";
    }
    function isFunction(it) {
        return ostring.call(it) === "[object Function]";
    }
    function isArray(it) {
        return ostring.call(it) === "[object Array]";
    }
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }
    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }
    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function(value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === "object" && value && !isArray(value) && !isFunction(value) && !(value instanceof RegExp)) {
                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }
    function bind(obj, fn) {
        return function() {
            return fn.apply(obj, arguments);
        };
    }
    function scripts() {
        return document.getElementsByTagName("script");
    }
    function defaultOnError(err) {
        throw err;
    }
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split("."), function(part) {
            g = g[part];
        });
        return g;
    }
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + "\nhttp://requirejs.org/docs/errors.html#" + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }
    if (typeof define !== "undefined") {
        return;
    }
    if (typeof requirejs !== "undefined") {
        if (isFunction(requirejs)) {
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }
    if (typeof require !== "undefined" && !isFunction(require)) {
        cfg = require;
        require = undefined;
    }
    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers, checkLoadedTimeoutId, config = {
            waitSeconds: 7,
            baseUrl: "./",
            paths: {},
            bundles: {},
            pkgs: {},
            shim: {},
            config: {}
        }, registry = {}, enabledRegistry = {}, undefEvents = {}, defQueue = [], defined = {}, urlFetched = {}, bundlesMap = {}, requireCounter = 1, unnormalizedCounter = 1;
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === ".") {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === "..") {
                    if (i === 0 || i === 1 && ary[2] === ".." || ary[i - 1] === "..") {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex, foundMap, foundI, foundStarMap, starI, normalizedBaseParts, baseParts = baseName && baseName.split("/"), map = config.map, starMap = map && map["*"];
            if (name) {
                name = name.split("/");
                lastIndex = name.length - 1;
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, "");
                }
                if (name[0].charAt(0) === "." && baseParts) {
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }
                trimDots(name);
                name = name.join("/");
            }
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split("/");
                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join("/");
                    if (baseParts) {
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join("/"));
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }
                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }
                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join("/");
                }
            }
            pkgMain = getOwn(config.pkgs, name);
            return pkgMain ? pkgMain : name;
        }
        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function(scriptNode) {
                    if (scriptNode.getAttribute("data-requiremodule") === name && scriptNode.getAttribute("data-requirecontext") === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }
        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                pathConfig.shift();
                context.require.undef(id);
                context.makeRequire(null, {
                    skipMap: true
                })([ id ]);
                return true;
            }
        }
        function splitPrefix(name) {
            var prefix, index = name ? name.indexOf("!") : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [ prefix, name ];
        }
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts, prefix = null, parentName = parentModuleMap ? parentModuleMap.name : null, originalName = name, isDefine = true, normalizedName = "";
            if (!name) {
                isDefine = false;
                name = "_@r" + (requireCounter += 1);
            }
            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];
            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        normalizedName = pluginModule.normalize(name, function(name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        normalizedName = name.indexOf("!") === -1 ? normalize(name, parentName, applyMap) : name;
                    }
                } else {
                    normalizedName = normalize(name, parentName, applyMap);
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;
                    url = context.nameToUrl(normalizedName);
                }
            }
            suffix = prefix && !pluginModule && !isNormalized ? "_unnormalized" + (unnormalizedCounter += 1) : "";
            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ? prefix + "!" + normalizedName : normalizedName) + suffix
            };
        }
        function getModule(depMap) {
            var id = depMap.id, mod = getOwn(registry, id);
            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }
            return mod;
        }
        function on(depMap, name, fn) {
            var id = depMap.id, mod = getOwn(registry, id);
            if (hasProp(defined, id) && (!mod || mod.defineEmitComplete)) {
                if (name === "defined") {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === "error") {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }
        function onError(err, errback) {
            var ids = err.requireModules, notified = false;
            if (errback) {
                errback(err);
            } else {
                each(ids, function(id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit("error", err);
                        }
                    }
                });
                if (!notified) {
                    req.onError(err);
                }
            }
        }
        function takeGlobalQueue() {
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === "string") {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }
        handlers = {
            require: function(mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return mod.require = context.makeRequire(mod.map);
                }
            },
            exports: function(mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return defined[mod.map.id] = mod.exports;
                    } else {
                        return mod.exports = defined[mod.map.id] = {};
                    }
                }
            },
            module: function(mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function() {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    };
                }
            }
        };
        function cleanRegistry(id) {
            delete registry[id];
            delete enabledRegistry[id];
        }
        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;
            if (mod.error) {
                mod.emit("error", mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function(depMap, i) {
                    var depId = depMap.id, dep = getOwn(registry, depId);
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check();
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }
        function checkLoaded() {
            var err, usingPathFallback, waitInterval = config.waitSeconds * 1e3, expired = waitInterval && context.startTime + waitInterval < new Date().getTime(), noLoads = [], reqCalls = [], stillLoading = false, needCycleCheck = true;
            if (inCheckLoaded) {
                return;
            }
            inCheckLoaded = true;
            eachProp(enabledRegistry, function(mod) {
                var map = mod.map, modId = map.id;
                if (!mod.enabled) {
                    return;
                }
                if (!map.isDefine) {
                    reqCalls.push(mod);
                }
                if (!mod.error) {
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            return needCycleCheck = false;
                        }
                    }
                }
            });
            if (expired && noLoads.length) {
                err = makeError("timeout", "Load timeout for modules: " + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }
            if (needCycleCheck) {
                each(reqCalls, function(mod) {
                    breakCycle(mod, {}, {});
                });
            }
            if ((!expired || usingPathFallback) && stillLoading) {
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function() {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }
            inCheckLoaded = false;
        }
        Module = function(map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;
        };
        Module.prototype = {
            init: function(depMaps, factory, errback, options) {
                options = options || {};
                if (this.inited) {
                    return;
                }
                this.factory = factory;
                if (errback) {
                    this.on("error", errback);
                } else if (this.events.error) {
                    errback = bind(this, function(err) {
                        this.emit("error", err);
                    });
                }
                this.depMaps = depMaps && depMaps.slice(0);
                this.errback = errback;
                this.inited = true;
                this.ignore = options.ignore;
                if (options.enabled || this.enabled) {
                    this.enable();
                } else {
                    this.check();
                }
            },
            defineDep: function(i, depExports) {
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },
            fetch: function() {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;
                context.startTime = new Date().getTime();
                var map = this.map;
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function() {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },
            load: function() {
                var url = this.map.url;
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },
            check: function() {
                if (!this.enabled || this.enabling) {
                    return;
                }
                var err, cjsModule, id = this.map.id, depExports = this.depExports, exports = this.exports, factory = this.factory;
                if (!this.inited) {
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit("error", this.error);
                } else if (!this.defining) {
                    this.defining = true;
                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            if (this.events.error && this.map.isDefine || req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    exports = this.exports;
                                }
                            }
                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [ this.map.id ] : null;
                                err.requireType = this.map.isDefine ? "define" : "require";
                                return onError(this.error = err);
                            }
                        } else {
                            exports = factory;
                        }
                        this.exports = exports;
                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;
                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function(depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }
                        cleanRegistry(id);
                        this.defined = true;
                    }
                    this.defining = false;
                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit("defined", this.exports);
                        this.defineEmitComplete = true;
                    }
                }
            },
            callPlugin: function() {
                var map = this.map, id = map.id, pluginMap = makeModuleMap(map.prefix);
                this.depMaps.push(pluginMap);
                on(pluginMap, "defined", bind(this, function(plugin) {
                    var load, normalizedMap, normalizedMod, bundleId = getOwn(bundlesMap, this.map.id), name = this.map.name, parentName = this.map.parentMap ? this.map.parentMap.name : null, localRequire = context.makeRequire(map.parentMap, {
                        enableBuildCallback: true
                    });
                    if (this.map.unnormalized) {
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function(name) {
                                return normalize(name, parentName, true);
                            }) || "";
                        }
                        normalizedMap = makeModuleMap(map.prefix + "!" + name, this.map.parentMap);
                        on(normalizedMap, "defined", bind(this, function(value) {
                            this.map.normalizedMap = normalizedMap;
                            this.init([], function() {
                                return value;
                            }, null, {
                                enabled: true,
                                ignore: true
                            });
                        }));
                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            this.depMaps.push(normalizedMap);
                            if (this.events.error) {
                                normalizedMod.on("error", bind(this, function(err) {
                                    this.emit("error", err);
                                }));
                            }
                            normalizedMod.enable();
                        }
                        return;
                    }
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }
                    load = bind(this, function(value) {
                        this.init([], function() {
                            return value;
                        }, null, {
                            enabled: true
                        });
                    });
                    load.error = bind(this, function(err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [ id ];
                        eachProp(registry, function(mod) {
                            if (mod.map.id.indexOf(id + "_unnormalized") === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });
                        onError(err);
                    });
                    load.fromText = bind(this, function(text, textAlt) {
                        var moduleName = map.name, moduleMap = makeModuleMap(moduleName), hasInteractive = useInteractive;
                        if (textAlt) {
                            text = textAlt;
                        }
                        if (hasInteractive) {
                            useInteractive = false;
                        }
                        getModule(moduleMap);
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }
                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError("fromtexteval", "fromText eval for " + id + " failed: " + e, e, [ id ]));
                        }
                        if (hasInteractive) {
                            useInteractive = true;
                        }
                        this.depMaps.push(moduleMap);
                        context.completeLoad(moduleName);
                        localRequire([ moduleName ], load);
                    });
                    plugin.load(map.name, localRequire, load, config);
                }));
                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },
            enable: function() {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;
                this.enabling = true;
                each(this.depMaps, bind(this, function(depMap, i) {
                    var id, mod, handler;
                    if (typeof depMap === "string") {
                        depMap = makeModuleMap(depMap, this.map.isDefine ? this.map : this.map.parentMap, false, !this.skipMap);
                        this.depMaps[i] = depMap;
                        handler = getOwn(handlers, depMap.id);
                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }
                        this.depCount += 1;
                        on(depMap, "defined", bind(this, function(depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));
                        if (this.errback) {
                            on(depMap, "error", bind(this, this.errback));
                        } else if (this.events.error) {
                            on(depMap, "error", bind(this, function(err) {
                                this.emit("error", err);
                            }));
                        }
                    }
                    id = depMap.id;
                    mod = registry[id];
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));
                eachProp(this.pluginMaps, bind(this, function(pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));
                this.enabling = false;
                this.check();
            },
            on: function(name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },
            emit: function(name, evt) {
                each(this.events[name], function(cb) {
                    cb(evt);
                });
                if (name === "error") {
                    delete this.events[name];
                }
            }
        };
        function callGetModule(args) {
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }
        function removeListener(node, func, name, ieName) {
            if (node.detachEvent && !isOpera) {
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }
        function getScriptData(evt) {
            var node = evt.currentTarget || evt.srcElement;
            removeListener(node, context.onScriptLoad, "load", "onreadystatechange");
            removeListener(node, context.onScriptError, "error");
            return {
                node: node,
                id: node && node.getAttribute("data-requiremodule")
            };
        }
        function intakeDefines() {
            var args;
            takeGlobalQueue();
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError("mismatch", "Mismatched anonymous define() module: " + args[args.length - 1]));
                } else {
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }
        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,
            configure: function(cfg) {
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== "/") {
                        cfg.baseUrl += "/";
                    }
                }
                if (typeof cfg.urlArgs === "string") {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf("?") === -1 ? "?" : "&") + urlArgs;
                    };
                }
                var shim = config.shim, objs = {
                    paths: true,
                    bundles: true,
                    config: true,
                    map: true
                };
                eachProp(cfg, function(value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function(value, prop) {
                        each(value, function(v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }
                if (cfg.shim) {
                    eachProp(cfg.shim, function(value, id) {
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }
                if (cfg.packages) {
                    each(cfg.packages, function(pkgObj) {
                        var location, name;
                        pkgObj = typeof pkgObj === "string" ? {
                            name: pkgObj
                        } : pkgObj;
                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }
                        config.pkgs[name] = pkgObj.name + "/" + (pkgObj.main || "main").replace(currDirRegExp, "").replace(jsSuffixRegExp, "");
                    });
                }
                eachProp(registry, function(mod, id) {
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },
            makeShimExports: function(value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || value.exports && getGlobal(value.exports);
                }
                return fn;
            },
            makeRequire: function(relMap, options) {
                options = options || {};
                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;
                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }
                    if (typeof deps === "string") {
                        if (isFunction(callback)) {
                            return onError(makeError("requireargs", "Invalid require call"), errback);
                        }
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;
                        if (!hasProp(defined, id)) {
                            return onError(makeError("notloaded", 'Module name "' + id + '" has not been loaded yet for context: ' + contextName + (relMap ? "" : ". Use require([])")));
                        }
                        return defined[id];
                    }
                    intakeDefines();
                    context.nextTick(function() {
                        intakeDefines();
                        requireMod = getModule(makeModuleMap(null, relMap));
                        requireMod.skipMap = options.skipMap;
                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });
                        checkLoaded();
                    });
                    return localRequire;
                }
                mixin(localRequire, {
                    isBrowser: isBrowser,
                    toUrl: function(moduleNamePlusExt) {
                        var ext, index = moduleNamePlusExt.lastIndexOf("."), segment = moduleNamePlusExt.split("/")[0], isRelative = segment === "." || segment === "..";
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }
                        return context.nameToUrl(normalize(moduleNamePlusExt, relMap && relMap.id, true), ext, true);
                    },
                    defined: function(id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },
                    specified: function(id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });
                if (!relMap) {
                    localRequire.undef = function(id) {
                        takeGlobalQueue();
                        var map = makeModuleMap(id, relMap, true), mod = getOwn(registry, id);
                        mod.undefed = true;
                        removeScript(id);
                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];
                        if (mod) {
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }
                            cleanRegistry(id);
                        }
                    };
                }
                return localRequire;
            },
            enable: function(depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },
            completeLoad: function(moduleName) {
                var found, args, mod, shim = getOwn(config.shim, moduleName) || {}, shExports = shim.exports;
                takeGlobalQueue();
                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        found = true;
                    }
                    callGetModule(args);
                }
                context.defQueueMap = {};
                mod = getOwn(registry, moduleName);
                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError("nodefine", "No define call for " + moduleName, null, [ moduleName ]));
                        }
                    } else {
                        callGetModule([ moduleName, shim.deps || [], shim.exportsFn ]);
                    }
                }
                checkLoaded();
            },
            nameToUrl: function(moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url, parentPath, bundleId, pkgMain = getOwn(config.pkgs, moduleName);
                if (pkgMain) {
                    moduleName = pkgMain;
                }
                bundleId = getOwn(bundlesMap, moduleName);
                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }
                if (req.jsExtRegExp.test(moduleName)) {
                    url = moduleName + (ext || "");
                } else {
                    paths = config.paths;
                    syms = moduleName.split("/");
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join("/");
                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }
                    url = syms.join("/");
                    url += ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? "" : ".js");
                    url = (url.charAt(0) === "/" || url.match(/^[\w\+\.\-]+:/) ? "" : config.baseUrl) + url;
                }
                return config.urlArgs && !/^blob\:/.test(url) ? url + config.urlArgs(moduleName, url) : url;
            },
            load: function(id, url) {
                req.load(context, id, url);
            },
            execCb: function(name, callback, args, exports) {
                return callback.apply(exports, args);
            },
            onScriptLoad: function(evt) {
                if (evt.type === "load" || readyRegExp.test((evt.currentTarget || evt.srcElement).readyState)) {
                    interactiveScript = null;
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },
            onScriptError: function(evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf("_@r") !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError("scripterror", 'Script error for "' + data.id + (parents.length ? '", needed by: ' + parents.join(", ") : '"'), evt, [ data.id ]));
                }
            }
        };
        context.require = context.makeRequire();
        return context;
    }
    req = requirejs = function(deps, callback, errback, optional) {
        var context, config, contextName = defContextName;
        if (!isArray(deps) && typeof deps !== "string") {
            config = deps;
            if (isArray(callback)) {
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }
        if (config && config.context) {
            contextName = config.context;
        }
        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }
        if (config) {
            context.configure(config);
        }
        return context.require(deps, callback, errback);
    };
    req.config = function(config) {
        return req(config);
    };
    req.nextTick = typeof setTimeout !== "undefined" ? function(fn) {
        setTimeout(fn, 4);
    } : function(fn) {
        fn();
    };
    if (!require) {
        require = req;
    }
    req.version = version;
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };
    req({});
    each([ "toUrl", "undef", "defined", "specified" ], function(prop) {
        req[prop] = function() {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });
    if (isBrowser) {
        head = s.head = document.getElementsByTagName("head")[0];
        baseElement = document.getElementsByTagName("base")[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }
    req.onError = defaultOnError;
    req.createNode = function(config, moduleName, url) {
        var node = config.xhtml ? document.createElementNS("http://www.w3.org/1999/xhtml", "html:script") : document.createElement("script");
        node.type = config.scriptType || "text/javascript";
        node.charset = "utf-8";
        node.async = true;
        return node;
    };
    req.load = function(context, moduleName, url) {
        var config = context && context.config || {}, node;
        if (isBrowser) {
            node = req.createNode(config, moduleName, url);
            node.setAttribute("data-requirecontext", context.contextName);
            node.setAttribute("data-requiremodule", moduleName);
            if (node.attachEvent && !(node.attachEvent.toString && node.attachEvent.toString().indexOf("[native code") < 0) && !isOpera) {
                useInteractive = true;
                node.attachEvent("onreadystatechange", context.onScriptLoad);
            } else {
                node.addEventListener("load", context.onScriptLoad, false);
                node.addEventListener("error", context.onScriptError, false);
            }
            node.src = url;
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;
            return node;
        } else if (isWebWorker) {
            try {
                setTimeout(function() {}, 0);
                importScripts(url);
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError("importscripts", "importScripts failed for " + moduleName + " at " + url, e, [ moduleName ]));
            }
        }
    };
    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === "interactive") {
            return interactiveScript;
        }
        eachReverse(scripts(), function(script) {
            if (script.readyState === "interactive") {
                return interactiveScript = script;
            }
        });
        return interactiveScript;
    }
    if (isBrowser && !cfg.skipDataMain) {
        eachReverse(scripts(), function(script) {
            if (!head) {
                head = script.parentNode;
            }
            dataMain = script.getAttribute("data-main");
            if (dataMain) {
                mainScript = dataMain;
                if (!cfg.baseUrl && mainScript.indexOf("!") === -1) {
                    src = mainScript.split("/");
                    mainScript = src.pop();
                    subPath = src.length ? src.join("/") + "/" : "./";
                    cfg.baseUrl = subPath;
                }
                mainScript = mainScript.replace(jsSuffixRegExp, "");
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [ mainScript ];
                return true;
            }
        });
    }
    define = function(name, deps, callback) {
        var node, context;
        if (typeof name !== "string") {
            callback = deps;
            deps = name;
            name = null;
        }
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }
        if (!deps && isFunction(callback)) {
            deps = [];
            if (callback.length) {
                callback.toString().replace(commentRegExp, commentReplace).replace(cjsRequireRegExp, function(match, dep) {
                    deps.push(dep);
                });
                deps = (callback.length === 1 ? [ "require" ] : [ "require", "exports", "module" ]).concat(deps);
            }
        }
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute("data-requiremodule");
                }
                context = contexts[node.getAttribute("data-requirecontext")];
            }
        }
        if (context) {
            context.defQueue.push([ name, deps, callback ]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([ name, deps, callback ]);
        }
    };
    define.amd = {
        jQuery: true
    };
    req.exec = function(text) {
        return eval(text);
    };
    req(cfg);
})(this, typeof setTimeout === "undefined" ? undefined : setTimeout);

(function() {
    String.prototype.format = function(args) {
        var reg1 = new RegExp("{-?[0-9]+}", "g");
        var reg2 = new RegExp("[-?[0-9]+,.+]", "g");
        var str = this;
        str = str.replace(reg1, function(item) {
            var intVal = parseInt(item.substring(1, item.length - 1));
            var replace;
            if (intVal >= 0) {
                replace = args[intVal];
            } else if (intVal === -1) {
                replace = "{";
            } else if (intVal === -2) {
                replace = "}";
            } else {
                replace = "";
            }
            return replace;
        });
        str = str.replace(reg2, function(item) {
            var pos1 = item.indexOf(",");
            var lastInt = parseInt(item.substring(pos1 - 1, pos1));
            var last2Int = parseInt(item.substring(pos1 - 2, pos1));
            var arrayValues = item.substring(pos1 + 1, item.length - 1).split(",");
            var result = "";
            if (last2Int >= 11 && last2Int <= 19) {
                result = arrayValues[2];
            } else {
                if (lastInt === 1) {
                    result = arrayValues[0];
                } else if (lastInt >= 2 && lastInt <= 4) {
                    result = arrayValues[1];
                } else if (lastInt >= 5 || lastInt === 0) {
                    result = arrayValues[2];
                }
            }
            return result;
        });
        return str;
    };
})();

window.MS = {
    Db: {},
    Browser: chrome,
    Translate: {
        ru: {
            translation: {
                nameApp: "MediaSave. 小泻邪褔懈胁邪薪懈械 屑褍蟹褘泻懈",
                descriptionApp: "袩芯蟹胁芯谢褟械褌 褋泻邪褔懈胁邪褌褜 屑褍蟹褘泻褍 褋 谢褞斜芯谐芯 褋邪泄褌邪",
                Rasshireniye_dlya_etogo_sayta_otklyucheno: "袪邪褋褕懈褉械薪懈械 写谢褟 褝褌芯谐芯 褋邪泄褌邪 芯褌泻谢褞褔械薪芯. <br> 啸芯褌懈褌械 胁泻谢褞褔懈褌褜?",
                Vklyuchit_rasshireniye: "袙泻谢褞褔懈褌褜 褉邪褋褕懈褉械薪懈械",
                Bez_nazvaniya: "袘械蟹 薪邪蟹胁邪薪懈褟",
                Neizvestnyy_ispolnitel: "袧械懈蟹胁械褋褌薪褘泄 懈褋锌芯谢薪懈褌械谢褜",
                Skachat: "小泻邪褔邪褌褜",
                Obnaruzheny_mediafayly: "袨斜薪邪褉褍卸械薪褘 屑械写懈邪褎邪泄谢褘. 啸芯褌懈褌械 褋泻邪褔邪褌褜?",
                Mne_nravitsya: "袦薪械 薪褉邪胁懈褌褋褟!",
                Vy_deystvitelno_khotite_otklyuchit_rasshireniye: "袙褘 写械泄褋褌胁懈褌械谢褜薪芯 褏芯褌懈褌械 芯褌泻谢褞褔懈褌褜 <br> 褉邪褋褕懈褉械薪懈械 芦MediaSave禄 写谢褟 褝褌芯谐芯 褋邪泄褌邪?",
                Vy_vsegda_smozhete_vklyuchit_yego: "袙褘 胁褋械谐写邪 褋屑芯卸械褌械 胁泻谢褞褔懈褌褜 械谐芯 胁薪芯胁褜, 薪邪卸邪胁 薪邪 蟹薪邪褔芯泻 褉邪褋褕懈褉械薪懈褟",
                Otklyuchit_plagin: "袨褌泻谢褞褔懈褌褜 锌谢邪谐懈薪",
                Svernut: "小胁械褉薪褍褌褜",
                Otmena: "袨褌屑械薪邪",
                Vam_nravitsya_nash_plagin: "袙邪屑 薪褉邪胁懈褌褋褟 薪邪褕 锌谢邪谐懈薪? 袩芯写写械褉卸懈褌械, 褉邪褋褋泻邪蟹邪胁 写褉褍蟹褜褟屑",
                Vy_davno_polzuyetes_plaginom: "袙褘 褍卸械 写邪胁薪芯 锌芯谢褜蟹褍械褌械褋褜 锌谢邪谐懈薪芯屑.<br> " + "袛谢褟 锌褉芯写芯谢卸械薪懈褟 懈褋锌芯谢褜蟹芯胁邪薪懈褟 褉邪褋褋泻邪卸懈褌械 芯 薪褢屑 褋胁芯懈屑 写褉褍蟹褜褟屑",
                Ne_khochu_delitsya: "袧械 褏芯褔褍 写械谢懈褌褜褋褟",
                Audio: "袗褍写懈芯",
                Video: "袙懈写械芯",
                Mb: "屑斜",
                Udalit: "校写邪谢懈褌褜",
                Proigrat_v_brauzere: "袩褉芯懈谐褉邪褌褜 胁 斜褉邪褍蟹械褉械",
                Priostanovit_proigryvaniye: "袩褉懈芯褋褌邪薪芯胁懈褌褜 锌褉芯懈谐褉褘胁邪薪懈械",
                Klassnoye_rasshirniye_chrome_dlya_skachivaniya_muzyki: "袣谢邪褋褋薪褘泄 锌谢邪谐懈薪 写谢褟 褋泻邪褔懈胁邪薪懈褟 屑褍蟹褘泻懈. 袘褘褋褌褉芯 懈 褍写芯斜薪芯!",
                Pozvolyayet_besplatno_skachivat_muzyku_s_lyubogo_sayta: "袩芯蟹胁芯谢褟械褌 斜械褋锌谢邪褌薪芯 褋泻邪褔懈胁邪褌褜 屑褍蟹褘泻褍 褋 谢褞斜芯谐芯 褋邪泄褌邪. 袙褋械屑 褉械泻芯屑械薪写褍褞!",
                Razvernut: "袪邪蟹胁械褉薪褍褌褜",
                Review: "袨褋褌邪胁懈褌褜 芯褌蟹褘胁",
                ExampleEmail: "alex-martov@linber.ru",
                "Popup/PoweredBy": "Powered by <b>Linber LLC</b>",
                "Popup/Settings": "袧邪褋褌褉芯泄泻懈",
                "Popup/ExtensionEnable": "袪邪褋褕懈褉械薪懈械 胁泻谢褞褔械薪芯 薪邪 褋邪泄褌械",
                "Popup/ExtensionDisable": "袪邪褋褕懈褉械薪懈械 胁褘泻谢褞褔械薪芯 薪邪 褋邪泄褌械",
                "Popup/WindowLocation": "袪邪褋锌芯谢芯卸械薪懈械 芯泻薪邪",
                "Popup/Feedback": "袨斜褉邪褌薪邪褟 褋胁褟蟹褜",
                "Popup/YourQuestions": "袙邪褕懈 胁芯锌褉芯褋褘/锌芯卸械谢邪薪懈褟",
                "Popup/BottomLeft": "小薪懈蟹褍 懈 褋谢械胁邪",
                "Popup/BotomCenter": "小薪懈蟹褍 懈 锌芯 褑械薪褌褉褍",
                "Popup/BottomRight": "小薪懈蟹褍 懈 褋锌褉邪胁邪",
                "Popup/TopLeft": "小胁械褉褏褍 懈 褋谢械胁邪",
                "Popup/TopCenter": "小胁械褉褏褍 懈 锌芯 褑械薪褌褉褍",
                "Popup/TopRight": "小胁械褉褏褍 懈 褋锌褉邪胁邪",
                "Popup/WriteUs": "袧邪锌懈褋邪褌褜 薪邪屑",
                "Popup/IWantToTell": "袦薪械 泻邪卸械褌褋褟, 褔褌芯 薪械 褏胁邪褌邪械褌...",
                "Popup/UnableSendMessage": "袧械 褍写邪谢芯褋褜 芯褌锌褉邪胁懈褌褜 褋芯芯斜褖械薪懈械",
                "Popup/TryLater": "袩芯锌褉芯斜褍泄褌械 锌芯蟹卸械",
                "Popup/MessageSuccessfullySent": "小芯芯斜褖械薪懈械 褍褋锌械褕薪芯 芯褌锌褉邪胁谢械薪芯",
                "Popup/WeWouldAppreciate": "小锌邪褋懈斜芯, 薪邪屑 胁邪卸薪芯 胁邪褕械 屑薪械薪懈械",
                "Popup/ShowWindowAutomatically": "袩芯泻邪蟹褘胁邪褌褜 褎邪泄谢褘 邪胁褌芯屑邪褌懈褔械褋泻懈",
                "Popup/NoShowWindowAutomatically": "袧械 锌芯泻邪蟹褘胁邪褌褜 褎邪泄谢褘 邪胁褌芯屑邪褌懈褔械褋泻懈",
                "Popup/ShowWindowAutomaticallyDesc": "袣邪泻 褌芯谢褜泻芯 斜褍写褍褌 薪邪泄写械薪褘 褎邪泄谢褘 写谢褟 褋泻邪褔懈胁邪薪懈褟, 芯薪懈 邪胁褌芯屑邪褌懈褔械褋泻懈 芯褌芯斜褉邪蟹褟褌褋褟 胁芯 胁褋锌谢褘胁邪褞褖械屑 芯泻薪械 (写械泄褋褌胁褍械褌 写谢褟 胁褋械褏 褋邪泄褌芯胁)",
                "Popup/NoShowWindowAutomaticallyDesc": "效褌芯斜褘 褍胁懈写械褌褜 褎邪泄谢褘 写芯褋褌褍锌薪褘械 写谢褟 褋泻邪褔懈胁邪薪懈褟, 薪械芯斜褏芯写懈屑芯 薪邪卸邪褌褜 薪邪 蟹薪邪褔芯泻 褉邪褋褕懈褉械薪懈褟 懈 泻薪芯锌泻褍 芦袩芯泻邪蟹邪褌褜 褎邪泄谢褘禄 (写械泄褋褌胁褍械褌 写谢褟 胁褋械褏 褋邪泄褌芯胁)",
                "Popup/ExtensionEnableDesc": "袪邪褋褕懈褉械薪懈械 胁泻谢褞褔械薪芯 懈 褉邪斜芯褌邪械褌 薪邪 褝褌芯屑 褋邪泄褌械",
                "Popup/ExtensionDisableDesc": "袪邪褋褕懈褉械薪懈械 胁褘泻谢褞褔械薪芯 懈 薪械 褉邪斜芯褌邪械褌 薪邪 褝褌芯屑 褋邪泄褌械",
                "Popup/YourEmail": "袙邪褕 email",
                "Popup/PageFilesAreFound": "袧邪 褋褌褉邪薪懈褑械 薪邪泄写械薪褘 褎邪泄谢褘",
                "Popup/ShowFiles": "袩芯泻邪蟹邪褌褜 褎邪泄谢褘",
                "Popup/PageFileNotFound": "袧邪 褋褌褉邪薪懈褑械 薪械 薪邪泄写械薪芯 褎邪泄谢芯胁 写谢褟 褋泻邪褔懈胁邪薪懈褟",
                "Popup/EnableSuccess": "袪邪褋褕懈褉械薪懈械 褍褋锌械褕薪芯 胁泻谢褞褔械薪芯 薪邪 褝褌芯屑 褋邪泄褌械",
                "Popup/AfterReloadEnableSuccess": "袩芯褋谢械 锌械褉械蟹邪谐褉褍蟹泻懈 褋褌褉邪薪懈褑褘 胁 斜褉邪褍蟹械褉械 褉邪褋褕懈褉械薪懈械 胁薪芯胁褜 薪邪褔薪械褌 褉邪斜芯褌邪褌褜 薪邪 褝褌芯屑 褋邪泄褌械",
                "Popup/DisableSuccess": "袪邪褋褕懈褉械薪懈械 褍褋锌械褕薪芯 芯褌泻谢褞褔械薪芯 薪邪 褝褌芯屑 褋邪泄褌械",
                "Popup/AfterReloadDisableSuccess": "袩芯褋谢械 锌械褉械蟹邪谐褉褍蟹泻懈 褋褌褉邪薪懈褑褘 胁 斜褉邪褍蟹械褉械 褉邪褋褕懈褉械薪懈械 锌械褉械褋褌邪薪械褌 褉邪斜芯褌邪褌褜 薪邪 褝褌芯屑 褋邪泄褌械",
                "UI/NoShowWindowAutomatically": "袧械 锌芯泻邪蟹褘胁邪褌褜 邪胁褌芯屑邪褌懈褔械褋泻懈",
                "UI/ClearList": "袨褔懈褋褌懈褌褜 褋锌懈褋芯泻 懈 蟹邪泻褉褘褌褜",
                "UI/Share": "袩芯写械谢懈褌褜褋褟 胁 褋芯褑懈邪谢褜薪褘褏 褋械褌褟褏",
                "UI/Close": "袟邪泻褉褘褌褜",
                "UI/downloads": "褋泻邪褔懈胁邪薪[{0},懈械,懈褟,懈泄]",
                "UI/TheAccountRemains": "袧邪 胁邪褕械屑 褋褔褢褌械 芯褋褌邪谢芯褋褜 <span data-balance-units>{0}</span> 褋泻邪褔懈胁邪薪[{0},懈械,懈褟,懈泄]",
                "UI/or": "懈谢懈",
                "UI/GetFree": "袩芯谢褍褔懈褌褜 斜械褋锌谢邪褌薪芯",
                "UI/DisableAd": "袨褌泻谢褞褔懈褌褜 褉械泻谢邪屑褍",
                "UI/BalanceDescription1": "袩褉懈 薪褍谢械胁芯屑 斜邪谢邪薪褋械 斜褍写械褌 邪泻褌懈胁懈褉芯胁邪薪 锌芯泻邪蟹 褉械泻谢邪屑褘.<br/> 效褌芯斜褘 械谐芯 芯褌泻谢褞褔懈褌褜, 薪械芯斜褏芯写懈屑芯 锌芯锌芯谢薪懈褌褜 斜邪谢邪薪褋 薪邪 谢褞斜褍褞 褋褍屑屑褍",
                "UI/BalanceDescription2": "袗泻褌懈胁懈褉芯胁邪薪 锌芯泻邪蟹 褉械泻谢邪屑褘.<br/> 效褌芯斜褘 械谐芯 芯褌泻谢褞褔懈褌褜, 薪械芯斜褏芯写懈屑芯 锌芯锌芯谢薪懈褌褜 斜邪谢邪薪褋 薪邪 谢褞斜褍褞 褋褍屑屑褍",
                "UI/TheAccountRemainsSubscriptionActive": "袙邪褕邪 锌芯写锌懈褋泻邪 写械泄褋褌胁褍械褌 写芯 <b>{0}</b>",
                "UI/TheAccountRemainsSubscriptionExpired": "袙邪褕邪 锌芯写锌懈褋泻邪 懈褋褌械泻谢邪. 袙褘 屑芯卸械褌械 械械 锌褉芯写谢懈褌褜",
                "UI/BalanceClickToMore": "袙邪褕邪 锌芯写锌懈褋泻邪. 袧邪卸屑懈褌械, 褔褌芯斜褘 褍蟹薪邪褌褜 锌芯写褉芯斜薪械械",
                "UI/SubscribeDoTitle": "写芯 {0}",
                "UI/PayDownloads": "袣褍锌懈褌褜 懈谢懈 锌褉芯写谢懈褌褜 锌芯写锌懈褋泻褍"
            }
        },
        en: {
            translation: {
                nameApp: "MediaSave. Downloading music files",
                descriptionApp: "You can download music files from any website",
                Rasshireniye_dlya_etogo_sayta_otklyucheno: "The extension is disable for this website. <br> Do you want to do it enable?",
                Vklyuchit_rasshireniye: "Enable the extension",
                Bez_nazvaniya: "No name",
                Neizvestnyy_ispolnitel: "Unknown performer",
                Skachat: "Download",
                Obnaruzheny_mediafayly: "Some media files have been found out",
                Mne_nravitsya: "I like it!",
                Vy_deystvitelno_khotite_otklyuchit_rasshireniye: "Do you really want to disable the extension 芦MediaSave禄 for this website?",
                Vy_vsegda_smozhete_vklyuchit_yego: "You can always to do it enable again, pressing on the extension's icon",
                Otklyuchit_plagin: "Disable the extension",
                Svernut: "Reduce",
                Otmena: "Cancel",
                Vam_nravitsya_nash_plagin: "Do you like our extension? Share with your friends",
                Vy_davno_polzuyetes_plaginom: "You use the extension for a long time.<br> Share with your friends for further using",
                Ne_khochu_delitsya: "I don't want to share",
                Audio: "Audio",
                Video: "Video",
                Mb: "mb",
                Udalit: "Delete",
                Proigrat_v_brauzere: "Play in the browser",
                Priostanovit_proigryvaniye: "Pause playback",
                Klassnoye_rasshirniye_chrome_dlya_skachivaniya_muzyki: "The plugin is cool for downloading music. Quickly and easily!",
                Pozvolyayet_besplatno_skachivat_muzyku_s_lyubogo_sayta: "It helps you to download music from any website absolutely free. I recommend it!",
                Razvernut: "Expand",
                Review: "Comment",
                ExampleEmail: "alex-martov@linber.ru",
                "Popup/PoweredBy": "Powered by <b>Linber LLC</b>",
                "Popup/Settings": "Settings",
                "Popup/ExtensionEnable": "The extension works on the website",
                "Popup/ExtensionDisable": "The extension turned off on the website",
                "Popup/WindowLocation": "Position of the window",
                "Popup/Feedback": "Feedback",
                "Popup/YourQuestions": "Your questions/wishes",
                "Popup/BottomLeft": "Bottom and left",
                "Popup/BotomCenter": "Bottom and center",
                "Popup/BottomRight": "Bottom and right",
                "Popup/TopLeft": "Top and left",
                "Popup/TopCenter": "Top and center",
                "Popup/TopRight": "Top and right",
                "Popup/WriteUs": "Write us",
                "Popup/IWantToTell": "I suppose, there is lack of...",
                "Popup/UnableSendMessage": "The message has not been sent",
                "Popup/TryLater": "Please, try it later",
                "Popup/MessageSuccessfullySent": "The message has been sent successfully",
                "Popup/WeWouldAppreciate": "Thank you. Your opinion is very important for us",
                "Popup/ShowWindowAutomatically": "Show files automatically",
                "Popup/NoShowWindowAutomatically": "Do not show files automatically",
                "Popup/ShowWindowAutomaticallyDesc": "When files for downloading are found out, they will be shown in pop-up automatically (works on all websites)",
                "Popup/NoShowWindowAutomaticallyDesc": "You should click on extension鈥檚 icon and the button 鈥淪how files鈥� to see files for downloading (works on all websites)",
                "Popup/ExtensionEnableDesc": "The extension is on and works on this website",
                "Popup/ExtensionDisableDesc": " The extension is off and doesn鈥檛 work on this website",
                "Popup/YourEmail": "Your email",
                "Popup/PageFilesAreFound": "Files have been found out on this page",
                "Popup/ShowFiles": "Show files",
                "Popup/PageFileNotFound": "Files for downloading have not been found out on this page",
                "Popup/EnableSuccess": "The extension has been switched on this website successfully",
                "Popup/AfterReloadEnableSuccess": "The extension will start working again on this website after reloading the page in your browser",
                "Popup/DisableSuccess": "The extension has been switched off on this website successfully",
                "Popup/AfterReloadDisableSuccess": "The extension will stop working on this website after reloading the page in your browser",
                "UI/NoShowWindowAutomatically": "Do not show automatically",
                "UI/ClearList": "Clear the list and close",
                "UI/Share": "Share",
                "UI/Close": "Close",
                "UI/downloads": "downloadings",
                "UI/TheAccountRemains": "You have <span data-balance-units>{0}</span> downloadings on your balance",
                "UI/or": "or",
                "UI/GetFree": "Get free",
                "UI/DisableAd": "Switch off ad",
                "UI/BalanceDescription1": "Advertisements will be activated when your balance is equal zero.<br/> You should replenish your balance to switch off advertisements",
                "UI/BalanceDescription2": "Advertisements are activated.<br/> You should replenish your balance to switch off advertisements",
                "UI/TheAccountRemainsSubscriptionActive": "Your subscription is active till <b>{0}</b>",
                "UI/TheAccountRemainsSubscriptionExpired": "Your subscription has expired. You can extend it",
                "UI/BalanceClickToMore": "Your subscription. Click here to know more details",
                "UI/SubscribeDoTitle": "till {0}",
                "UI/PayDownloads": "Buy or extend subscription"
            }
        }
    },
    BrowserInfo: {
        Name: "chrome"
    },
    Init: function() {
        if (MS.BrowserInfo.Name === "firefox") {
            try {
                MS.Browser.storage.sync.get();
                MS.Browser.storage.local.get(function(dataLocal) {
                    if (dataLocal && Object.keys(dataLocal).length > 0) {
                        MS.Browser.storage.sync.get(function(dataSync) {
                            if (dataSync && Object.keys(dataSync).length > 0) {
                                return;
                            }
                            MS.Browser.storage.sync.set(dataLocal, function() {
                                MS.Browser.storage.local.clear();
                            });
                        });
                    }
                });
            } catch (e) {
                MS.Browser.storage.sync = MS.Browser.storage.local;
            }
        }
    }
};

(function() {
    var urlBase = MS.Browser.runtime.getURL("");
    if (urlBase.indexOf("moz-extension://") > -1) {
        MS.BrowserInfo.Name = "firefox";
        MS.Browser.storage.sync = MS.Browser.storage.local;
    } else {
        MS.BrowserInfo.Name = "chrome";
    }
})();

require.config({
    baseUrl: "/app/",
    urlArgs: function() {
        return "bust=" + new Date().getTime();
    }(),
    config: {
        text: {
            useXhr: function(url, protocol, hostname, port) {
                return true;
            }
        }
    },
    shim: {
        i18n: {
            exports: "i18n"
        },
        semantic: {
            deps: [ "jquery" ]
        },
        linberShare: {
            deps: [ "jquery" ]
        },
        moment: {
            exports: "moment"
        }
    },
    paths: {
        app: "shared/js/app",
        linberShare: "shared/libs/LinberShare/LinberShare",
        text: "../bower_components/requirejs-text/text",
        jquery: "../bower_components/jquery/jquery.min",
        underscore: "../bower_components/underscore/underscore-min",
        backbone: "../bower_components/backbone/backbone",
        i18n: "../bower_components/i18next/i18next.min",
        moment: "../bower_components/momentjs/min/moment-with-locales",
        semantic: "../bower_components/semantic/dist/semantic.min",
        mustache: "../bower_components/mustache.js/mustache.min"
    }
});

(function(e, t) {
    function _(e) {
        var t = M[e] = {};
        return v.each(e.split(y), function(e, n) {
            t[n] = !0;
        }), t;
    }
    function H(e, n, r) {
        if (r === t && e.nodeType === 1) {
            var i = "data-" + n.replace(P, "-$1").toLowerCase();
            r = e.getAttribute(i);
            if (typeof r == "string") {
                try {
                    r = r === "true" ? !0 : r === "false" ? !1 : r === "null" ? null : +r + "" === r ? +r : D.test(r) ? v.parseJSON(r) : r;
                } catch (s) {}
                v.data(e, n, r);
            } else r = t;
        }
        return r;
    }
    function B(e) {
        var t;
        for (t in e) {
            if (t === "data" && v.isEmptyObject(e[t])) continue;
            if (t !== "toJSON") return !1;
        }
        return !0;
    }
    function et() {
        return !1;
    }
    function tt() {
        return !0;
    }
    function ut(e) {
        return !e || !e.parentNode || e.parentNode.nodeType === 11;
    }
    function at(e, t) {
        do e = e[t]; while (e && e.nodeType !== 1);
        return e;
    }
    function ft(e, t, n) {
        t = t || 0;
        if (v.isFunction(t)) return v.grep(e, function(e, r) {
            var i = !!t.call(e, r, e);
            return i === n;
        });
        if (t.nodeType) return v.grep(e, function(e, r) {
            return e === t === n;
        });
        if (typeof t == "string") {
            var r = v.grep(e, function(e) {
                return e.nodeType === 1;
            });
            if (it.test(t)) return v.filter(t, r, !n);
            t = v.filter(t, r);
        }
        return v.grep(e, function(e, r) {
            return v.inArray(e, t) >= 0 === n;
        });
    }
    function lt(e) {
        var t = ct.split("|"), n = e.createDocumentFragment();
        if (n.createElement) while (t.length) n.createElement(t.pop());
        return n;
    }
    function Lt(e, t) {
        return e.getElementsByTagName(t)[0] || e.appendChild(e.ownerDocument.createElement(t));
    }
    function At(e, t) {
        if (t.nodeType !== 1 || !v.hasData(e)) return;
        var n, r, i, s = v._data(e), o = v._data(t, s), u = s.events;
        if (u) {
            delete o.handle, o.events = {};
            for (n in u) for (r = 0, i = u[n].length; r < i; r++) v.event.add(t, n, u[n][r]);
        }
        o.data && (o.data = v.extend({}, o.data));
    }
    function Ot(e, t) {
        var n;
        if (t.nodeType !== 1) return;
        t.clearAttributes && t.clearAttributes(), t.mergeAttributes && t.mergeAttributes(e), 
        n = t.nodeName.toLowerCase(), n === "object" ? (t.parentNode && (t.outerHTML = e.outerHTML), 
        v.support.html5Clone && e.innerHTML && !v.trim(t.innerHTML) && (t.innerHTML = e.innerHTML)) : n === "input" && Et.test(e.type) ? (t.defaultChecked = t.checked = e.checked, 
        t.value !== e.value && (t.value = e.value)) : n === "option" ? t.selected = e.defaultSelected : n === "input" || n === "textarea" ? t.defaultValue = e.defaultValue : n === "script" && t.text !== e.text && (t.text = e.text), 
        t.removeAttribute(v.expando);
    }
    function Mt(e) {
        return typeof e.getElementsByTagName != "undefined" ? e.getElementsByTagName("*") : typeof e.querySelectorAll != "undefined" ? e.querySelectorAll("*") : [];
    }
    function _t(e) {
        Et.test(e.type) && (e.defaultChecked = e.checked);
    }
    function Qt(e, t) {
        if (t in e) return t;
        var n = t.charAt(0).toUpperCase() + t.slice(1), r = t, i = Jt.length;
        while (i--) {
            t = Jt[i] + n;
            if (t in e) return t;
        }
        return r;
    }
    function Gt(e, t) {
        return e = t || e, v.css(e, "display") === "none" || !v.contains(e.ownerDocument, e);
    }
    function Yt(e, t) {
        var n, r, i = [], s = 0, o = e.length;
        for (;s < o; s++) {
            n = e[s];
            if (!n.style) continue;
            i[s] = v._data(n, "olddisplay"), t ? (!i[s] && n.style.display === "none" && (n.style.display = ""), 
            n.style.display === "" && Gt(n) && (i[s] = v._data(n, "olddisplay", nn(n.nodeName)))) : (r = Dt(n, "display"), 
            !i[s] && r !== "none" && v._data(n, "olddisplay", r));
        }
        for (s = 0; s < o; s++) {
            n = e[s];
            if (!n.style) continue;
            if (!t || n.style.display === "none" || n.style.display === "") n.style.display = t ? i[s] || "" : "none";
        }
        return e;
    }
    function Zt(e, t, n) {
        var r = Rt.exec(t);
        return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t;
    }
    function en(e, t, n, r) {
        var i = n === (r ? "border" : "content") ? 4 : t === "width" ? 1 : 0, s = 0;
        for (;i < 4; i += 2) n === "margin" && (s += v.css(e, n + $t[i], !0)), r ? (n === "content" && (s -= parseFloat(Dt(e, "padding" + $t[i])) || 0), 
        n !== "margin" && (s -= parseFloat(Dt(e, "border" + $t[i] + "Width")) || 0)) : (s += parseFloat(Dt(e, "padding" + $t[i])) || 0, 
        n !== "padding" && (s += parseFloat(Dt(e, "border" + $t[i] + "Width")) || 0));
        return s;
    }
    function tn(e, t, n) {
        var r = t === "width" ? e.offsetWidth : e.offsetHeight, i = !0, s = v.support.boxSizing && v.css(e, "boxSizing") === "border-box";
        if (r <= 0 || r == null) {
            r = Dt(e, t);
            if (r < 0 || r == null) r = e.style[t];
            if (Ut.test(r)) return r;
            i = s && (v.support.boxSizingReliable || r === e.style[t]), r = parseFloat(r) || 0;
        }
        return r + en(e, t, n || (s ? "border" : "content"), i) + "px";
    }
    function nn(e) {
        if (Wt[e]) return Wt[e];
        var t = v("<" + e + ">").appendTo(i.body), n = t.css("display");
        t.remove();
        if (n === "none" || n === "") {
            Pt = i.body.appendChild(Pt || v.extend(i.createElement("iframe"), {
                frameBorder: 0,
                width: 0,
                height: 0
            }));
            if (!Ht || !Pt.createElement) Ht = (Pt.contentWindow || Pt.contentDocument).document, 
            Ht.write("<!doctype html><html><body>"), Ht.close();
            t = Ht.body.appendChild(Ht.createElement(e)), n = Dt(t, "display"), i.body.removeChild(Pt);
        }
        return Wt[e] = n, n;
    }
    function fn(e, t, n, r) {
        var i;
        if (v.isArray(t)) v.each(t, function(t, i) {
            n || sn.test(e) ? r(e, i) : fn(e + "[" + (typeof i == "object" ? t : "") + "]", i, n, r);
        }); else if (!n && v.type(t) === "object") for (i in t) fn(e + "[" + i + "]", t[i], n, r); else r(e, t);
    }
    function Cn(e) {
        return function(t, n) {
            typeof t != "string" && (n = t, t = "*");
            var r, i, s, o = t.toLowerCase().split(y), u = 0, a = o.length;
            if (v.isFunction(n)) for (;u < a; u++) r = o[u], s = /^\+/.test(r), s && (r = r.substr(1) || "*"), 
            i = e[r] = e[r] || [], i[s ? "unshift" : "push"](n);
        };
    }
    function kn(e, n, r, i, s, o) {
        s = s || n.dataTypes[0], o = o || {}, o[s] = !0;
        var u, a = e[s], f = 0, l = a ? a.length : 0, c = e === Sn;
        for (;f < l && (c || !u); f++) u = a[f](n, r, i), typeof u == "string" && (!c || o[u] ? u = t : (n.dataTypes.unshift(u), 
        u = kn(e, n, r, i, u, o)));
        return (c || !u) && !o["*"] && (u = kn(e, n, r, i, "*", o)), u;
    }
    function Ln(e, n) {
        var r, i, s = v.ajaxSettings.flatOptions || {};
        for (r in n) n[r] !== t && ((s[r] ? e : i || (i = {}))[r] = n[r]);
        i && v.extend(!0, e, i);
    }
    function An(e, n, r) {
        var i, s, o, u, a = e.contents, f = e.dataTypes, l = e.responseFields;
        for (s in l) s in r && (n[l[s]] = r[s]);
        while (f[0] === "*") f.shift(), i === t && (i = e.mimeType || n.getResponseHeader("content-type"));
        if (i) for (s in a) if (a[s] && a[s].test(i)) {
            f.unshift(s);
            break;
        }
        if (f[0] in r) o = f[0]; else {
            for (s in r) {
                if (!f[0] || e.converters[s + " " + f[0]]) {
                    o = s;
                    break;
                }
                u || (u = s);
            }
            o = o || u;
        }
        if (o) return o !== f[0] && f.unshift(o), r[o];
    }
    function On(e, t) {
        var n, r, i, s, o = e.dataTypes.slice(), u = o[0], a = {}, f = 0;
        e.dataFilter && (t = e.dataFilter(t, e.dataType));
        if (o[1]) for (n in e.converters) a[n.toLowerCase()] = e.converters[n];
        for (;i = o[++f]; ) if (i !== "*") {
            if (u !== "*" && u !== i) {
                n = a[u + " " + i] || a["* " + i];
                if (!n) for (r in a) {
                    s = r.split(" ");
                    if (s[1] === i) {
                        n = a[u + " " + s[0]] || a["* " + s[0]];
                        if (n) {
                            n === !0 ? n = a[r] : a[r] !== !0 && (i = s[0], o.splice(f--, 0, i));
                            break;
                        }
                    }
                }
                if (n !== !0) if (n && e["throws"]) t = n(t); else try {
                    t = n(t);
                } catch (l) {
                    return {
                        state: "parsererror",
                        error: n ? l : "No conversion from " + u + " to " + i
                    };
                }
            }
            u = i;
        }
        return {
            state: "success",
            data: t
        };
    }
    function Fn() {
        try {
            return new e.XMLHttpRequest();
        } catch (t) {}
    }
    function In() {
        try {
            return new e.ActiveXObject("Microsoft.XMLHTTP");
        } catch (t) {}
    }
    function $n() {
        return setTimeout(function() {
            qn = t;
        }, 0), qn = v.now();
    }
    function Jn(e, t) {
        v.each(t, function(t, n) {
            var r = (Vn[t] || []).concat(Vn["*"]), i = 0, s = r.length;
            for (;i < s; i++) if (r[i].call(e, t, n)) return;
        });
    }
    function Kn(e, t, n) {
        var r, i = 0, s = 0, o = Xn.length, u = v.Deferred().always(function() {
            delete a.elem;
        }), a = function() {
            var t = qn || $n(), n = Math.max(0, f.startTime + f.duration - t), r = n / f.duration || 0, i = 1 - r, s = 0, o = f.tweens.length;
            for (;s < o; s++) f.tweens[s].run(i);
            return u.notifyWith(e, [ f, i, n ]), i < 1 && o ? n : (u.resolveWith(e, [ f ]), 
            !1);
        }, f = u.promise({
            elem: e,
            props: v.extend({}, t),
            opts: v.extend(!0, {
                specialEasing: {}
            }, n),
            originalProperties: t,
            originalOptions: n,
            startTime: qn || $n(),
            duration: n.duration,
            tweens: [],
            createTween: function(t, n, r) {
                var i = v.Tween(e, f.opts, t, n, f.opts.specialEasing[t] || f.opts.easing);
                return f.tweens.push(i), i;
            },
            stop: function(t) {
                var n = 0, r = t ? f.tweens.length : 0;
                for (;n < r; n++) f.tweens[n].run(1);
                return t ? u.resolveWith(e, [ f, t ]) : u.rejectWith(e, [ f, t ]), this;
            }
        }), l = f.props;
        Qn(l, f.opts.specialEasing);
        for (;i < o; i++) {
            r = Xn[i].call(f, e, l, f.opts);
            if (r) return r;
        }
        return Jn(f, l), v.isFunction(f.opts.start) && f.opts.start.call(e, f), v.fx.timer(v.extend(a, {
            anim: f,
            queue: f.opts.queue,
            elem: e
        })), f.progress(f.opts.progress).done(f.opts.done, f.opts.complete).fail(f.opts.fail).always(f.opts.always);
    }
    function Qn(e, t) {
        var n, r, i, s, o;
        for (n in e) {
            r = v.camelCase(n), i = t[r], s = e[n], v.isArray(s) && (i = s[1], s = e[n] = s[0]), 
            n !== r && (e[r] = s, delete e[n]), o = v.cssHooks[r];
            if (o && "expand" in o) {
                s = o.expand(s), delete e[r];
                for (n in s) n in e || (e[n] = s[n], t[n] = i);
            } else t[r] = i;
        }
    }
    function Gn(e, t, n) {
        var r, i, s, o, u, a, f, l, c, h = this, p = e.style, d = {}, m = [], g = e.nodeType && Gt(e);
        n.queue || (l = v._queueHooks(e, "fx"), l.unqueued == null && (l.unqueued = 0, c = l.empty.fire, 
        l.empty.fire = function() {
            l.unqueued || c();
        }), l.unqueued++, h.always(function() {
            h.always(function() {
                l.unqueued--, v.queue(e, "fx").length || l.empty.fire();
            });
        })), e.nodeType === 1 && ("height" in t || "width" in t) && (n.overflow = [ p.overflow, p.overflowX, p.overflowY ], 
        v.css(e, "display") === "inline" && v.css(e, "float") === "none" && (!v.support.inlineBlockNeedsLayout || nn(e.nodeName) === "inline" ? p.display = "inline-block" : p.zoom = 1)), 
        n.overflow && (p.overflow = "hidden", v.support.shrinkWrapBlocks || h.done(function() {
            p.overflow = n.overflow[0], p.overflowX = n.overflow[1], p.overflowY = n.overflow[2];
        }));
        for (r in t) {
            s = t[r];
            if (Un.exec(s)) {
                delete t[r], a = a || s === "toggle";
                if (s === (g ? "hide" : "show")) continue;
                m.push(r);
            }
        }
        o = m.length;
        if (o) {
            u = v._data(e, "fxshow") || v._data(e, "fxshow", {}), "hidden" in u && (g = u.hidden), 
            a && (u.hidden = !g), g ? v(e).show() : h.done(function() {
                v(e).hide();
            }), h.done(function() {
                var t;
                v.removeData(e, "fxshow", !0);
                for (t in d) v.style(e, t, d[t]);
            });
            for (r = 0; r < o; r++) i = m[r], f = h.createTween(i, g ? u[i] : 0), d[i] = u[i] || v.style(e, i), 
            i in u || (u[i] = f.start, g && (f.end = f.start, f.start = i === "width" || i === "height" ? 1 : 0));
        }
    }
    function Yn(e, t, n, r, i) {
        return new Yn.prototype.init(e, t, n, r, i);
    }
    function Zn(e, t) {
        var n, r = {
            height: e
        }, i = 0;
        t = t ? 1 : 0;
        for (;i < 4; i += 2 - t) n = $t[i], r["margin" + n] = r["padding" + n] = e;
        return t && (r.opacity = r.width = e), r;
    }
    function tr(e) {
        return v.isWindow(e) ? e : e.nodeType === 9 ? e.defaultView || e.parentWindow : !1;
    }
    var n, r, i = e.document, s = e.location, o = e.navigator, u = e.jQuery, a = e.$, f = Array.prototype.push, l = Array.prototype.slice, c = Array.prototype.indexOf, h = Object.prototype.toString, p = Object.prototype.hasOwnProperty, d = String.prototype.trim, v = function(e, t) {
        return new v.fn.init(e, t, n);
    }, m = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source, g = /\S/, y = /\s+/, b = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, w = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/, E = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, S = /^[\],:{}\s]*$/, x = /(?:^|:|,)(?:\s*\[)+/g, T = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g, N = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g, C = /^-ms-/, k = /-([\da-z])/gi, L = function(e, t) {
        return (t + "").toUpperCase();
    }, A = function() {
        i.addEventListener ? (i.removeEventListener("DOMContentLoaded", A, !1), v.ready()) : i.readyState === "complete" && (i.detachEvent("onreadystatechange", A), 
        v.ready());
    }, O = {};
    v.fn = v.prototype = {
        constructor: v,
        init: function(e, n, r) {
            var s, o, u, a;
            if (!e) return this;
            if (e.nodeType) return this.context = this[0] = e, this.length = 1, this;
            if (typeof e == "string") {
                e.charAt(0) === "<" && e.charAt(e.length - 1) === ">" && e.length >= 3 ? s = [ null, e, null ] : s = w.exec(e);
                if (s && (s[1] || !n)) {
                    if (s[1]) return n = n instanceof v ? n[0] : n, a = n && n.nodeType ? n.ownerDocument || n : i, 
                    e = v.parseHTML(s[1], a, !0), E.test(s[1]) && v.isPlainObject(n) && this.attr.call(e, n, !0), 
                    v.merge(this, e);
                    o = i.getElementById(s[2]);
                    if (o && o.parentNode) {
                        if (o.id !== s[2]) return r.find(e);
                        this.length = 1, this[0] = o;
                    }
                    return this.context = i, this.selector = e, this;
                }
                return !n || n.jquery ? (n || r).find(e) : this.constructor(n).find(e);
            }
            return v.isFunction(e) ? r.ready(e) : (e.selector !== t && (this.selector = e.selector, 
            this.context = e.context), v.makeArray(e, this));
        },
        selector: "",
        jquery: "1.8.3",
        length: 0,
        size: function() {
            return this.length;
        },
        toArray: function() {
            return l.call(this);
        },
        get: function(e) {
            return e == null ? this.toArray() : e < 0 ? this[this.length + e] : this[e];
        },
        pushStack: function(e, t, n) {
            var r = v.merge(this.constructor(), e);
            return r.prevObject = this, r.context = this.context, t === "find" ? r.selector = this.selector + (this.selector ? " " : "") + n : t && (r.selector = this.selector + "." + t + "(" + n + ")"), 
            r;
        },
        each: function(e, t) {
            return v.each(this, e, t);
        },
        ready: function(e) {
            return v.ready.promise().done(e), this;
        },
        eq: function(e) {
            return e = +e, e === -1 ? this.slice(e) : this.slice(e, e + 1);
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        slice: function() {
            return this.pushStack(l.apply(this, arguments), "slice", l.call(arguments).join(","));
        },
        map: function(e) {
            return this.pushStack(v.map(this, function(t, n) {
                return e.call(t, n, t);
            }));
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: f,
        sort: [].sort,
        splice: [].splice
    }, v.fn.init.prototype = v.fn, v.extend = v.fn.extend = function() {
        var e, n, r, i, s, o, u = arguments[0] || {}, a = 1, f = arguments.length, l = !1;
        typeof u == "boolean" && (l = u, u = arguments[1] || {}, a = 2), typeof u != "object" && !v.isFunction(u) && (u = {}), 
        f === a && (u = this, --a);
        for (;a < f; a++) if ((e = arguments[a]) != null) for (n in e) {
            r = u[n], i = e[n];
            if (u === i) continue;
            l && i && (v.isPlainObject(i) || (s = v.isArray(i))) ? (s ? (s = !1, o = r && v.isArray(r) ? r : []) : o = r && v.isPlainObject(r) ? r : {}, 
            u[n] = v.extend(l, o, i)) : i !== t && (u[n] = i);
        }
        return u;
    }, v.extend({
        noConflict: function(t) {
            return e.$ === v && (e.$ = a), t && e.jQuery === v && (e.jQuery = u), v;
        },
        isReady: !1,
        readyWait: 1,
        holdReady: function(e) {
            e ? v.readyWait++ : v.ready(!0);
        },
        ready: function(e) {
            if (e === !0 ? --v.readyWait : v.isReady) return;
            if (!i.body) return setTimeout(v.ready, 1);
            v.isReady = !0;
            if (e !== !0 && --v.readyWait > 0) return;
            r.resolveWith(i, [ v ]), v.fn.trigger && v(i).trigger("ready").off("ready");
        },
        isFunction: function(e) {
            return v.type(e) === "function";
        },
        isArray: Array.isArray || function(e) {
            return v.type(e) === "array";
        },
        isWindow: function(e) {
            return e != null && e == e.window;
        },
        isNumeric: function(e) {
            return !isNaN(parseFloat(e)) && isFinite(e);
        },
        type: function(e) {
            return e == null ? String(e) : O[h.call(e)] || "object";
        },
        isPlainObject: function(e) {
            if (!e || v.type(e) !== "object" || e.nodeType || v.isWindow(e)) return !1;
            try {
                if (e.constructor && !p.call(e, "constructor") && !p.call(e.constructor.prototype, "isPrototypeOf")) return !1;
            } catch (n) {
                return !1;
            }
            var r;
            for (r in e) ;
            return r === t || p.call(e, r);
        },
        isEmptyObject: function(e) {
            var t;
            for (t in e) return !1;
            return !0;
        },
        error: function(e) {
            throw new Error(e);
        },
        parseHTML: function(e, t, n) {
            var r;
            return !e || typeof e != "string" ? null : (typeof t == "boolean" && (n = t, t = 0), 
            t = t || i, (r = E.exec(e)) ? [ t.createElement(r[1]) ] : (r = v.buildFragment([ e ], t, n ? null : []), 
            v.merge([], (r.cacheable ? v.clone(r.fragment) : r.fragment).childNodes)));
        },
        parseJSON: function(t) {
            if (!t || typeof t != "string") return null;
            t = v.trim(t);
            if (e.JSON && e.JSON.parse) return e.JSON.parse(t);
            if (S.test(t.replace(T, "@").replace(N, "]").replace(x, ""))) return new Function("return " + t)();
            v.error("Invalid JSON: " + t);
        },
        parseXML: function(n) {
            var r, i;
            if (!n || typeof n != "string") return null;
            try {
                e.DOMParser ? (i = new DOMParser(), r = i.parseFromString(n, "text/xml")) : (r = new ActiveXObject("Microsoft.XMLDOM"), 
                r.async = "false", r.loadXML(n));
            } catch (s) {
                r = t;
            }
            return (!r || !r.documentElement || r.getElementsByTagName("parsererror").length) && v.error("Invalid XML: " + n), 
            r;
        },
        noop: function() {},
        globalEval: function(t) {
            t && g.test(t) && (e.execScript || function(t) {
                e.eval.call(e, t);
            })(t);
        },
        camelCase: function(e) {
            return e.replace(C, "ms-").replace(k, L);
        },
        nodeName: function(e, t) {
            return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
        },
        each: function(e, n, r) {
            var i, s = 0, o = e.length, u = o === t || v.isFunction(e);
            if (r) {
                if (u) {
                    for (i in e) if (n.apply(e[i], r) === !1) break;
                } else for (;s < o; ) if (n.apply(e[s++], r) === !1) break;
            } else if (u) {
                for (i in e) if (n.call(e[i], i, e[i]) === !1) break;
            } else for (;s < o; ) if (n.call(e[s], s, e[s++]) === !1) break;
            return e;
        },
        trim: d && !d.call("\ufeff聽") ? function(e) {
            return e == null ? "" : d.call(e);
        } : function(e) {
            return e == null ? "" : (e + "").replace(b, "");
        },
        makeArray: function(e, t) {
            var n, r = t || [];
            return e != null && (n = v.type(e), e.length == null || n === "string" || n === "function" || n === "regexp" || v.isWindow(e) ? f.call(r, e) : v.merge(r, e)), 
            r;
        },
        inArray: function(e, t, n) {
            var r;
            if (t) {
                if (c) return c.call(t, e, n);
                r = t.length, n = n ? n < 0 ? Math.max(0, r + n) : n : 0;
                for (;n < r; n++) if (n in t && t[n] === e) return n;
            }
            return -1;
        },
        merge: function(e, n) {
            var r = n.length, i = e.length, s = 0;
            if (typeof r == "number") for (;s < r; s++) e[i++] = n[s]; else while (n[s] !== t) e[i++] = n[s++];
            return e.length = i, e;
        },
        grep: function(e, t, n) {
            var r, i = [], s = 0, o = e.length;
            n = !!n;
            for (;s < o; s++) r = !!t(e[s], s), n !== r && i.push(e[s]);
            return i;
        },
        map: function(e, n, r) {
            var i, s, o = [], u = 0, a = e.length, f = e instanceof v || a !== t && typeof a == "number" && (a > 0 && e[0] && e[a - 1] || a === 0 || v.isArray(e));
            if (f) for (;u < a; u++) i = n(e[u], u, r), i != null && (o[o.length] = i); else for (s in e) i = n(e[s], s, r), 
            i != null && (o[o.length] = i);
            return o.concat.apply([], o);
        },
        guid: 1,
        proxy: function(e, n) {
            var r, i, s;
            return typeof n == "string" && (r = e[n], n = e, e = r), v.isFunction(e) ? (i = l.call(arguments, 2), 
            s = function() {
                return e.apply(n, i.concat(l.call(arguments)));
            }, s.guid = e.guid = e.guid || v.guid++, s) : t;
        },
        access: function(e, n, r, i, s, o, u) {
            var a, f = r == null, l = 0, c = e.length;
            if (r && typeof r == "object") {
                for (l in r) v.access(e, n, l, r[l], 1, o, i);
                s = 1;
            } else if (i !== t) {
                a = u === t && v.isFunction(i), f && (a ? (a = n, n = function(e, t, n) {
                    return a.call(v(e), n);
                }) : (n.call(e, i), n = null));
                if (n) for (;l < c; l++) n(e[l], r, a ? i.call(e[l], l, n(e[l], r)) : i, u);
                s = 1;
            }
            return s ? e : f ? n.call(e) : c ? n(e[0], r) : o;
        },
        now: function() {
            return new Date().getTime();
        }
    }), v.ready.promise = function(t) {
        if (!r) {
            r = v.Deferred();
            if (i.readyState === "complete") setTimeout(v.ready, 1); else if (i.addEventListener) i.addEventListener("DOMContentLoaded", A, !1), 
            e.addEventListener("load", v.ready, !1); else {
                i.attachEvent("onreadystatechange", A), e.attachEvent("onload", v.ready);
                var n = !1;
                try {
                    n = e.frameElement == null && i.documentElement;
                } catch (s) {}
                n && n.doScroll && function o() {
                    if (!v.isReady) {
                        try {
                            n.doScroll("left");
                        } catch (e) {
                            return setTimeout(o, 50);
                        }
                        v.ready();
                    }
                }();
            }
        }
        return r.promise(t);
    }, v.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(e, t) {
        O["[object " + t + "]"] = t.toLowerCase();
    }), n = v(i);
    var M = {};
    v.Callbacks = function(e) {
        e = typeof e == "string" ? M[e] || _(e) : v.extend({}, e);
        var n, r, i, s, o, u, a = [], f = !e.once && [], l = function(t) {
            n = e.memory && t, r = !0, u = s || 0, s = 0, o = a.length, i = !0;
            for (;a && u < o; u++) if (a[u].apply(t[0], t[1]) === !1 && e.stopOnFalse) {
                n = !1;
                break;
            }
            i = !1, a && (f ? f.length && l(f.shift()) : n ? a = [] : c.disable());
        }, c = {
            add: function() {
                if (a) {
                    var t = a.length;
                    (function r(t) {
                        v.each(t, function(t, n) {
                            var i = v.type(n);
                            i === "function" ? (!e.unique || !c.has(n)) && a.push(n) : n && n.length && i !== "string" && r(n);
                        });
                    })(arguments), i ? o = a.length : n && (s = t, l(n));
                }
                return this;
            },
            remove: function() {
                return a && v.each(arguments, function(e, t) {
                    var n;
                    while ((n = v.inArray(t, a, n)) > -1) a.splice(n, 1), i && (n <= o && o--, n <= u && u--);
                }), this;
            },
            has: function(e) {
                return v.inArray(e, a) > -1;
            },
            empty: function() {
                return a = [], this;
            },
            disable: function() {
                return a = f = n = t, this;
            },
            disabled: function() {
                return !a;
            },
            lock: function() {
                return f = t, n || c.disable(), this;
            },
            locked: function() {
                return !f;
            },
            fireWith: function(e, t) {
                return t = t || [], t = [ e, t.slice ? t.slice() : t ], a && (!r || f) && (i ? f.push(t) : l(t)), 
                this;
            },
            fire: function() {
                return c.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!r;
            }
        };
        return c;
    }, v.extend({
        Deferred: function(e) {
            var t = [ [ "resolve", "done", v.Callbacks("once memory"), "resolved" ], [ "reject", "fail", v.Callbacks("once memory"), "rejected" ], [ "notify", "progress", v.Callbacks("memory") ] ], n = "pending", r = {
                state: function() {
                    return n;
                },
                always: function() {
                    return i.done(arguments).fail(arguments), this;
                },
                then: function() {
                    var e = arguments;
                    return v.Deferred(function(n) {
                        v.each(t, function(t, r) {
                            var s = r[0], o = e[t];
                            i[r[1]](v.isFunction(o) ? function() {
                                var e = o.apply(this, arguments);
                                e && v.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[s + "With"](this === i ? n : this, [ e ]);
                            } : n[s]);
                        }), e = null;
                    }).promise();
                },
                promise: function(e) {
                    return e != null ? v.extend(e, r) : r;
                }
            }, i = {};
            return r.pipe = r.then, v.each(t, function(e, s) {
                var o = s[2], u = s[3];
                r[s[1]] = o.add, u && o.add(function() {
                    n = u;
                }, t[e ^ 1][2].disable, t[2][2].lock), i[s[0]] = o.fire, i[s[0] + "With"] = o.fireWith;
            }), r.promise(i), e && e.call(i, i), i;
        },
        when: function(e) {
            var t = 0, n = l.call(arguments), r = n.length, i = r !== 1 || e && v.isFunction(e.promise) ? r : 0, s = i === 1 ? e : v.Deferred(), o = function(e, t, n) {
                return function(r) {
                    t[e] = this, n[e] = arguments.length > 1 ? l.call(arguments) : r, n === u ? s.notifyWith(t, n) : --i || s.resolveWith(t, n);
                };
            }, u, a, f;
            if (r > 1) {
                u = new Array(r), a = new Array(r), f = new Array(r);
                for (;t < r; t++) n[t] && v.isFunction(n[t].promise) ? n[t].promise().done(o(t, f, n)).fail(s.reject).progress(o(t, a, u)) : --i;
            }
            return i || s.resolveWith(f, n), s.promise();
        }
    }), v.support = function() {
        var t, n, r, s, o, u, a, f, l, c, h, p = i.createElement("div");
        p.setAttribute("className", "t"), p.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        n = p.getElementsByTagName("*"), r = p.getElementsByTagName("a")[0];
        if (!n || !r || !n.length) return {};
        s = i.createElement("select"), o = s.appendChild(i.createElement("option")), u = p.getElementsByTagName("input")[0], 
        r.style.cssText = "top:1px;float:left;opacity:.5", t = {
            leadingWhitespace: p.firstChild.nodeType === 3,
            tbody: !p.getElementsByTagName("tbody").length,
            htmlSerialize: !!p.getElementsByTagName("link").length,
            style: /top/.test(r.getAttribute("style")),
            hrefNormalized: r.getAttribute("href") === "/a",
            opacity: /^0.5/.test(r.style.opacity),
            cssFloat: !!r.style.cssFloat,
            checkOn: u.value === "on",
            optSelected: o.selected,
            getSetAttribute: p.className !== "t",
            enctype: !!i.createElement("form").enctype,
            html5Clone: i.createElement("nav").cloneNode(!0).outerHTML !== "<:nav></:nav>",
            boxModel: i.compatMode === "CSS1Compat",
            submitBubbles: !0,
            changeBubbles: !0,
            focusinBubbles: !1,
            deleteExpando: !0,
            noCloneEvent: !0,
            inlineBlockNeedsLayout: !1,
            shrinkWrapBlocks: !1,
            reliableMarginRight: !0,
            boxSizingReliable: !0,
            pixelPosition: !1
        }, u.checked = !0, t.noCloneChecked = u.cloneNode(!0).checked, s.disabled = !0, 
        t.optDisabled = !o.disabled;
        try {
            delete p.test;
        } catch (d) {
            t.deleteExpando = !1;
        }
        !p.addEventListener && p.attachEvent && p.fireEvent && (p.attachEvent("onclick", h = function() {
            t.noCloneEvent = !1;
        }), p.cloneNode(!0).fireEvent("onclick"), p.detachEvent("onclick", h)), u = i.createElement("input"), 
        u.value = "t", u.setAttribute("type", "radio"), t.radioValue = u.value === "t", 
        u.setAttribute("checked", "checked"), u.setAttribute("name", "t"), p.appendChild(u), 
        a = i.createDocumentFragment(), a.appendChild(p.lastChild), t.checkClone = a.cloneNode(!0).cloneNode(!0).lastChild.checked, 
        t.appendChecked = u.checked, a.removeChild(u), a.appendChild(p);
        if (p.attachEvent) for (l in {
            submit: !0,
            change: !0,
            focusin: !0
        }) f = "on" + l, c = f in p, c || (p.setAttribute(f, "return;"), c = typeof p[f] == "function"), 
        t[l + "Bubbles"] = c;
        return v(function() {
            var n, r, s, o, u = "padding:0;margin:0;border:0;display:block;overflow:hidden;", a = i.getElementsByTagName("body")[0];
            if (!a) return;
            n = i.createElement("div"), n.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px", 
            a.insertBefore(n, a.firstChild), r = i.createElement("div"), n.appendChild(r), r.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", 
            s = r.getElementsByTagName("td"), s[0].style.cssText = "padding:0;margin:0;border:0;display:none", 
            c = s[0].offsetHeight === 0, s[0].style.display = "", s[1].style.display = "none", 
            t.reliableHiddenOffsets = c && s[0].offsetHeight === 0, r.innerHTML = "", r.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;", 
            t.boxSizing = r.offsetWidth === 4, t.doesNotIncludeMarginInBodyOffset = a.offsetTop !== 1, 
            e.getComputedStyle && (t.pixelPosition = (e.getComputedStyle(r, null) || {}).top !== "1%", 
            t.boxSizingReliable = (e.getComputedStyle(r, null) || {
                width: "4px"
            }).width === "4px", o = i.createElement("div"), o.style.cssText = r.style.cssText = u, 
            o.style.marginRight = o.style.width = "0", r.style.width = "1px", r.appendChild(o), 
            t.reliableMarginRight = !parseFloat((e.getComputedStyle(o, null) || {}).marginRight)), 
            typeof r.style.zoom != "undefined" && (r.innerHTML = "", r.style.cssText = u + "width:1px;padding:1px;display:inline;zoom:1", 
            t.inlineBlockNeedsLayout = r.offsetWidth === 3, r.style.display = "block", r.style.overflow = "visible", 
            r.innerHTML = "<div></div>", r.firstChild.style.width = "5px", t.shrinkWrapBlocks = r.offsetWidth !== 3, 
            n.style.zoom = 1), a.removeChild(n), n = r = s = o = null;
        }), a.removeChild(p), n = r = s = o = u = a = p = null, t;
    }();
    var D = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, P = /([A-Z])/g;
    v.extend({
        cache: {},
        deletedIds: [],
        uuid: 0,
        expando: "jQuery" + (v.fn.jquery + Math.random()).replace(/\D/g, ""),
        noData: {
            embed: !0,
            object: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            applet: !0
        },
        hasData: function(e) {
            return e = e.nodeType ? v.cache[e[v.expando]] : e[v.expando], !!e && !B(e);
        },
        data: function(e, n, r, i) {
            if (!v.acceptData(e)) return;
            var s, o, u = v.expando, a = typeof n == "string", f = e.nodeType, l = f ? v.cache : e, c = f ? e[u] : e[u] && u;
            if ((!c || !l[c] || !i && !l[c].data) && a && r === t) return;
            c || (f ? e[u] = c = v.deletedIds.pop() || v.guid++ : c = u), l[c] || (l[c] = {}, 
            f || (l[c].toJSON = v.noop));
            if (typeof n == "object" || typeof n == "function") i ? l[c] = v.extend(l[c], n) : l[c].data = v.extend(l[c].data, n);
            return s = l[c], i || (s.data || (s.data = {}), s = s.data), r !== t && (s[v.camelCase(n)] = r), 
            a ? (o = s[n], o == null && (o = s[v.camelCase(n)])) : o = s, o;
        },
        removeData: function(e, t, n) {
            if (!v.acceptData(e)) return;
            var r, i, s, o = e.nodeType, u = o ? v.cache : e, a = o ? e[v.expando] : v.expando;
            if (!u[a]) return;
            if (t) {
                r = n ? u[a] : u[a].data;
                if (r) {
                    v.isArray(t) || (t in r ? t = [ t ] : (t = v.camelCase(t), t in r ? t = [ t ] : t = t.split(" ")));
                    for (i = 0, s = t.length; i < s; i++) delete r[t[i]];
                    if (!(n ? B : v.isEmptyObject)(r)) return;
                }
            }
            if (!n) {
                delete u[a].data;
                if (!B(u[a])) return;
            }
            o ? v.cleanData([ e ], !0) : v.support.deleteExpando || u != u.window ? delete u[a] : u[a] = null;
        },
        _data: function(e, t, n) {
            return v.data(e, t, n, !0);
        },
        acceptData: function(e) {
            var t = e.nodeName && v.noData[e.nodeName.toLowerCase()];
            return !t || t !== !0 && e.getAttribute("classid") === t;
        }
    }), v.fn.extend({
        data: function(e, n) {
            var r, i, s, o, u, a = this[0], f = 0, l = null;
            if (e === t) {
                if (this.length) {
                    l = v.data(a);
                    if (a.nodeType === 1 && !v._data(a, "parsedAttrs")) {
                        s = a.attributes;
                        for (u = s.length; f < u; f++) o = s[f].name, o.indexOf("data-") || (o = v.camelCase(o.substring(5)), 
                        H(a, o, l[o]));
                        v._data(a, "parsedAttrs", !0);
                    }
                }
                return l;
            }
            return typeof e == "object" ? this.each(function() {
                v.data(this, e);
            }) : (r = e.split(".", 2), r[1] = r[1] ? "." + r[1] : "", i = r[1] + "!", v.access(this, function(n) {
                if (n === t) return l = this.triggerHandler("getData" + i, [ r[0] ]), l === t && a && (l = v.data(a, e), 
                l = H(a, e, l)), l === t && r[1] ? this.data(r[0]) : l;
                r[1] = n, this.each(function() {
                    var t = v(this);
                    t.triggerHandler("setData" + i, r), v.data(this, e, n), t.triggerHandler("changeData" + i, r);
                });
            }, null, n, arguments.length > 1, null, !1));
        },
        removeData: function(e) {
            return this.each(function() {
                v.removeData(this, e);
            });
        }
    }), v.extend({
        queue: function(e, t, n) {
            var r;
            if (e) return t = (t || "fx") + "queue", r = v._data(e, t), n && (!r || v.isArray(n) ? r = v._data(e, t, v.makeArray(n)) : r.push(n)), 
            r || [];
        },
        dequeue: function(e, t) {
            t = t || "fx";
            var n = v.queue(e, t), r = n.length, i = n.shift(), s = v._queueHooks(e, t), o = function() {
                v.dequeue(e, t);
            };
            i === "inprogress" && (i = n.shift(), r--), i && (t === "fx" && n.unshift("inprogress"), 
            delete s.stop, i.call(e, o, s)), !r && s && s.empty.fire();
        },
        _queueHooks: function(e, t) {
            var n = t + "queueHooks";
            return v._data(e, n) || v._data(e, n, {
                empty: v.Callbacks("once memory").add(function() {
                    v.removeData(e, t + "queue", !0), v.removeData(e, n, !0);
                })
            });
        }
    }), v.fn.extend({
        queue: function(e, n) {
            var r = 2;
            return typeof e != "string" && (n = e, e = "fx", r--), arguments.length < r ? v.queue(this[0], e) : n === t ? this : this.each(function() {
                var t = v.queue(this, e, n);
                v._queueHooks(this, e), e === "fx" && t[0] !== "inprogress" && v.dequeue(this, e);
            });
        },
        dequeue: function(e) {
            return this.each(function() {
                v.dequeue(this, e);
            });
        },
        delay: function(e, t) {
            return e = v.fx ? v.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function(t, n) {
                var r = setTimeout(t, e);
                n.stop = function() {
                    clearTimeout(r);
                };
            });
        },
        clearQueue: function(e) {
            return this.queue(e || "fx", []);
        },
        promise: function(e, n) {
            var r, i = 1, s = v.Deferred(), o = this, u = this.length, a = function() {
                --i || s.resolveWith(o, [ o ]);
            };
            typeof e != "string" && (n = e, e = t), e = e || "fx";
            while (u--) r = v._data(o[u], e + "queueHooks"), r && r.empty && (i++, r.empty.add(a));
            return a(), s.promise(n);
        }
    });
    var j, F, I, q = /[\t\r\n]/g, R = /\r/g, U = /^(?:button|input)$/i, z = /^(?:button|input|object|select|textarea)$/i, W = /^a(?:rea|)$/i, X = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i, V = v.support.getSetAttribute;
    v.fn.extend({
        attr: function(e, t) {
            return v.access(this, v.attr, e, t, arguments.length > 1);
        },
        removeAttr: function(e) {
            return this.each(function() {
                v.removeAttr(this, e);
            });
        },
        prop: function(e, t) {
            return v.access(this, v.prop, e, t, arguments.length > 1);
        },
        removeProp: function(e) {
            return e = v.propFix[e] || e, this.each(function() {
                try {
                    this[e] = t, delete this[e];
                } catch (n) {}
            });
        },
        addClass: function(e) {
            var t, n, r, i, s, o, u;
            if (v.isFunction(e)) return this.each(function(t) {
                v(this).addClass(e.call(this, t, this.className));
            });
            if (e && typeof e == "string") {
                t = e.split(y);
                for (n = 0, r = this.length; n < r; n++) {
                    i = this[n];
                    if (i.nodeType === 1) if (!i.className && t.length === 1) i.className = e; else {
                        s = " " + i.className + " ";
                        for (o = 0, u = t.length; o < u; o++) s.indexOf(" " + t[o] + " ") < 0 && (s += t[o] + " ");
                        i.className = v.trim(s);
                    }
                }
            }
            return this;
        },
        removeClass: function(e) {
            var n, r, i, s, o, u, a;
            if (v.isFunction(e)) return this.each(function(t) {
                v(this).removeClass(e.call(this, t, this.className));
            });
            if (e && typeof e == "string" || e === t) {
                n = (e || "").split(y);
                for (u = 0, a = this.length; u < a; u++) {
                    i = this[u];
                    if (i.nodeType === 1 && i.className) {
                        r = (" " + i.className + " ").replace(q, " ");
                        for (s = 0, o = n.length; s < o; s++) while (r.indexOf(" " + n[s] + " ") >= 0) r = r.replace(" " + n[s] + " ", " ");
                        i.className = e ? v.trim(r) : "";
                    }
                }
            }
            return this;
        },
        toggleClass: function(e, t) {
            var n = typeof e, r = typeof t == "boolean";
            return v.isFunction(e) ? this.each(function(n) {
                v(this).toggleClass(e.call(this, n, this.className, t), t);
            }) : this.each(function() {
                if (n === "string") {
                    var i, s = 0, o = v(this), u = t, a = e.split(y);
                    while (i = a[s++]) u = r ? u : !o.hasClass(i), o[u ? "addClass" : "removeClass"](i);
                } else if (n === "undefined" || n === "boolean") this.className && v._data(this, "__className__", this.className), 
                this.className = this.className || e === !1 ? "" : v._data(this, "__className__") || "";
            });
        },
        hasClass: function(e) {
            var t = " " + e + " ", n = 0, r = this.length;
            for (;n < r; n++) if (this[n].nodeType === 1 && (" " + this[n].className + " ").replace(q, " ").indexOf(t) >= 0) return !0;
            return !1;
        },
        val: function(e) {
            var n, r, i, s = this[0];
            if (!arguments.length) {
                if (s) return n = v.valHooks[s.type] || v.valHooks[s.nodeName.toLowerCase()], n && "get" in n && (r = n.get(s, "value")) !== t ? r : (r = s.value, 
                typeof r == "string" ? r.replace(R, "") : r == null ? "" : r);
                return;
            }
            return i = v.isFunction(e), this.each(function(r) {
                var s, o = v(this);
                if (this.nodeType !== 1) return;
                i ? s = e.call(this, r, o.val()) : s = e, s == null ? s = "" : typeof s == "number" ? s += "" : v.isArray(s) && (s = v.map(s, function(e) {
                    return e == null ? "" : e + "";
                })), n = v.valHooks[this.type] || v.valHooks[this.nodeName.toLowerCase()];
                if (!n || !("set" in n) || n.set(this, s, "value") === t) this.value = s;
            });
        }
    }), v.extend({
        valHooks: {
            option: {
                get: function(e) {
                    var t = e.attributes.value;
                    return !t || t.specified ? e.value : e.text;
                }
            },
            select: {
                get: function(e) {
                    var t, n, r = e.options, i = e.selectedIndex, s = e.type === "select-one" || i < 0, o = s ? null : [], u = s ? i + 1 : r.length, a = i < 0 ? u : s ? i : 0;
                    for (;a < u; a++) {
                        n = r[a];
                        if ((n.selected || a === i) && (v.support.optDisabled ? !n.disabled : n.getAttribute("disabled") === null) && (!n.parentNode.disabled || !v.nodeName(n.parentNode, "optgroup"))) {
                            t = v(n).val();
                            if (s) return t;
                            o.push(t);
                        }
                    }
                    return o;
                },
                set: function(e, t) {
                    var n = v.makeArray(t);
                    return v(e).find("option").each(function() {
                        this.selected = v.inArray(v(this).val(), n) >= 0;
                    }), n.length || (e.selectedIndex = -1), n;
                }
            }
        },
        attrFn: {},
        attr: function(e, n, r, i) {
            var s, o, u, a = e.nodeType;
            if (!e || a === 3 || a === 8 || a === 2) return;
            if (i && v.isFunction(v.fn[n])) return v(e)[n](r);
            if (typeof e.getAttribute == "undefined") return v.prop(e, n, r);
            u = a !== 1 || !v.isXMLDoc(e), u && (n = n.toLowerCase(), o = v.attrHooks[n] || (X.test(n) ? F : j));
            if (r !== t) {
                if (r === null) {
                    v.removeAttr(e, n);
                    return;
                }
                return o && "set" in o && u && (s = o.set(e, r, n)) !== t ? s : (e.setAttribute(n, r + ""), 
                r);
            }
            return o && "get" in o && u && (s = o.get(e, n)) !== null ? s : (s = e.getAttribute(n), 
            s === null ? t : s);
        },
        removeAttr: function(e, t) {
            var n, r, i, s, o = 0;
            if (t && e.nodeType === 1) {
                r = t.split(y);
                for (;o < r.length; o++) i = r[o], i && (n = v.propFix[i] || i, s = X.test(i), s || v.attr(e, i, ""), 
                e.removeAttribute(V ? i : n), s && n in e && (e[n] = !1));
            }
        },
        attrHooks: {
            type: {
                set: function(e, t) {
                    if (U.test(e.nodeName) && e.parentNode) v.error("type property can't be changed"); else if (!v.support.radioValue && t === "radio" && v.nodeName(e, "input")) {
                        var n = e.value;
                        return e.setAttribute("type", t), n && (e.value = n), t;
                    }
                }
            },
            value: {
                get: function(e, t) {
                    return j && v.nodeName(e, "button") ? j.get(e, t) : t in e ? e.value : null;
                },
                set: function(e, t, n) {
                    if (j && v.nodeName(e, "button")) return j.set(e, t, n);
                    e.value = t;
                }
            }
        },
        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            for: "htmlFor",
            class: "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },
        prop: function(e, n, r) {
            var i, s, o, u = e.nodeType;
            if (!e || u === 3 || u === 8 || u === 2) return;
            return o = u !== 1 || !v.isXMLDoc(e), o && (n = v.propFix[n] || n, s = v.propHooks[n]), 
            r !== t ? s && "set" in s && (i = s.set(e, r, n)) !== t ? i : e[n] = r : s && "get" in s && (i = s.get(e, n)) !== null ? i : e[n];
        },
        propHooks: {
            tabIndex: {
                get: function(e) {
                    var n = e.getAttributeNode("tabindex");
                    return n && n.specified ? parseInt(n.value, 10) : z.test(e.nodeName) || W.test(e.nodeName) && e.href ? 0 : t;
                }
            }
        }
    }), F = {
        get: function(e, n) {
            var r, i = v.prop(e, n);
            return i === !0 || typeof i != "boolean" && (r = e.getAttributeNode(n)) && r.nodeValue !== !1 ? n.toLowerCase() : t;
        },
        set: function(e, t, n) {
            var r;
            return t === !1 ? v.removeAttr(e, n) : (r = v.propFix[n] || n, r in e && (e[r] = !0), 
            e.setAttribute(n, n.toLowerCase())), n;
        }
    }, V || (I = {
        name: !0,
        id: !0,
        coords: !0
    }, j = v.valHooks.button = {
        get: function(e, n) {
            var r;
            return r = e.getAttributeNode(n), r && (I[n] ? r.value !== "" : r.specified) ? r.value : t;
        },
        set: function(e, t, n) {
            var r = e.getAttributeNode(n);
            return r || (r = i.createAttribute(n), e.setAttributeNode(r)), r.value = t + "";
        }
    }, v.each([ "width", "height" ], function(e, t) {
        v.attrHooks[t] = v.extend(v.attrHooks[t], {
            set: function(e, n) {
                if (n === "") return e.setAttribute(t, "auto"), n;
            }
        });
    }), v.attrHooks.contenteditable = {
        get: j.get,
        set: function(e, t, n) {
            t === "" && (t = "false"), j.set(e, t, n);
        }
    }), v.support.hrefNormalized || v.each([ "href", "src", "width", "height" ], function(e, n) {
        v.attrHooks[n] = v.extend(v.attrHooks[n], {
            get: function(e) {
                var r = e.getAttribute(n, 2);
                return r === null ? t : r;
            }
        });
    }), v.support.style || (v.attrHooks.style = {
        get: function(e) {
            return e.style.cssText.toLowerCase() || t;
        },
        set: function(e, t) {
            return e.style.cssText = t + "";
        }
    }), v.support.optSelected || (v.propHooks.selected = v.extend(v.propHooks.selected, {
        get: function(e) {
            var t = e.parentNode;
            return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null;
        }
    })), v.support.enctype || (v.propFix.enctype = "encoding"), v.support.checkOn || v.each([ "radio", "checkbox" ], function() {
        v.valHooks[this] = {
            get: function(e) {
                return e.getAttribute("value") === null ? "on" : e.value;
            }
        };
    }), v.each([ "radio", "checkbox" ], function() {
        v.valHooks[this] = v.extend(v.valHooks[this], {
            set: function(e, t) {
                if (v.isArray(t)) return e.checked = v.inArray(v(e).val(), t) >= 0;
            }
        });
    });
    var $ = /^(?:textarea|input|select)$/i, J = /^([^\.]*|)(?:\.(.+)|)$/, K = /(?:^|\s)hover(\.\S+|)\b/, Q = /^key/, G = /^(?:mouse|contextmenu)|click/, Y = /^(?:focusinfocus|focusoutblur)$/, Z = function(e) {
        return v.event.special.hover ? e : e.replace(K, "mouseenter$1 mouseleave$1");
    };
    v.event = {
        add: function(e, n, r, i, s) {
            var o, u, a, f, l, c, h, p, d, m, g;
            if (e.nodeType === 3 || e.nodeType === 8 || !n || !r || !(o = v._data(e))) return;
            r.handler && (d = r, r = d.handler, s = d.selector), r.guid || (r.guid = v.guid++), 
            a = o.events, a || (o.events = a = {}), u = o.handle, u || (o.handle = u = function(e) {
                return typeof v == "undefined" || !!e && v.event.triggered === e.type ? t : v.event.dispatch.apply(u.elem, arguments);
            }, u.elem = e), n = v.trim(Z(n)).split(" ");
            for (f = 0; f < n.length; f++) {
                l = J.exec(n[f]) || [], c = l[1], h = (l[2] || "").split(".").sort(), g = v.event.special[c] || {}, 
                c = (s ? g.delegateType : g.bindType) || c, g = v.event.special[c] || {}, p = v.extend({
                    type: c,
                    origType: l[1],
                    data: i,
                    handler: r,
                    guid: r.guid,
                    selector: s,
                    needsContext: s && v.expr.match.needsContext.test(s),
                    namespace: h.join(".")
                }, d), m = a[c];
                if (!m) {
                    m = a[c] = [], m.delegateCount = 0;
                    if (!g.setup || g.setup.call(e, i, h, u) === !1) e.addEventListener ? e.addEventListener(c, u, !1) : e.attachEvent && e.attachEvent("on" + c, u);
                }
                g.add && (g.add.call(e, p), p.handler.guid || (p.handler.guid = r.guid)), s ? m.splice(m.delegateCount++, 0, p) : m.push(p), 
                v.event.global[c] = !0;
            }
            e = null;
        },
        global: {},
        remove: function(e, t, n, r, i) {
            var s, o, u, a, f, l, c, h, p, d, m, g = v.hasData(e) && v._data(e);
            if (!g || !(h = g.events)) return;
            t = v.trim(Z(t || "")).split(" ");
            for (s = 0; s < t.length; s++) {
                o = J.exec(t[s]) || [], u = a = o[1], f = o[2];
                if (!u) {
                    for (u in h) v.event.remove(e, u + t[s], n, r, !0);
                    continue;
                }
                p = v.event.special[u] || {}, u = (r ? p.delegateType : p.bindType) || u, d = h[u] || [], 
                l = d.length, f = f ? new RegExp("(^|\\.)" + f.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
                for (c = 0; c < d.length; c++) m = d[c], (i || a === m.origType) && (!n || n.guid === m.guid) && (!f || f.test(m.namespace)) && (!r || r === m.selector || r === "**" && m.selector) && (d.splice(c--, 1), 
                m.selector && d.delegateCount--, p.remove && p.remove.call(e, m));
                d.length === 0 && l !== d.length && ((!p.teardown || p.teardown.call(e, f, g.handle) === !1) && v.removeEvent(e, u, g.handle), 
                delete h[u]);
            }
            v.isEmptyObject(h) && (delete g.handle, v.removeData(e, "events", !0));
        },
        customEvent: {
            getData: !0,
            setData: !0,
            changeData: !0
        },
        trigger: function(n, r, s, o) {
            if (!s || s.nodeType !== 3 && s.nodeType !== 8) {
                var u, a, f, l, c, h, p, d, m, g, y = n.type || n, b = [];
                if (Y.test(y + v.event.triggered)) return;
                y.indexOf("!") >= 0 && (y = y.slice(0, -1), a = !0), y.indexOf(".") >= 0 && (b = y.split("."), 
                y = b.shift(), b.sort());
                if ((!s || v.event.customEvent[y]) && !v.event.global[y]) return;
                n = typeof n == "object" ? n[v.expando] ? n : new v.Event(y, n) : new v.Event(y), 
                n.type = y, n.isTrigger = !0, n.exclusive = a, n.namespace = b.join("."), n.namespace_re = n.namespace ? new RegExp("(^|\\.)" + b.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
                h = y.indexOf(":") < 0 ? "on" + y : "";
                if (!s) {
                    u = v.cache;
                    for (f in u) u[f].events && u[f].events[y] && v.event.trigger(n, r, u[f].handle.elem, !0);
                    return;
                }
                n.result = t, n.target || (n.target = s), r = r != null ? v.makeArray(r) : [], r.unshift(n), 
                p = v.event.special[y] || {};
                if (p.trigger && p.trigger.apply(s, r) === !1) return;
                m = [ [ s, p.bindType || y ] ];
                if (!o && !p.noBubble && !v.isWindow(s)) {
                    g = p.delegateType || y, l = Y.test(g + y) ? s : s.parentNode;
                    for (c = s; l; l = l.parentNode) m.push([ l, g ]), c = l;
                    c === (s.ownerDocument || i) && m.push([ c.defaultView || c.parentWindow || e, g ]);
                }
                for (f = 0; f < m.length && !n.isPropagationStopped(); f++) l = m[f][0], n.type = m[f][1], 
                d = (v._data(l, "events") || {})[n.type] && v._data(l, "handle"), d && d.apply(l, r), 
                d = h && l[h], d && v.acceptData(l) && d.apply && d.apply(l, r) === !1 && n.preventDefault();
                return n.type = y, !o && !n.isDefaultPrevented() && (!p._default || p._default.apply(s.ownerDocument, r) === !1) && (y !== "click" || !v.nodeName(s, "a")) && v.acceptData(s) && h && s[y] && (y !== "focus" && y !== "blur" || n.target.offsetWidth !== 0) && !v.isWindow(s) && (c = s[h], 
                c && (s[h] = null), v.event.triggered = y, s[y](), v.event.triggered = t, c && (s[h] = c)), 
                n.result;
            }
            return;
        },
        dispatch: function(n) {
            n = v.event.fix(n || e.event);
            var r, i, s, o, u, a, f, c, h, p, d = (v._data(this, "events") || {})[n.type] || [], m = d.delegateCount, g = l.call(arguments), y = !n.exclusive && !n.namespace, b = v.event.special[n.type] || {}, w = [];
            g[0] = n, n.delegateTarget = this;
            if (b.preDispatch && b.preDispatch.call(this, n) === !1) return;
            if (m && (!n.button || n.type !== "click")) for (s = n.target; s != this; s = s.parentNode || this) if (s.disabled !== !0 || n.type !== "click") {
                u = {}, f = [];
                for (r = 0; r < m; r++) c = d[r], h = c.selector, u[h] === t && (u[h] = c.needsContext ? v(h, this).index(s) >= 0 : v.find(h, this, null, [ s ]).length), 
                u[h] && f.push(c);
                f.length && w.push({
                    elem: s,
                    matches: f
                });
            }
            d.length > m && w.push({
                elem: this,
                matches: d.slice(m)
            });
            for (r = 0; r < w.length && !n.isPropagationStopped(); r++) {
                a = w[r], n.currentTarget = a.elem;
                for (i = 0; i < a.matches.length && !n.isImmediatePropagationStopped(); i++) {
                    c = a.matches[i];
                    if (y || !n.namespace && !c.namespace || n.namespace_re && n.namespace_re.test(c.namespace)) n.data = c.data, 
                    n.handleObj = c, o = ((v.event.special[c.origType] || {}).handle || c.handler).apply(a.elem, g), 
                    o !== t && (n.result = o, o === !1 && (n.preventDefault(), n.stopPropagation()));
                }
            }
            return b.postDispatch && b.postDispatch.call(this, n), n.result;
        },
        props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(e, t) {
                return e.which == null && (e.which = t.charCode != null ? t.charCode : t.keyCode), 
                e;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(e, n) {
                var r, s, o, u = n.button, a = n.fromElement;
                return e.pageX == null && n.clientX != null && (r = e.target.ownerDocument || i, 
                s = r.documentElement, o = r.body, e.pageX = n.clientX + (s && s.scrollLeft || o && o.scrollLeft || 0) - (s && s.clientLeft || o && o.clientLeft || 0), 
                e.pageY = n.clientY + (s && s.scrollTop || o && o.scrollTop || 0) - (s && s.clientTop || o && o.clientTop || 0)), 
                !e.relatedTarget && a && (e.relatedTarget = a === e.target ? n.toElement : a), !e.which && u !== t && (e.which = u & 1 ? 1 : u & 2 ? 3 : u & 4 ? 2 : 0), 
                e;
            }
        },
        fix: function(e) {
            if (e[v.expando]) return e;
            var t, n, r = e, s = v.event.fixHooks[e.type] || {}, o = s.props ? this.props.concat(s.props) : this.props;
            e = v.Event(r);
            for (t = o.length; t; ) n = o[--t], e[n] = r[n];
            return e.target || (e.target = r.srcElement || i), e.target.nodeType === 3 && (e.target = e.target.parentNode), 
            e.metaKey = !!e.metaKey, s.filter ? s.filter(e, r) : e;
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                delegateType: "focusin"
            },
            blur: {
                delegateType: "focusout"
            },
            beforeunload: {
                setup: function(e, t, n) {
                    v.isWindow(this) && (this.onbeforeunload = n);
                },
                teardown: function(e, t) {
                    this.onbeforeunload === t && (this.onbeforeunload = null);
                }
            }
        },
        simulate: function(e, t, n, r) {
            var i = v.extend(new v.Event(), n, {
                type: e,
                isSimulated: !0,
                originalEvent: {}
            });
            r ? v.event.trigger(i, null, t) : v.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault();
        }
    }, v.event.handle = v.event.dispatch, v.removeEvent = i.removeEventListener ? function(e, t, n) {
        e.removeEventListener && e.removeEventListener(t, n, !1);
    } : function(e, t, n) {
        var r = "on" + t;
        e.detachEvent && (typeof e[r] == "undefined" && (e[r] = null), e.detachEvent(r, n));
    }, v.Event = function(e, t) {
        if (!(this instanceof v.Event)) return new v.Event(e, t);
        e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || e.returnValue === !1 || e.getPreventDefault && e.getPreventDefault() ? tt : et) : this.type = e, 
        t && v.extend(this, t), this.timeStamp = e && e.timeStamp || v.now(), this[v.expando] = !0;
    }, v.Event.prototype = {
        preventDefault: function() {
            this.isDefaultPrevented = tt;
            var e = this.originalEvent;
            if (!e) return;
            e.preventDefault ? e.preventDefault() : e.returnValue = !1;
        },
        stopPropagation: function() {
            this.isPropagationStopped = tt;
            var e = this.originalEvent;
            if (!e) return;
            e.stopPropagation && e.stopPropagation(), e.cancelBubble = !0;
        },
        stopImmediatePropagation: function() {
            this.isImmediatePropagationStopped = tt, this.stopPropagation();
        },
        isDefaultPrevented: et,
        isPropagationStopped: et,
        isImmediatePropagationStopped: et
    }, v.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function(e, t) {
        v.event.special[e] = {
            delegateType: t,
            bindType: t,
            handle: function(e) {
                var n, r = this, i = e.relatedTarget, s = e.handleObj, o = s.selector;
                if (!i || i !== r && !v.contains(r, i)) e.type = s.origType, n = s.handler.apply(this, arguments), 
                e.type = t;
                return n;
            }
        };
    }), v.support.submitBubbles || (v.event.special.submit = {
        setup: function() {
            if (v.nodeName(this, "form")) return !1;
            v.event.add(this, "click._submit keypress._submit", function(e) {
                var n = e.target, r = v.nodeName(n, "input") || v.nodeName(n, "button") ? n.form : t;
                r && !v._data(r, "_submit_attached") && (v.event.add(r, "submit._submit", function(e) {
                    e._submit_bubble = !0;
                }), v._data(r, "_submit_attached", !0));
            });
        },
        postDispatch: function(e) {
            e._submit_bubble && (delete e._submit_bubble, this.parentNode && !e.isTrigger && v.event.simulate("submit", this.parentNode, e, !0));
        },
        teardown: function() {
            if (v.nodeName(this, "form")) return !1;
            v.event.remove(this, "._submit");
        }
    }), v.support.changeBubbles || (v.event.special.change = {
        setup: function() {
            if ($.test(this.nodeName)) {
                if (this.type === "checkbox" || this.type === "radio") v.event.add(this, "propertychange._change", function(e) {
                    e.originalEvent.propertyName === "checked" && (this._just_changed = !0);
                }), v.event.add(this, "click._change", function(e) {
                    this._just_changed && !e.isTrigger && (this._just_changed = !1), v.event.simulate("change", this, e, !0);
                });
                return !1;
            }
            v.event.add(this, "beforeactivate._change", function(e) {
                var t = e.target;
                $.test(t.nodeName) && !v._data(t, "_change_attached") && (v.event.add(t, "change._change", function(e) {
                    this.parentNode && !e.isSimulated && !e.isTrigger && v.event.simulate("change", this.parentNode, e, !0);
                }), v._data(t, "_change_attached", !0));
            });
        },
        handle: function(e) {
            var t = e.target;
            if (this !== t || e.isSimulated || e.isTrigger || t.type !== "radio" && t.type !== "checkbox") return e.handleObj.handler.apply(this, arguments);
        },
        teardown: function() {
            return v.event.remove(this, "._change"), !$.test(this.nodeName);
        }
    }), v.support.focusinBubbles || v.each({
        focus: "focusin",
        blur: "focusout"
    }, function(e, t) {
        var n = 0, r = function(e) {
            v.event.simulate(t, e.target, v.event.fix(e), !0);
        };
        v.event.special[t] = {
            setup: function() {
                n++ === 0 && i.addEventListener(e, r, !0);
            },
            teardown: function() {
                --n === 0 && i.removeEventListener(e, r, !0);
            }
        };
    }), v.fn.extend({
        on: function(e, n, r, i, s) {
            var o, u;
            if (typeof e == "object") {
                typeof n != "string" && (r = r || n, n = t);
                for (u in e) this.on(u, n, r, e[u], s);
                return this;
            }
            r == null && i == null ? (i = n, r = n = t) : i == null && (typeof n == "string" ? (i = r, 
            r = t) : (i = r, r = n, n = t));
            if (i === !1) i = et; else if (!i) return this;
            return s === 1 && (o = i, i = function(e) {
                return v().off(e), o.apply(this, arguments);
            }, i.guid = o.guid || (o.guid = v.guid++)), this.each(function() {
                v.event.add(this, e, i, r, n);
            });
        },
        one: function(e, t, n, r) {
            return this.on(e, t, n, r, 1);
        },
        off: function(e, n, r) {
            var i, s;
            if (e && e.preventDefault && e.handleObj) return i = e.handleObj, v(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), 
            this;
            if (typeof e == "object") {
                for (s in e) this.off(s, n, e[s]);
                return this;
            }
            if (n === !1 || typeof n == "function") r = n, n = t;
            return r === !1 && (r = et), this.each(function() {
                v.event.remove(this, e, r, n);
            });
        },
        bind: function(e, t, n) {
            return this.on(e, null, t, n);
        },
        unbind: function(e, t) {
            return this.off(e, null, t);
        },
        live: function(e, t, n) {
            return v(this.context).on(e, this.selector, t, n), this;
        },
        die: function(e, t) {
            return v(this.context).off(e, this.selector || "**", t), this;
        },
        delegate: function(e, t, n, r) {
            return this.on(t, e, n, r);
        },
        undelegate: function(e, t, n) {
            return arguments.length === 1 ? this.off(e, "**") : this.off(t, e || "**", n);
        },
        trigger: function(e, t) {
            return this.each(function() {
                v.event.trigger(e, t, this);
            });
        },
        triggerHandler: function(e, t) {
            if (this[0]) return v.event.trigger(e, t, this[0], !0);
        },
        toggle: function(e) {
            var t = arguments, n = e.guid || v.guid++, r = 0, i = function(n) {
                var i = (v._data(this, "lastToggle" + e.guid) || 0) % r;
                return v._data(this, "lastToggle" + e.guid, i + 1), n.preventDefault(), t[i].apply(this, arguments) || !1;
            };
            i.guid = n;
            while (r < t.length) t[r++].guid = n;
            return this.click(i);
        },
        hover: function(e, t) {
            return this.mouseenter(e).mouseleave(t || e);
        }
    }), v.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(e, t) {
        v.fn[t] = function(e, n) {
            return n == null && (n = e, e = null), arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t);
        }, Q.test(t) && (v.event.fixHooks[t] = v.event.keyHooks), G.test(t) && (v.event.fixHooks[t] = v.event.mouseHooks);
    }), function(e, t) {
        function nt(e, t, n, r) {
            n = n || [], t = t || g;
            var i, s, a, f, l = t.nodeType;
            if (!e || typeof e != "string") return n;
            if (l !== 1 && l !== 9) return [];
            a = o(t);
            if (!a && !r) if (i = R.exec(e)) if (f = i[1]) {
                if (l === 9) {
                    s = t.getElementById(f);
                    if (!s || !s.parentNode) return n;
                    if (s.id === f) return n.push(s), n;
                } else if (t.ownerDocument && (s = t.ownerDocument.getElementById(f)) && u(t, s) && s.id === f) return n.push(s), 
                n;
            } else {
                if (i[2]) return S.apply(n, x.call(t.getElementsByTagName(e), 0)), n;
                if ((f = i[3]) && Z && t.getElementsByClassName) return S.apply(n, x.call(t.getElementsByClassName(f), 0)), 
                n;
            }
            return vt(e.replace(j, "$1"), t, n, r, a);
        }
        function rt(e) {
            return function(t) {
                var n = t.nodeName.toLowerCase();
                return n === "input" && t.type === e;
            };
        }
        function it(e) {
            return function(t) {
                var n = t.nodeName.toLowerCase();
                return (n === "input" || n === "button") && t.type === e;
            };
        }
        function st(e) {
            return N(function(t) {
                return t = +t, N(function(n, r) {
                    var i, s = e([], n.length, t), o = s.length;
                    while (o--) n[i = s[o]] && (n[i] = !(r[i] = n[i]));
                });
            });
        }
        function ot(e, t, n) {
            if (e === t) return n;
            var r = e.nextSibling;
            while (r) {
                if (r === t) return -1;
                r = r.nextSibling;
            }
            return 1;
        }
        function ut(e, t) {
            var n, r, s, o, u, a, f, l = L[d][e + " "];
            if (l) return t ? 0 : l.slice(0);
            u = e, a = [], f = i.preFilter;
            while (u) {
                if (!n || (r = F.exec(u))) r && (u = u.slice(r[0].length) || u), a.push(s = []);
                n = !1;
                if (r = I.exec(u)) s.push(n = new m(r.shift())), u = u.slice(n.length), n.type = r[0].replace(j, " ");
                for (o in i.filter) (r = J[o].exec(u)) && (!f[o] || (r = f[o](r))) && (s.push(n = new m(r.shift())), 
                u = u.slice(n.length), n.type = o, n.matches = r);
                if (!n) break;
            }
            return t ? u.length : u ? nt.error(e) : L(e, a).slice(0);
        }
        function at(e, t, r) {
            var i = t.dir, s = r && t.dir === "parentNode", o = w++;
            return t.first ? function(t, n, r) {
                while (t = t[i]) if (s || t.nodeType === 1) return e(t, n, r);
            } : function(t, r, u) {
                if (!u) {
                    var a, f = b + " " + o + " ", l = f + n;
                    while (t = t[i]) if (s || t.nodeType === 1) {
                        if ((a = t[d]) === l) return t.sizset;
                        if (typeof a == "string" && a.indexOf(f) === 0) {
                            if (t.sizset) return t;
                        } else {
                            t[d] = l;
                            if (e(t, r, u)) return t.sizset = !0, t;
                            t.sizset = !1;
                        }
                    }
                } else while (t = t[i]) if (s || t.nodeType === 1) if (e(t, r, u)) return t;
            };
        }
        function ft(e) {
            return e.length > 1 ? function(t, n, r) {
                var i = e.length;
                while (i--) if (!e[i](t, n, r)) return !1;
                return !0;
            } : e[0];
        }
        function lt(e, t, n, r, i) {
            var s, o = [], u = 0, a = e.length, f = t != null;
            for (;u < a; u++) if (s = e[u]) if (!n || n(s, r, i)) o.push(s), f && t.push(u);
            return o;
        }
        function ct(e, t, n, r, i, s) {
            return r && !r[d] && (r = ct(r)), i && !i[d] && (i = ct(i, s)), N(function(s, o, u, a) {
                var f, l, c, h = [], p = [], d = o.length, v = s || dt(t || "*", u.nodeType ? [ u ] : u, []), m = e && (s || !t) ? lt(v, h, e, u, a) : v, g = n ? i || (s ? e : d || r) ? [] : o : m;
                n && n(m, g, u, a);
                if (r) {
                    f = lt(g, p), r(f, [], u, a), l = f.length;
                    while (l--) if (c = f[l]) g[p[l]] = !(m[p[l]] = c);
                }
                if (s) {
                    if (i || e) {
                        if (i) {
                            f = [], l = g.length;
                            while (l--) (c = g[l]) && f.push(m[l] = c);
                            i(null, g = [], f, a);
                        }
                        l = g.length;
                        while (l--) (c = g[l]) && (f = i ? T.call(s, c) : h[l]) > -1 && (s[f] = !(o[f] = c));
                    }
                } else g = lt(g === o ? g.splice(d, g.length) : g), i ? i(null, o, g, a) : S.apply(o, g);
            });
        }
        function ht(e) {
            var t, n, r, s = e.length, o = i.relative[e[0].type], u = o || i.relative[" "], a = o ? 1 : 0, f = at(function(e) {
                return e === t;
            }, u, !0), l = at(function(e) {
                return T.call(t, e) > -1;
            }, u, !0), h = [ function(e, n, r) {
                return !o && (r || n !== c) || ((t = n).nodeType ? f(e, n, r) : l(e, n, r));
            } ];
            for (;a < s; a++) if (n = i.relative[e[a].type]) h = [ at(ft(h), n) ]; else {
                n = i.filter[e[a].type].apply(null, e[a].matches);
                if (n[d]) {
                    r = ++a;
                    for (;r < s; r++) if (i.relative[e[r].type]) break;
                    return ct(a > 1 && ft(h), a > 1 && e.slice(0, a - 1).join("").replace(j, "$1"), n, a < r && ht(e.slice(a, r)), r < s && ht(e = e.slice(r)), r < s && e.join(""));
                }
                h.push(n);
            }
            return ft(h);
        }
        function pt(e, t) {
            var r = t.length > 0, s = e.length > 0, o = function(u, a, f, l, h) {
                var p, d, v, m = [], y = 0, w = "0", x = u && [], T = h != null, N = c, C = u || s && i.find.TAG("*", h && a.parentNode || a), k = b += N == null ? 1 : Math.E;
                T && (c = a !== g && a, n = o.el);
                for (;(p = C[w]) != null; w++) {
                    if (s && p) {
                        for (d = 0; v = e[d]; d++) if (v(p, a, f)) {
                            l.push(p);
                            break;
                        }
                        T && (b = k, n = ++o.el);
                    }
                    r && ((p = !v && p) && y--, u && x.push(p));
                }
                y += w;
                if (r && w !== y) {
                    for (d = 0; v = t[d]; d++) v(x, m, a, f);
                    if (u) {
                        if (y > 0) while (w--) !x[w] && !m[w] && (m[w] = E.call(l));
                        m = lt(m);
                    }
                    S.apply(l, m), T && !u && m.length > 0 && y + t.length > 1 && nt.uniqueSort(l);
                }
                return T && (b = k, c = N), x;
            };
            return o.el = 0, r ? N(o) : o;
        }
        function dt(e, t, n) {
            var r = 0, i = t.length;
            for (;r < i; r++) nt(e, t[r], n);
            return n;
        }
        function vt(e, t, n, r, s) {
            var o, u, f, l, c, h = ut(e), p = h.length;
            if (!r && h.length === 1) {
                u = h[0] = h[0].slice(0);
                if (u.length > 2 && (f = u[0]).type === "ID" && t.nodeType === 9 && !s && i.relative[u[1].type]) {
                    t = i.find.ID(f.matches[0].replace($, ""), t, s)[0];
                    if (!t) return n;
                    e = e.slice(u.shift().length);
                }
                for (o = J.POS.test(e) ? -1 : u.length - 1; o >= 0; o--) {
                    f = u[o];
                    if (i.relative[l = f.type]) break;
                    if (c = i.find[l]) if (r = c(f.matches[0].replace($, ""), z.test(u[0].type) && t.parentNode || t, s)) {
                        u.splice(o, 1), e = r.length && u.join("");
                        if (!e) return S.apply(n, x.call(r, 0)), n;
                        break;
                    }
                }
            }
            return a(e, h)(r, t, s, n, z.test(e)), n;
        }
        function mt() {}
        var n, r, i, s, o, u, a, f, l, c, h = !0, p = "undefined", d = ("sizcache" + Math.random()).replace(".", ""), m = String, g = e.document, y = g.documentElement, b = 0, w = 0, E = [].pop, S = [].push, x = [].slice, T = [].indexOf || function(e) {
            var t = 0, n = this.length;
            for (;t < n; t++) if (this[t] === e) return t;
            return -1;
        }, N = function(e, t) {
            return e[d] = t == null || t, e;
        }, C = function() {
            var e = {}, t = [];
            return N(function(n, r) {
                return t.push(n) > i.cacheLength && delete e[t.shift()], e[n + " "] = r;
            }, e);
        }, k = C(), L = C(), A = C(), O = "[\\x20\\t\\r\\n\\f]", M = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+", _ = M.replace("w", "w#"), D = "([*^$|!~]?=)", P = "\\[" + O + "*(" + M + ")" + O + "*(?:" + D + O + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + _ + ")|)|)" + O + "*\\]", H = ":(" + M + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + P + ")|[^:]|\\\\.)*|.*))\\)|)", B = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + O + "*((?:-\\d)?\\d*)" + O + "*\\)|)(?=[^-]|$)", j = new RegExp("^" + O + "+|((?:^|[^\\\\])(?:\\\\.)*)" + O + "+$", "g"), F = new RegExp("^" + O + "*," + O + "*"), I = new RegExp("^" + O + "*([\\x20\\t\\r\\n\\f>+~])" + O + "*"), q = new RegExp(H), R = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/, U = /^:not/, z = /[\x20\t\r\n\f]*[+~]/, W = /:not\($/, X = /h\d/i, V = /input|select|textarea|button/i, $ = /\\(?!\\)/g, J = {
            ID: new RegExp("^#(" + M + ")"),
            CLASS: new RegExp("^\\.(" + M + ")"),
            NAME: new RegExp("^\\[name=['\"]?(" + M + ")['\"]?\\]"),
            TAG: new RegExp("^(" + M.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + P),
            PSEUDO: new RegExp("^" + H),
            POS: new RegExp(B, "i"),
            CHILD: new RegExp("^:(only|nth|first|last)-child(?:\\(" + O + "*(even|odd|(([+-]|)(\\d*)n|)" + O + "*(?:([+-]|)" + O + "*(\\d+)|))" + O + "*\\)|)", "i"),
            needsContext: new RegExp("^" + O + "*[>+~]|" + B, "i")
        }, K = function(e) {
            var t = g.createElement("div");
            try {
                return e(t);
            } catch (n) {
                return !1;
            } finally {
                t = null;
            }
        }, Q = K(function(e) {
            return e.appendChild(g.createComment("")), !e.getElementsByTagName("*").length;
        }), G = K(function(e) {
            return e.innerHTML = "<a href='#'></a>", e.firstChild && typeof e.firstChild.getAttribute !== p && e.firstChild.getAttribute("href") === "#";
        }), Y = K(function(e) {
            e.innerHTML = "<select></select>";
            var t = typeof e.lastChild.getAttribute("multiple");
            return t !== "boolean" && t !== "string";
        }), Z = K(function(e) {
            return e.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>", !e.getElementsByClassName || !e.getElementsByClassName("e").length ? !1 : (e.lastChild.className = "e", 
            e.getElementsByClassName("e").length === 2);
        }), et = K(function(e) {
            e.id = d + 0, e.innerHTML = "<a name='" + d + "'></a><div name='" + d + "'></div>", 
            y.insertBefore(e, y.firstChild);
            var t = g.getElementsByName && g.getElementsByName(d).length === 2 + g.getElementsByName(d + 0).length;
            return r = !g.getElementById(d), y.removeChild(e), t;
        });
        try {
            x.call(y.childNodes, 0)[0].nodeType;
        } catch (tt) {
            x = function(e) {
                var t, n = [];
                for (;t = this[e]; e++) n.push(t);
                return n;
            };
        }
        nt.matches = function(e, t) {
            return nt(e, null, null, t);
        }, nt.matchesSelector = function(e, t) {
            return nt(t, null, null, [ e ]).length > 0;
        }, s = nt.getText = function(e) {
            var t, n = "", r = 0, i = e.nodeType;
            if (i) {
                if (i === 1 || i === 9 || i === 11) {
                    if (typeof e.textContent == "string") return e.textContent;
                    for (e = e.firstChild; e; e = e.nextSibling) n += s(e);
                } else if (i === 3 || i === 4) return e.nodeValue;
            } else for (;t = e[r]; r++) n += s(t);
            return n;
        }, o = nt.isXML = function(e) {
            var t = e && (e.ownerDocument || e).documentElement;
            return t ? t.nodeName !== "HTML" : !1;
        }, u = nt.contains = y.contains ? function(e, t) {
            var n = e.nodeType === 9 ? e.documentElement : e, r = t && t.parentNode;
            return e === r || !!(r && r.nodeType === 1 && n.contains && n.contains(r));
        } : y.compareDocumentPosition ? function(e, t) {
            return t && !!(e.compareDocumentPosition(t) & 16);
        } : function(e, t) {
            while (t = t.parentNode) if (t === e) return !0;
            return !1;
        }, nt.attr = function(e, t) {
            var n, r = o(e);
            return r || (t = t.toLowerCase()), (n = i.attrHandle[t]) ? n(e) : r || Y ? e.getAttribute(t) : (n = e.getAttributeNode(t), 
            n ? typeof e[t] == "boolean" ? e[t] ? t : null : n.specified ? n.value : null : null);
        }, i = nt.selectors = {
            cacheLength: 50,
            createPseudo: N,
            match: J,
            attrHandle: G ? {} : {
                href: function(e) {
                    return e.getAttribute("href", 2);
                },
                type: function(e) {
                    return e.getAttribute("type");
                }
            },
            find: {
                ID: r ? function(e, t, n) {
                    if (typeof t.getElementById !== p && !n) {
                        var r = t.getElementById(e);
                        return r && r.parentNode ? [ r ] : [];
                    }
                } : function(e, n, r) {
                    if (typeof n.getElementById !== p && !r) {
                        var i = n.getElementById(e);
                        return i ? i.id === e || typeof i.getAttributeNode !== p && i.getAttributeNode("id").value === e ? [ i ] : t : [];
                    }
                },
                TAG: Q ? function(e, t) {
                    if (typeof t.getElementsByTagName !== p) return t.getElementsByTagName(e);
                } : function(e, t) {
                    var n = t.getElementsByTagName(e);
                    if (e === "*") {
                        var r, i = [], s = 0;
                        for (;r = n[s]; s++) r.nodeType === 1 && i.push(r);
                        return i;
                    }
                    return n;
                },
                NAME: et && function(e, t) {
                    if (typeof t.getElementsByName !== p) return t.getElementsByName(name);
                },
                CLASS: Z && function(e, t, n) {
                    if (typeof t.getElementsByClassName !== p && !n) return t.getElementsByClassName(e);
                }
            },
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(e) {
                    return e[1] = e[1].replace($, ""), e[3] = (e[4] || e[5] || "").replace($, ""), e[2] === "~=" && (e[3] = " " + e[3] + " "), 
                    e.slice(0, 4);
                },
                CHILD: function(e) {
                    return e[1] = e[1].toLowerCase(), e[1] === "nth" ? (e[2] || nt.error(e[0]), e[3] = +(e[3] ? e[4] + (e[5] || 1) : 2 * (e[2] === "even" || e[2] === "odd")), 
                    e[4] = +(e[6] + e[7] || e[2] === "odd")) : e[2] && nt.error(e[0]), e;
                },
                PSEUDO: function(e) {
                    var t, n;
                    if (J.CHILD.test(e[0])) return null;
                    if (e[3]) e[2] = e[3]; else if (t = e[4]) q.test(t) && (n = ut(t, !0)) && (n = t.indexOf(")", t.length - n) - t.length) && (t = t.slice(0, n), 
                    e[0] = e[0].slice(0, n)), e[2] = t;
                    return e.slice(0, 3);
                }
            },
            filter: {
                ID: r ? function(e) {
                    return e = e.replace($, ""), function(t) {
                        return t.getAttribute("id") === e;
                    };
                } : function(e) {
                    return e = e.replace($, ""), function(t) {
                        var n = typeof t.getAttributeNode !== p && t.getAttributeNode("id");
                        return n && n.value === e;
                    };
                },
                TAG: function(e) {
                    return e === "*" ? function() {
                        return !0;
                    } : (e = e.replace($, "").toLowerCase(), function(t) {
                        return t.nodeName && t.nodeName.toLowerCase() === e;
                    });
                },
                CLASS: function(e) {
                    var t = k[d][e + " "];
                    return t || (t = new RegExp("(^|" + O + ")" + e + "(" + O + "|$)")) && k(e, function(e) {
                        return t.test(e.className || typeof e.getAttribute !== p && e.getAttribute("class") || "");
                    });
                },
                ATTR: function(e, t, n) {
                    return function(r, i) {
                        var s = nt.attr(r, e);
                        return s == null ? t === "!=" : t ? (s += "", t === "=" ? s === n : t === "!=" ? s !== n : t === "^=" ? n && s.indexOf(n) === 0 : t === "*=" ? n && s.indexOf(n) > -1 : t === "$=" ? n && s.substr(s.length - n.length) === n : t === "~=" ? (" " + s + " ").indexOf(n) > -1 : t === "|=" ? s === n || s.substr(0, n.length + 1) === n + "-" : !1) : !0;
                    };
                },
                CHILD: function(e, t, n, r) {
                    return e === "nth" ? function(e) {
                        var t, i, s = e.parentNode;
                        if (n === 1 && r === 0) return !0;
                        if (s) {
                            i = 0;
                            for (t = s.firstChild; t; t = t.nextSibling) if (t.nodeType === 1) {
                                i++;
                                if (e === t) break;
                            }
                        }
                        return i -= r, i === n || i % n === 0 && i / n >= 0;
                    } : function(t) {
                        var n = t;
                        switch (e) {
                          case "only":
                          case "first":
                            while (n = n.previousSibling) if (n.nodeType === 1) return !1;
                            if (e === "first") return !0;
                            n = t;

                          case "last":
                            while (n = n.nextSibling) if (n.nodeType === 1) return !1;
                            return !0;
                        }
                    };
                },
                PSEUDO: function(e, t) {
                    var n, r = i.pseudos[e] || i.setFilters[e.toLowerCase()] || nt.error("unsupported pseudo: " + e);
                    return r[d] ? r(t) : r.length > 1 ? (n = [ e, e, "", t ], i.setFilters.hasOwnProperty(e.toLowerCase()) ? N(function(e, n) {
                        var i, s = r(e, t), o = s.length;
                        while (o--) i = T.call(e, s[o]), e[i] = !(n[i] = s[o]);
                    }) : function(e) {
                        return r(e, 0, n);
                    }) : r;
                }
            },
            pseudos: {
                not: N(function(e) {
                    var t = [], n = [], r = a(e.replace(j, "$1"));
                    return r[d] ? N(function(e, t, n, i) {
                        var s, o = r(e, null, i, []), u = e.length;
                        while (u--) if (s = o[u]) e[u] = !(t[u] = s);
                    }) : function(e, i, s) {
                        return t[0] = e, r(t, null, s, n), !n.pop();
                    };
                }),
                has: N(function(e) {
                    return function(t) {
                        return nt(e, t).length > 0;
                    };
                }),
                contains: N(function(e) {
                    return function(t) {
                        return (t.textContent || t.innerText || s(t)).indexOf(e) > -1;
                    };
                }),
                enabled: function(e) {
                    return e.disabled === !1;
                },
                disabled: function(e) {
                    return e.disabled === !0;
                },
                checked: function(e) {
                    var t = e.nodeName.toLowerCase();
                    return t === "input" && !!e.checked || t === "option" && !!e.selected;
                },
                selected: function(e) {
                    return e.parentNode && e.parentNode.selectedIndex, e.selected === !0;
                },
                parent: function(e) {
                    return !i.pseudos.empty(e);
                },
                empty: function(e) {
                    var t;
                    e = e.firstChild;
                    while (e) {
                        if (e.nodeName > "@" || (t = e.nodeType) === 3 || t === 4) return !1;
                        e = e.nextSibling;
                    }
                    return !0;
                },
                header: function(e) {
                    return X.test(e.nodeName);
                },
                text: function(e) {
                    var t, n;
                    return e.nodeName.toLowerCase() === "input" && (t = e.type) === "text" && ((n = e.getAttribute("type")) == null || n.toLowerCase() === t);
                },
                radio: rt("radio"),
                checkbox: rt("checkbox"),
                file: rt("file"),
                password: rt("password"),
                image: rt("image"),
                submit: it("submit"),
                reset: it("reset"),
                button: function(e) {
                    var t = e.nodeName.toLowerCase();
                    return t === "input" && e.type === "button" || t === "button";
                },
                input: function(e) {
                    return V.test(e.nodeName);
                },
                focus: function(e) {
                    var t = e.ownerDocument;
                    return e === t.activeElement && (!t.hasFocus || t.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
                },
                active: function(e) {
                    return e === e.ownerDocument.activeElement;
                },
                first: st(function() {
                    return [ 0 ];
                }),
                last: st(function(e, t) {
                    return [ t - 1 ];
                }),
                eq: st(function(e, t, n) {
                    return [ n < 0 ? n + t : n ];
                }),
                even: st(function(e, t) {
                    for (var n = 0; n < t; n += 2) e.push(n);
                    return e;
                }),
                odd: st(function(e, t) {
                    for (var n = 1; n < t; n += 2) e.push(n);
                    return e;
                }),
                lt: st(function(e, t, n) {
                    for (var r = n < 0 ? n + t : n; --r >= 0; ) e.push(r);
                    return e;
                }),
                gt: st(function(e, t, n) {
                    for (var r = n < 0 ? n + t : n; ++r < t; ) e.push(r);
                    return e;
                })
            }
        }, f = y.compareDocumentPosition ? function(e, t) {
            return e === t ? (l = !0, 0) : (!e.compareDocumentPosition || !t.compareDocumentPosition ? e.compareDocumentPosition : e.compareDocumentPosition(t) & 4) ? -1 : 1;
        } : function(e, t) {
            if (e === t) return l = !0, 0;
            if (e.sourceIndex && t.sourceIndex) return e.sourceIndex - t.sourceIndex;
            var n, r, i = [], s = [], o = e.parentNode, u = t.parentNode, a = o;
            if (o === u) return ot(e, t);
            if (!o) return -1;
            if (!u) return 1;
            while (a) i.unshift(a), a = a.parentNode;
            a = u;
            while (a) s.unshift(a), a = a.parentNode;
            n = i.length, r = s.length;
            for (var f = 0; f < n && f < r; f++) if (i[f] !== s[f]) return ot(i[f], s[f]);
            return f === n ? ot(e, s[f], -1) : ot(i[f], t, 1);
        }, [ 0, 0 ].sort(f), h = !l, nt.uniqueSort = function(e) {
            var t, n = [], r = 1, i = 0;
            l = h, e.sort(f);
            if (l) {
                for (;t = e[r]; r++) t === e[r - 1] && (i = n.push(r));
                while (i--) e.splice(n[i], 1);
            }
            return e;
        }, nt.error = function(e) {
            throw new Error("Syntax error, unrecognized expression: " + e);
        }, a = nt.compile = function(e, t) {
            var n, r = [], i = [], s = A[d][e + " "];
            if (!s) {
                t || (t = ut(e)), n = t.length;
                while (n--) s = ht(t[n]), s[d] ? r.push(s) : i.push(s);
                s = A(e, pt(i, r));
            }
            return s;
        }, g.querySelectorAll && function() {
            var e, t = vt, n = /'|\\/g, r = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g, i = [ ":focus" ], s = [ ":active" ], u = y.matchesSelector || y.mozMatchesSelector || y.webkitMatchesSelector || y.oMatchesSelector || y.msMatchesSelector;
            K(function(e) {
                e.innerHTML = "<select><option selected=''></option></select>", e.querySelectorAll("[selected]").length || i.push("\\[" + O + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)"), 
                e.querySelectorAll(":checked").length || i.push(":checked");
            }), K(function(e) {
                e.innerHTML = "<p test=''></p>", e.querySelectorAll("[test^='']").length && i.push("[*^$]=" + O + "*(?:\"\"|'')"), 
                e.innerHTML = "<input type='hidden'/>", e.querySelectorAll(":enabled").length || i.push(":enabled", ":disabled");
            }), i = new RegExp(i.join("|")), vt = function(e, r, s, o, u) {
                if (!o && !u && !i.test(e)) {
                    var a, f, l = !0, c = d, h = r, p = r.nodeType === 9 && e;
                    if (r.nodeType === 1 && r.nodeName.toLowerCase() !== "object") {
                        a = ut(e), (l = r.getAttribute("id")) ? c = l.replace(n, "\\$&") : r.setAttribute("id", c), 
                        c = "[id='" + c + "'] ", f = a.length;
                        while (f--) a[f] = c + a[f].join("");
                        h = z.test(e) && r.parentNode || r, p = a.join(",");
                    }
                    if (p) try {
                        return S.apply(s, x.call(h.querySelectorAll(p), 0)), s;
                    } catch (v) {} finally {
                        l || r.removeAttribute("id");
                    }
                }
                return t(e, r, s, o, u);
            }, u && (K(function(t) {
                e = u.call(t, "div");
                try {
                    u.call(t, "[test!='']:sizzle"), s.push("!=", H);
                } catch (n) {}
            }), s = new RegExp(s.join("|")), nt.matchesSelector = function(t, n) {
                n = n.replace(r, "='$1']");
                if (!o(t) && !s.test(n) && !i.test(n)) try {
                    var a = u.call(t, n);
                    if (a || e || t.document && t.document.nodeType !== 11) return a;
                } catch (f) {}
                return nt(n, null, null, [ t ]).length > 0;
            });
        }(), i.pseudos.nth = i.pseudos.eq, i.filters = mt.prototype = i.pseudos, i.setFilters = new mt(), 
        nt.attr = v.attr, v.find = nt, v.expr = nt.selectors, v.expr[":"] = v.expr.pseudos, 
        v.unique = nt.uniqueSort, v.text = nt.getText, v.isXMLDoc = nt.isXML, v.contains = nt.contains;
    }(e);
    var nt = /Until$/, rt = /^(?:parents|prev(?:Until|All))/, it = /^.[^:#\[\.,]*$/, st = v.expr.match.needsContext, ot = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    v.fn.extend({
        find: function(e) {
            var t, n, r, i, s, o, u = this;
            if (typeof e != "string") return v(e).filter(function() {
                for (t = 0, n = u.length; t < n; t++) if (v.contains(u[t], this)) return !0;
            });
            o = this.pushStack("", "find", e);
            for (t = 0, n = this.length; t < n; t++) {
                r = o.length, v.find(e, this[t], o);
                if (t > 0) for (i = r; i < o.length; i++) for (s = 0; s < r; s++) if (o[s] === o[i]) {
                    o.splice(i--, 1);
                    break;
                }
            }
            return o;
        },
        has: function(e) {
            var t, n = v(e, this), r = n.length;
            return this.filter(function() {
                for (t = 0; t < r; t++) if (v.contains(this, n[t])) return !0;
            });
        },
        not: function(e) {
            return this.pushStack(ft(this, e, !1), "not", e);
        },
        filter: function(e) {
            return this.pushStack(ft(this, e, !0), "filter", e);
        },
        is: function(e) {
            return !!e && (typeof e == "string" ? st.test(e) ? v(e, this.context).index(this[0]) >= 0 : v.filter(e, this).length > 0 : this.filter(e).length > 0);
        },
        closest: function(e, t) {
            var n, r = 0, i = this.length, s = [], o = st.test(e) || typeof e != "string" ? v(e, t || this.context) : 0;
            for (;r < i; r++) {
                n = this[r];
                while (n && n.ownerDocument && n !== t && n.nodeType !== 11) {
                    if (o ? o.index(n) > -1 : v.find.matchesSelector(n, e)) {
                        s.push(n);
                        break;
                    }
                    n = n.parentNode;
                }
            }
            return s = s.length > 1 ? v.unique(s) : s, this.pushStack(s, "closest", e);
        },
        index: function(e) {
            return e ? typeof e == "string" ? v.inArray(this[0], v(e)) : v.inArray(e.jquery ? e[0] : e, this) : this[0] && this[0].parentNode ? this.prevAll().length : -1;
        },
        add: function(e, t) {
            var n = typeof e == "string" ? v(e, t) : v.makeArray(e && e.nodeType ? [ e ] : e), r = v.merge(this.get(), n);
            return this.pushStack(ut(n[0]) || ut(r[0]) ? r : v.unique(r));
        },
        addBack: function(e) {
            return this.add(e == null ? this.prevObject : this.prevObject.filter(e));
        }
    }), v.fn.andSelf = v.fn.addBack, v.each({
        parent: function(e) {
            var t = e.parentNode;
            return t && t.nodeType !== 11 ? t : null;
        },
        parents: function(e) {
            return v.dir(e, "parentNode");
        },
        parentsUntil: function(e, t, n) {
            return v.dir(e, "parentNode", n);
        },
        next: function(e) {
            return at(e, "nextSibling");
        },
        prev: function(e) {
            return at(e, "previousSibling");
        },
        nextAll: function(e) {
            return v.dir(e, "nextSibling");
        },
        prevAll: function(e) {
            return v.dir(e, "previousSibling");
        },
        nextUntil: function(e, t, n) {
            return v.dir(e, "nextSibling", n);
        },
        prevUntil: function(e, t, n) {
            return v.dir(e, "previousSibling", n);
        },
        siblings: function(e) {
            return v.sibling((e.parentNode || {}).firstChild, e);
        },
        children: function(e) {
            return v.sibling(e.firstChild);
        },
        contents: function(e) {
            return v.nodeName(e, "iframe") ? e.contentDocument || e.contentWindow.document : v.merge([], e.childNodes);
        }
    }, function(e, t) {
        v.fn[e] = function(n, r) {
            var i = v.map(this, t, n);
            return nt.test(e) || (r = n), r && typeof r == "string" && (i = v.filter(r, i)), 
            i = this.length > 1 && !ot[e] ? v.unique(i) : i, this.length > 1 && rt.test(e) && (i = i.reverse()), 
            this.pushStack(i, e, l.call(arguments).join(","));
        };
    }), v.extend({
        filter: function(e, t, n) {
            return n && (e = ":not(" + e + ")"), t.length === 1 ? v.find.matchesSelector(t[0], e) ? [ t[0] ] : [] : v.find.matches(e, t);
        },
        dir: function(e, n, r) {
            var i = [], s = e[n];
            while (s && s.nodeType !== 9 && (r === t || s.nodeType !== 1 || !v(s).is(r))) s.nodeType === 1 && i.push(s), 
            s = s[n];
            return i;
        },
        sibling: function(e, t) {
            var n = [];
            for (;e; e = e.nextSibling) e.nodeType === 1 && e !== t && n.push(e);
            return n;
        }
    });
    var ct = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", ht = / jQuery\d+="(?:null|\d+)"/g, pt = /^\s+/, dt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, vt = /<([\w:]+)/, mt = /<tbody/i, gt = /<|&#?\w+;/, yt = /<(?:script|style|link)/i, bt = /<(?:script|object|embed|option|style)/i, wt = new RegExp("<(?:" + ct + ")[\\s/>]", "i"), Et = /^(?:checkbox|radio)$/, St = /checked\s*(?:[^=]|=\s*.checked.)/i, xt = /\/(java|ecma)script/i, Tt = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g, Nt = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        area: [ 1, "<map>", "</map>" ],
        _default: [ 0, "", "" ]
    }, Ct = lt(i), kt = Ct.appendChild(i.createElement("div"));
    Nt.optgroup = Nt.option, Nt.tbody = Nt.tfoot = Nt.colgroup = Nt.caption = Nt.thead, 
    Nt.th = Nt.td, v.support.htmlSerialize || (Nt._default = [ 1, "X<div>", "</div>" ]), 
    v.fn.extend({
        text: function(e) {
            return v.access(this, function(e) {
                return e === t ? v.text(this) : this.empty().append((this[0] && this[0].ownerDocument || i).createTextNode(e));
            }, null, e, arguments.length);
        },
        wrapAll: function(e) {
            if (v.isFunction(e)) return this.each(function(t) {
                v(this).wrapAll(e.call(this, t));
            });
            if (this[0]) {
                var t = v(e, this[0].ownerDocument).eq(0).clone(!0);
                this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
                    var e = this;
                    while (e.firstChild && e.firstChild.nodeType === 1) e = e.firstChild;
                    return e;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(e) {
            return v.isFunction(e) ? this.each(function(t) {
                v(this).wrapInner(e.call(this, t));
            }) : this.each(function() {
                var t = v(this), n = t.contents();
                n.length ? n.wrapAll(e) : t.append(e);
            });
        },
        wrap: function(e) {
            var t = v.isFunction(e);
            return this.each(function(n) {
                v(this).wrapAll(t ? e.call(this, n) : e);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                v.nodeName(this, "body") || v(this).replaceWith(this.childNodes);
            }).end();
        },
        append: function() {
            return this.domManip(arguments, !0, function(e) {
                (this.nodeType === 1 || this.nodeType === 11) && this.appendChild(e);
            });
        },
        prepend: function() {
            return this.domManip(arguments, !0, function(e) {
                (this.nodeType === 1 || this.nodeType === 11) && this.insertBefore(e, this.firstChild);
            });
        },
        before: function() {
            if (!ut(this[0])) return this.domManip(arguments, !1, function(e) {
                this.parentNode.insertBefore(e, this);
            });
            if (arguments.length) {
                var e = v.clean(arguments);
                return this.pushStack(v.merge(e, this), "before", this.selector);
            }
        },
        after: function() {
            if (!ut(this[0])) return this.domManip(arguments, !1, function(e) {
                this.parentNode.insertBefore(e, this.nextSibling);
            });
            if (arguments.length) {
                var e = v.clean(arguments);
                return this.pushStack(v.merge(this, e), "after", this.selector);
            }
        },
        remove: function(e, t) {
            var n, r = 0;
            for (;(n = this[r]) != null; r++) if (!e || v.filter(e, [ n ]).length) !t && n.nodeType === 1 && (v.cleanData(n.getElementsByTagName("*")), 
            v.cleanData([ n ])), n.parentNode && n.parentNode.removeChild(n);
            return this;
        },
        empty: function() {
            var e, t = 0;
            for (;(e = this[t]) != null; t++) {
                e.nodeType === 1 && v.cleanData(e.getElementsByTagName("*"));
                while (e.firstChild) e.removeChild(e.firstChild);
            }
            return this;
        },
        clone: function(e, t) {
            return e = e == null ? !1 : e, t = t == null ? e : t, this.map(function() {
                return v.clone(this, e, t);
            });
        },
        html: function(e) {
            return v.access(this, function(e) {
                var n = this[0] || {}, r = 0, i = this.length;
                if (e === t) return n.nodeType === 1 ? n.innerHTML.replace(ht, "") : t;
                if (typeof e == "string" && !yt.test(e) && (v.support.htmlSerialize || !wt.test(e)) && (v.support.leadingWhitespace || !pt.test(e)) && !Nt[(vt.exec(e) || [ "", "" ])[1].toLowerCase()]) {
                    e = e.replace(dt, "<$1></$2>");
                    try {
                        for (;r < i; r++) n = this[r] || {}, n.nodeType === 1 && (v.cleanData(n.getElementsByTagName("*")), 
                        n.innerHTML = e);
                        n = 0;
                    } catch (s) {}
                }
                n && this.empty().append(e);
            }, null, e, arguments.length);
        },
        replaceWith: function(e) {
            return ut(this[0]) ? this.length ? this.pushStack(v(v.isFunction(e) ? e() : e), "replaceWith", e) : this : v.isFunction(e) ? this.each(function(t) {
                var n = v(this), r = n.html();
                n.replaceWith(e.call(this, t, r));
            }) : (typeof e != "string" && (e = v(e).detach()), this.each(function() {
                var t = this.nextSibling, n = this.parentNode;
                v(this).remove(), t ? v(t).before(e) : v(n).append(e);
            }));
        },
        detach: function(e) {
            return this.remove(e, !0);
        },
        domManip: function(e, n, r) {
            e = [].concat.apply([], e);
            var i, s, o, u, a = 0, f = e[0], l = [], c = this.length;
            if (!v.support.checkClone && c > 1 && typeof f == "string" && St.test(f)) return this.each(function() {
                v(this).domManip(e, n, r);
            });
            if (v.isFunction(f)) return this.each(function(i) {
                var s = v(this);
                e[0] = f.call(this, i, n ? s.html() : t), s.domManip(e, n, r);
            });
            if (this[0]) {
                i = v.buildFragment(e, this, l), o = i.fragment, s = o.firstChild, o.childNodes.length === 1 && (o = s);
                if (s) {
                    n = n && v.nodeName(s, "tr");
                    for (u = i.cacheable || c - 1; a < c; a++) r.call(n && v.nodeName(this[a], "table") ? Lt(this[a], "tbody") : this[a], a === u ? o : v.clone(o, !0, !0));
                }
                o = s = null, l.length && v.each(l, function(e, t) {
                    t.src ? v.ajax ? v.ajax({
                        url: t.src,
                        type: "GET",
                        dataType: "script",
                        async: !1,
                        global: !1,
                        throws: !0
                    }) : v.error("no ajax") : v.globalEval((t.text || t.textContent || t.innerHTML || "").replace(Tt, "")), 
                    t.parentNode && t.parentNode.removeChild(t);
                });
            }
            return this;
        }
    }), v.buildFragment = function(e, n, r) {
        var s, o, u, a = e[0];
        return n = n || i, n = !n.nodeType && n[0] || n, n = n.ownerDocument || n, e.length === 1 && typeof a == "string" && a.length < 512 && n === i && a.charAt(0) === "<" && !bt.test(a) && (v.support.checkClone || !St.test(a)) && (v.support.html5Clone || !wt.test(a)) && (o = !0, 
        s = v.fragments[a], u = s !== t), s || (s = n.createDocumentFragment(), v.clean(e, n, s, r), 
        o && (v.fragments[a] = u && s)), {
            fragment: s,
            cacheable: o
        };
    }, v.fragments = {}, v.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(e, t) {
        v.fn[e] = function(n) {
            var r, i = 0, s = [], o = v(n), u = o.length, a = this.length === 1 && this[0].parentNode;
            if ((a == null || a && a.nodeType === 11 && a.childNodes.length === 1) && u === 1) return o[t](this[0]), 
            this;
            for (;i < u; i++) r = (i > 0 ? this.clone(!0) : this).get(), v(o[i])[t](r), s = s.concat(r);
            return this.pushStack(s, e, o.selector);
        };
    }), v.extend({
        clone: function(e, t, n) {
            var r, i, s, o;
            v.support.html5Clone || v.isXMLDoc(e) || !wt.test("<" + e.nodeName + ">") ? o = e.cloneNode(!0) : (kt.innerHTML = e.outerHTML, 
            kt.removeChild(o = kt.firstChild));
            if ((!v.support.noCloneEvent || !v.support.noCloneChecked) && (e.nodeType === 1 || e.nodeType === 11) && !v.isXMLDoc(e)) {
                Ot(e, o), r = Mt(e), i = Mt(o);
                for (s = 0; r[s]; ++s) i[s] && Ot(r[s], i[s]);
            }
            if (t) {
                At(e, o);
                if (n) {
                    r = Mt(e), i = Mt(o);
                    for (s = 0; r[s]; ++s) At(r[s], i[s]);
                }
            }
            return r = i = null, o;
        },
        clean: function(e, t, n, r) {
            var s, o, u, a, f, l, c, h, p, d, m, g, y = t === i && Ct, b = [];
            if (!t || typeof t.createDocumentFragment == "undefined") t = i;
            for (s = 0; (u = e[s]) != null; s++) {
                typeof u == "number" && (u += "");
                if (!u) continue;
                if (typeof u == "string") if (!gt.test(u)) u = t.createTextNode(u); else {
                    y = y || lt(t), c = t.createElement("div"), y.appendChild(c), u = u.replace(dt, "<$1></$2>"), 
                    a = (vt.exec(u) || [ "", "" ])[1].toLowerCase(), f = Nt[a] || Nt._default, l = f[0], 
                    c.innerHTML = f[1] + u + f[2];
                    while (l--) c = c.lastChild;
                    if (!v.support.tbody) {
                        h = mt.test(u), p = a === "table" && !h ? c.firstChild && c.firstChild.childNodes : f[1] === "<table>" && !h ? c.childNodes : [];
                        for (o = p.length - 1; o >= 0; --o) v.nodeName(p[o], "tbody") && !p[o].childNodes.length && p[o].parentNode.removeChild(p[o]);
                    }
                    !v.support.leadingWhitespace && pt.test(u) && c.insertBefore(t.createTextNode(pt.exec(u)[0]), c.firstChild), 
                    u = c.childNodes, c.parentNode.removeChild(c);
                }
                u.nodeType ? b.push(u) : v.merge(b, u);
            }
            c && (u = c = y = null);
            if (!v.support.appendChecked) for (s = 0; (u = b[s]) != null; s++) v.nodeName(u, "input") ? _t(u) : typeof u.getElementsByTagName != "undefined" && v.grep(u.getElementsByTagName("input"), _t);
            if (n) {
                m = function(e) {
                    if (!e.type || xt.test(e.type)) return r ? r.push(e.parentNode ? e.parentNode.removeChild(e) : e) : n.appendChild(e);
                };
                for (s = 0; (u = b[s]) != null; s++) if (!v.nodeName(u, "script") || !m(u)) n.appendChild(u), 
                typeof u.getElementsByTagName != "undefined" && (g = v.grep(v.merge([], u.getElementsByTagName("script")), m), 
                b.splice.apply(b, [ s + 1, 0 ].concat(g)), s += g.length);
            }
            return b;
        },
        cleanData: function(e, t) {
            var n, r, i, s, o = 0, u = v.expando, a = v.cache, f = v.support.deleteExpando, l = v.event.special;
            for (;(i = e[o]) != null; o++) if (t || v.acceptData(i)) {
                r = i[u], n = r && a[r];
                if (n) {
                    if (n.events) for (s in n.events) l[s] ? v.event.remove(i, s) : v.removeEvent(i, s, n.handle);
                    a[r] && (delete a[r], f ? delete i[u] : i.removeAttribute ? i.removeAttribute(u) : i[u] = null, 
                    v.deletedIds.push(r));
                }
            }
        }
    }), function() {
        var e, t;
        v.uaMatch = function(e) {
            e = e.toLowerCase();
            var t = /(chrome)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || e.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e) || [];
            return {
                browser: t[1] || "",
                version: t[2] || "0"
            };
        }, e = v.uaMatch(o.userAgent), t = {}, e.browser && (t[e.browser] = !0, t.version = e.version), 
        t.chrome ? t.webkit = !0 : t.webkit && (t.safari = !0), v.browser = t, v.sub = function() {
            function e(t, n) {
                return new e.fn.init(t, n);
            }
            v.extend(!0, e, this), e.superclass = this, e.fn = e.prototype = this(), e.fn.constructor = e, 
            e.sub = this.sub, e.fn.init = function(r, i) {
                return i && i instanceof v && !(i instanceof e) && (i = e(i)), v.fn.init.call(this, r, i, t);
            }, e.fn.init.prototype = e.fn;
            var t = e(i);
            return e;
        };
    }();
    var Dt, Pt, Ht, Bt = /alpha\([^)]*\)/i, jt = /opacity=([^)]*)/, Ft = /^(top|right|bottom|left)$/, It = /^(none|table(?!-c[ea]).+)/, qt = /^margin/, Rt = new RegExp("^(" + m + ")(.*)$", "i"), Ut = new RegExp("^(" + m + ")(?!px)[a-z%]+$", "i"), zt = new RegExp("^([-+])=(" + m + ")", "i"), Wt = {
        BODY: "block"
    }, Xt = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, Vt = {
        letterSpacing: 0,
        fontWeight: 400
    }, $t = [ "Top", "Right", "Bottom", "Left" ], Jt = [ "Webkit", "O", "Moz", "ms" ], Kt = v.fn.toggle;
    v.fn.extend({
        css: function(e, n) {
            return v.access(this, function(e, n, r) {
                return r !== t ? v.style(e, n, r) : v.css(e, n);
            }, e, n, arguments.length > 1);
        },
        show: function() {
            return Yt(this, !0);
        },
        hide: function() {
            return Yt(this);
        },
        toggle: function(e, t) {
            var n = typeof e == "boolean";
            return v.isFunction(e) && v.isFunction(t) ? Kt.apply(this, arguments) : this.each(function() {
                (n ? e : Gt(this)) ? v(this).show() : v(this).hide();
            });
        }
    }), v.extend({
        cssHooks: {
            opacity: {
                get: function(e, t) {
                    if (t) {
                        var n = Dt(e, "opacity");
                        return n === "" ? "1" : n;
                    }
                }
            }
        },
        cssNumber: {
            fillOpacity: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            float: v.support.cssFloat ? "cssFloat" : "styleFloat"
        },
        style: function(e, n, r, i) {
            if (!e || e.nodeType === 3 || e.nodeType === 8 || !e.style) return;
            var s, o, u, a = v.camelCase(n), f = e.style;
            n = v.cssProps[a] || (v.cssProps[a] = Qt(f, a)), u = v.cssHooks[n] || v.cssHooks[a];
            if (r === t) return u && "get" in u && (s = u.get(e, !1, i)) !== t ? s : f[n];
            o = typeof r, o === "string" && (s = zt.exec(r)) && (r = (s[1] + 1) * s[2] + parseFloat(v.css(e, n)), 
            o = "number");
            if (r == null || o === "number" && isNaN(r)) return;
            o === "number" && !v.cssNumber[a] && (r += "px");
            if (!u || !("set" in u) || (r = u.set(e, r, i)) !== t) try {
                f[n] = r;
            } catch (l) {}
        },
        css: function(e, n, r, i) {
            var s, o, u, a = v.camelCase(n);
            return n = v.cssProps[a] || (v.cssProps[a] = Qt(e.style, a)), u = v.cssHooks[n] || v.cssHooks[a], 
            u && "get" in u && (s = u.get(e, !0, i)), s === t && (s = Dt(e, n)), s === "normal" && n in Vt && (s = Vt[n]), 
            r || i !== t ? (o = parseFloat(s), r || v.isNumeric(o) ? o || 0 : s) : s;
        },
        swap: function(e, t, n) {
            var r, i, s = {};
            for (i in t) s[i] = e.style[i], e.style[i] = t[i];
            r = n.call(e);
            for (i in t) e.style[i] = s[i];
            return r;
        }
    }), e.getComputedStyle ? Dt = function(t, n) {
        var r, i, s, o, u = e.getComputedStyle(t, null), a = t.style;
        return u && (r = u.getPropertyValue(n) || u[n], r === "" && !v.contains(t.ownerDocument, t) && (r = v.style(t, n)), 
        Ut.test(r) && qt.test(n) && (i = a.width, s = a.minWidth, o = a.maxWidth, a.minWidth = a.maxWidth = a.width = r, 
        r = u.width, a.width = i, a.minWidth = s, a.maxWidth = o)), r;
    } : i.documentElement.currentStyle && (Dt = function(e, t) {
        var n, r, i = e.currentStyle && e.currentStyle[t], s = e.style;
        return i == null && s && s[t] && (i = s[t]), Ut.test(i) && !Ft.test(t) && (n = s.left, 
        r = e.runtimeStyle && e.runtimeStyle.left, r && (e.runtimeStyle.left = e.currentStyle.left), 
        s.left = t === "fontSize" ? "1em" : i, i = s.pixelLeft + "px", s.left = n, r && (e.runtimeStyle.left = r)), 
        i === "" ? "auto" : i;
    }), v.each([ "height", "width" ], function(e, t) {
        v.cssHooks[t] = {
            get: function(e, n, r) {
                if (n) return e.offsetWidth === 0 && It.test(Dt(e, "display")) ? v.swap(e, Xt, function() {
                    return tn(e, t, r);
                }) : tn(e, t, r);
            },
            set: function(e, n, r) {
                return Zt(e, n, r ? en(e, t, r, v.support.boxSizing && v.css(e, "boxSizing") === "border-box") : 0);
            }
        };
    }), v.support.opacity || (v.cssHooks.opacity = {
        get: function(e, t) {
            return jt.test((t && e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : t ? "1" : "";
        },
        set: function(e, t) {
            var n = e.style, r = e.currentStyle, i = v.isNumeric(t) ? "alpha(opacity=" + t * 100 + ")" : "", s = r && r.filter || n.filter || "";
            n.zoom = 1;
            if (t >= 1 && v.trim(s.replace(Bt, "")) === "" && n.removeAttribute) {
                n.removeAttribute("filter");
                if (r && !r.filter) return;
            }
            n.filter = Bt.test(s) ? s.replace(Bt, i) : s + " " + i;
        }
    }), v(function() {
        v.support.reliableMarginRight || (v.cssHooks.marginRight = {
            get: function(e, t) {
                return v.swap(e, {
                    display: "inline-block"
                }, function() {
                    if (t) return Dt(e, "marginRight");
                });
            }
        }), !v.support.pixelPosition && v.fn.position && v.each([ "top", "left" ], function(e, t) {
            v.cssHooks[t] = {
                get: function(e, n) {
                    if (n) {
                        var r = Dt(e, t);
                        return Ut.test(r) ? v(e).position()[t] + "px" : r;
                    }
                }
            };
        });
    }), v.expr && v.expr.filters && (v.expr.filters.hidden = function(e) {
        return e.offsetWidth === 0 && e.offsetHeight === 0 || !v.support.reliableHiddenOffsets && (e.style && e.style.display || Dt(e, "display")) === "none";
    }, v.expr.filters.visible = function(e) {
        return !v.expr.filters.hidden(e);
    }), v.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(e, t) {
        v.cssHooks[e + t] = {
            expand: function(n) {
                var r, i = typeof n == "string" ? n.split(" ") : [ n ], s = {};
                for (r = 0; r < 4; r++) s[e + $t[r] + t] = i[r] || i[r - 2] || i[0];
                return s;
            }
        }, qt.test(e) || (v.cssHooks[e + t].set = Zt);
    });
    var rn = /%20/g, sn = /\[\]$/, on = /\r?\n/g, un = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i, an = /^(?:select|textarea)/i;
    v.fn.extend({
        serialize: function() {
            return v.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                return this.elements ? v.makeArray(this.elements) : this;
            }).filter(function() {
                return this.name && !this.disabled && (this.checked || an.test(this.nodeName) || un.test(this.type));
            }).map(function(e, t) {
                var n = v(this).val();
                return n == null ? null : v.isArray(n) ? v.map(n, function(e, n) {
                    return {
                        name: t.name,
                        value: e.replace(on, "\r\n")
                    };
                }) : {
                    name: t.name,
                    value: n.replace(on, "\r\n")
                };
            }).get();
        }
    }), v.param = function(e, n) {
        var r, i = [], s = function(e, t) {
            t = v.isFunction(t) ? t() : t == null ? "" : t, i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t);
        };
        n === t && (n = v.ajaxSettings && v.ajaxSettings.traditional);
        if (v.isArray(e) || e.jquery && !v.isPlainObject(e)) v.each(e, function() {
            s(this.name, this.value);
        }); else for (r in e) fn(r, e[r], n, s);
        return i.join("&").replace(rn, "+");
    };
    var ln, cn, hn = /#.*$/, pn = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, dn = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/, vn = /^(?:GET|HEAD)$/, mn = /^\/\//, gn = /\?/, yn = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, bn = /([?&])_=[^&]*/, wn = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, En = v.fn.load, Sn = {}, xn = {}, Tn = [ "*/" ] + [ "*" ];
    try {
        cn = s.href;
    } catch (Nn) {
        cn = i.createElement("a"), cn.href = "", cn = cn.href;
    }
    ln = wn.exec(cn.toLowerCase()) || [], v.fn.load = function(e, n, r) {
        if (typeof e != "string" && En) return En.apply(this, arguments);
        if (!this.length) return this;
        var i, s, o, u = this, a = e.indexOf(" ");
        return a >= 0 && (i = e.slice(a, e.length), e = e.slice(0, a)), v.isFunction(n) ? (r = n, 
        n = t) : n && typeof n == "object" && (s = "POST"), v.ajax({
            url: e,
            type: s,
            dataType: "html",
            data: n,
            complete: function(e, t) {
                r && u.each(r, o || [ e.responseText, t, e ]);
            }
        }).done(function(e) {
            o = arguments, u.html(i ? v("<div>").append(e.replace(yn, "")).find(i) : e);
        }), this;
    }, v.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function(e, t) {
        v.fn[t] = function(e) {
            return this.on(t, e);
        };
    }), v.each([ "get", "post" ], function(e, n) {
        v[n] = function(e, r, i, s) {
            return v.isFunction(r) && (s = s || i, i = r, r = t), v.ajax({
                type: n,
                url: e,
                data: r,
                success: i,
                dataType: s
            });
        };
    }), v.extend({
        getScript: function(e, n) {
            return v.get(e, t, n, "script");
        },
        getJSON: function(e, t, n) {
            return v.get(e, t, n, "json");
        },
        ajaxSetup: function(e, t) {
            return t ? Ln(e, v.ajaxSettings) : (t = e, e = v.ajaxSettings), Ln(e, t), e;
        },
        ajaxSettings: {
            url: cn,
            isLocal: dn.test(ln[1]),
            global: !0,
            type: "GET",
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            processData: !0,
            async: !0,
            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": Tn
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },
            converters: {
                "* text": e.String,
                "text html": !0,
                "text json": v.parseJSON,
                "text xml": v.parseXML
            },
            flatOptions: {
                context: !0,
                url: !0
            }
        },
        ajaxPrefilter: Cn(Sn),
        ajaxTransport: Cn(xn),
        ajax: function(e, n) {
            function T(e, n, s, a) {
                var l, y, b, w, S, T = n;
                if (E === 2) return;
                E = 2, u && clearTimeout(u), o = t, i = a || "", x.readyState = e > 0 ? 4 : 0, s && (w = An(c, x, s));
                if (e >= 200 && e < 300 || e === 304) c.ifModified && (S = x.getResponseHeader("Last-Modified"), 
                S && (v.lastModified[r] = S), S = x.getResponseHeader("Etag"), S && (v.etag[r] = S)), 
                e === 304 ? (T = "notmodified", l = !0) : (l = On(c, w), T = l.state, y = l.data, 
                b = l.error, l = !b); else {
                    b = T;
                    if (!T || e) T = "error", e < 0 && (e = 0);
                }
                x.status = e, x.statusText = (n || T) + "", l ? d.resolveWith(h, [ y, T, x ]) : d.rejectWith(h, [ x, T, b ]), 
                x.statusCode(g), g = t, f && p.trigger("ajax" + (l ? "Success" : "Error"), [ x, c, l ? y : b ]), 
                m.fireWith(h, [ x, T ]), f && (p.trigger("ajaxComplete", [ x, c ]), --v.active || v.event.trigger("ajaxStop"));
            }
            typeof e == "object" && (n = e, e = t), n = n || {};
            var r, i, s, o, u, a, f, l, c = v.ajaxSetup({}, n), h = c.context || c, p = h !== c && (h.nodeType || h instanceof v) ? v(h) : v.event, d = v.Deferred(), m = v.Callbacks("once memory"), g = c.statusCode || {}, b = {}, w = {}, E = 0, S = "canceled", x = {
                readyState: 0,
                setRequestHeader: function(e, t) {
                    if (!E) {
                        var n = e.toLowerCase();
                        e = w[n] = w[n] || e, b[e] = t;
                    }
                    return this;
                },
                getAllResponseHeaders: function() {
                    return E === 2 ? i : null;
                },
                getResponseHeader: function(e) {
                    var n;
                    if (E === 2) {
                        if (!s) {
                            s = {};
                            while (n = pn.exec(i)) s[n[1].toLowerCase()] = n[2];
                        }
                        n = s[e.toLowerCase()];
                    }
                    return n === t ? null : n;
                },
                overrideMimeType: function(e) {
                    return E || (c.mimeType = e), this;
                },
                abort: function(e) {
                    return e = e || S, o && o.abort(e), T(0, e), this;
                }
            };
            d.promise(x), x.success = x.done, x.error = x.fail, x.complete = m.add, x.statusCode = function(e) {
                if (e) {
                    var t;
                    if (E < 2) for (t in e) g[t] = [ g[t], e[t] ]; else t = e[x.status], x.always(t);
                }
                return this;
            }, c.url = ((e || c.url) + "").replace(hn, "").replace(mn, ln[1] + "//"), c.dataTypes = v.trim(c.dataType || "*").toLowerCase().split(y), 
            c.crossDomain == null && (a = wn.exec(c.url.toLowerCase()), c.crossDomain = !(!a || a[1] === ln[1] && a[2] === ln[2] && (a[3] || (a[1] === "http:" ? 80 : 443)) == (ln[3] || (ln[1] === "http:" ? 80 : 443)))), 
            c.data && c.processData && typeof c.data != "string" && (c.data = v.param(c.data, c.traditional)), 
            kn(Sn, c, n, x);
            if (E === 2) return x;
            f = c.global, c.type = c.type.toUpperCase(), c.hasContent = !vn.test(c.type), f && v.active++ === 0 && v.event.trigger("ajaxStart");
            if (!c.hasContent) {
                c.data && (c.url += (gn.test(c.url) ? "&" : "?") + c.data, delete c.data), r = c.url;
                if (c.cache === !1) {
                    var N = v.now(), C = c.url.replace(bn, "$1_=" + N);
                    c.url = C + (C === c.url ? (gn.test(c.url) ? "&" : "?") + "_=" + N : "");
                }
            }
            (c.data && c.hasContent && c.contentType !== !1 || n.contentType) && x.setRequestHeader("Content-Type", c.contentType), 
            c.ifModified && (r = r || c.url, v.lastModified[r] && x.setRequestHeader("If-Modified-Since", v.lastModified[r]), 
            v.etag[r] && x.setRequestHeader("If-None-Match", v.etag[r])), x.setRequestHeader("Accept", c.dataTypes[0] && c.accepts[c.dataTypes[0]] ? c.accepts[c.dataTypes[0]] + (c.dataTypes[0] !== "*" ? ", " + Tn + "; q=0.01" : "") : c.accepts["*"]);
            for (l in c.headers) x.setRequestHeader(l, c.headers[l]);
            if (!c.beforeSend || c.beforeSend.call(h, x, c) !== !1 && E !== 2) {
                S = "abort";
                for (l in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) x[l](c[l]);
                o = kn(xn, c, n, x);
                if (!o) T(-1, "No Transport"); else {
                    x.readyState = 1, f && p.trigger("ajaxSend", [ x, c ]), c.async && c.timeout > 0 && (u = setTimeout(function() {
                        x.abort("timeout");
                    }, c.timeout));
                    try {
                        E = 1, o.send(b, T);
                    } catch (k) {
                        if (!(E < 2)) throw k;
                        T(-1, k);
                    }
                }
                return x;
            }
            return x.abort();
        },
        active: 0,
        lastModified: {},
        etag: {}
    });
    var Mn = [], _n = /\?/, Dn = /(=)\?(?=&|$)|\?\?/, Pn = v.now();
    v.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var e = Mn.pop() || v.expando + "_" + Pn++;
            return this[e] = !0, e;
        }
    }), v.ajaxPrefilter("json jsonp", function(n, r, i) {
        var s, o, u, a = n.data, f = n.url, l = n.jsonp !== !1, c = l && Dn.test(f), h = l && !c && typeof a == "string" && !(n.contentType || "").indexOf("application/x-www-form-urlencoded") && Dn.test(a);
        if (n.dataTypes[0] === "jsonp" || c || h) return s = n.jsonpCallback = v.isFunction(n.jsonpCallback) ? n.jsonpCallback() : n.jsonpCallback, 
        o = e[s], c ? n.url = f.replace(Dn, "$1" + s) : h ? n.data = a.replace(Dn, "$1" + s) : l && (n.url += (_n.test(f) ? "&" : "?") + n.jsonp + "=" + s), 
        n.converters["script json"] = function() {
            return u || v.error(s + " was not called"), u[0];
        }, n.dataTypes[0] = "json", e[s] = function() {
            u = arguments;
        }, i.always(function() {
            e[s] = o, n[s] && (n.jsonpCallback = r.jsonpCallback, Mn.push(s)), u && v.isFunction(o) && o(u[0]), 
            u = o = t;
        }), "script";
    }), v.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function(e) {
                return v.globalEval(e), e;
            }
        }
    }), v.ajaxPrefilter("script", function(e) {
        e.cache === t && (e.cache = !1), e.crossDomain && (e.type = "GET", e.global = !1);
    }), v.ajaxTransport("script", function(e) {
        if (e.crossDomain) {
            var n, r = i.head || i.getElementsByTagName("head")[0] || i.documentElement;
            return {
                send: function(s, o) {
                    n = i.createElement("script"), n.async = "async", e.scriptCharset && (n.charset = e.scriptCharset), 
                    n.src = e.url, n.onload = n.onreadystatechange = function(e, i) {
                        if (i || !n.readyState || /loaded|complete/.test(n.readyState)) n.onload = n.onreadystatechange = null, 
                        r && n.parentNode && r.removeChild(n), n = t, i || o(200, "success");
                    }, r.insertBefore(n, r.firstChild);
                },
                abort: function() {
                    n && n.onload(0, 1);
                }
            };
        }
    });
    var Hn, Bn = e.ActiveXObject ? function() {
        for (var e in Hn) Hn[e](0, 1);
    } : !1, jn = 0;
    v.ajaxSettings.xhr = e.ActiveXObject ? function() {
        return !this.isLocal && Fn() || In();
    } : Fn, function(e) {
        v.extend(v.support, {
            ajax: !!e,
            cors: !!e && "withCredentials" in e
        });
    }(v.ajaxSettings.xhr()), v.support.ajax && v.ajaxTransport(function(n) {
        if (!n.crossDomain || v.support.cors) {
            var r;
            return {
                send: function(i, s) {
                    var o, u, a = n.xhr();
                    n.username ? a.open(n.type, n.url, n.async, n.username, n.password) : a.open(n.type, n.url, n.async);
                    if (n.xhrFields) for (u in n.xhrFields) a[u] = n.xhrFields[u];
                    n.mimeType && a.overrideMimeType && a.overrideMimeType(n.mimeType), !n.crossDomain && !i["X-Requested-With"] && (i["X-Requested-With"] = "XMLHttpRequest");
                    try {
                        for (u in i) a.setRequestHeader(u, i[u]);
                    } catch (f) {}
                    a.send(n.hasContent && n.data || null), r = function(e, i) {
                        var u, f, l, c, h;
                        try {
                            if (r && (i || a.readyState === 4)) {
                                r = t, o && (a.onreadystatechange = v.noop, Bn && delete Hn[o]);
                                if (i) a.readyState !== 4 && a.abort(); else {
                                    u = a.status, l = a.getAllResponseHeaders(), c = {}, h = a.responseXML, h && h.documentElement && (c.xml = h);
                                    try {
                                        c.text = a.responseText;
                                    } catch (p) {}
                                    try {
                                        f = a.statusText;
                                    } catch (p) {
                                        f = "";
                                    }
                                    !u && n.isLocal && !n.crossDomain ? u = c.text ? 200 : 404 : u === 1223 && (u = 204);
                                }
                            }
                        } catch (d) {
                            i || s(-1, d);
                        }
                        c && s(u, f, c, l);
                    }, n.async ? a.readyState === 4 ? setTimeout(r, 0) : (o = ++jn, Bn && (Hn || (Hn = {}, 
                    v(e).unload(Bn)), Hn[o] = r), a.onreadystatechange = r) : r();
                },
                abort: function() {
                    r && r(0, 1);
                }
            };
        }
    });
    var qn, Rn, Un = /^(?:toggle|show|hide)$/, zn = new RegExp("^(?:([-+])=|)(" + m + ")([a-z%]*)$", "i"), Wn = /queueHooks$/, Xn = [ Gn ], Vn = {
        "*": [ function(e, t) {
            var n, r, i = this.createTween(e, t), s = zn.exec(t), o = i.cur(), u = +o || 0, a = 1, f = 20;
            if (s) {
                n = +s[2], r = s[3] || (v.cssNumber[e] ? "" : "px");
                if (r !== "px" && u) {
                    u = v.css(i.elem, e, !0) || n || 1;
                    do a = a || ".5", u /= a, v.style(i.elem, e, u + r); while (a !== (a = i.cur() / o) && a !== 1 && --f);
                }
                i.unit = r, i.start = u, i.end = s[1] ? u + (s[1] + 1) * n : n;
            }
            return i;
        } ]
    };
    v.Animation = v.extend(Kn, {
        tweener: function(e, t) {
            v.isFunction(e) ? (t = e, e = [ "*" ]) : e = e.split(" ");
            var n, r = 0, i = e.length;
            for (;r < i; r++) n = e[r], Vn[n] = Vn[n] || [], Vn[n].unshift(t);
        },
        prefilter: function(e, t) {
            t ? Xn.unshift(e) : Xn.push(e);
        }
    }), v.Tween = Yn, Yn.prototype = {
        constructor: Yn,
        init: function(e, t, n, r, i, s) {
            this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur(), 
            this.end = r, this.unit = s || (v.cssNumber[n] ? "" : "px");
        },
        cur: function() {
            var e = Yn.propHooks[this.prop];
            return e && e.get ? e.get(this) : Yn.propHooks._default.get(this);
        },
        run: function(e) {
            var t, n = Yn.propHooks[this.prop];
            return this.options.duration ? this.pos = t = v.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, 
            this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            n && n.set ? n.set(this) : Yn.propHooks._default.set(this), this;
        }
    }, Yn.prototype.init.prototype = Yn.prototype, Yn.propHooks = {
        _default: {
            get: function(e) {
                var t;
                return e.elem[e.prop] == null || !!e.elem.style && e.elem.style[e.prop] != null ? (t = v.css(e.elem, e.prop, !1, ""), 
                !t || t === "auto" ? 0 : t) : e.elem[e.prop];
            },
            set: function(e) {
                v.fx.step[e.prop] ? v.fx.step[e.prop](e) : e.elem.style && (e.elem.style[v.cssProps[e.prop]] != null || v.cssHooks[e.prop]) ? v.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now;
            }
        }
    }, Yn.propHooks.scrollTop = Yn.propHooks.scrollLeft = {
        set: function(e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);
        }
    }, v.each([ "toggle", "show", "hide" ], function(e, t) {
        var n = v.fn[t];
        v.fn[t] = function(r, i, s) {
            return r == null || typeof r == "boolean" || !e && v.isFunction(r) && v.isFunction(i) ? n.apply(this, arguments) : this.animate(Zn(t, !0), r, i, s);
        };
    }), v.fn.extend({
        fadeTo: function(e, t, n, r) {
            return this.filter(Gt).css("opacity", 0).show().end().animate({
                opacity: t
            }, e, n, r);
        },
        animate: function(e, t, n, r) {
            var i = v.isEmptyObject(e), s = v.speed(t, n, r), o = function() {
                var t = Kn(this, v.extend({}, e), s);
                i && t.stop(!0);
            };
            return i || s.queue === !1 ? this.each(o) : this.queue(s.queue, o);
        },
        stop: function(e, n, r) {
            var i = function(e) {
                var t = e.stop;
                delete e.stop, t(r);
            };
            return typeof e != "string" && (r = n, n = e, e = t), n && e !== !1 && this.queue(e || "fx", []), 
            this.each(function() {
                var t = !0, n = e != null && e + "queueHooks", s = v.timers, o = v._data(this);
                if (n) o[n] && o[n].stop && i(o[n]); else for (n in o) o[n] && o[n].stop && Wn.test(n) && i(o[n]);
                for (n = s.length; n--; ) s[n].elem === this && (e == null || s[n].queue === e) && (s[n].anim.stop(r), 
                t = !1, s.splice(n, 1));
                (t || !r) && v.dequeue(this, e);
            });
        }
    }), v.each({
        slideDown: Zn("show"),
        slideUp: Zn("hide"),
        slideToggle: Zn("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(e, t) {
        v.fn[e] = function(e, n, r) {
            return this.animate(t, e, n, r);
        };
    }), v.speed = function(e, t, n) {
        var r = e && typeof e == "object" ? v.extend({}, e) : {
            complete: n || !n && t || v.isFunction(e) && e,
            duration: e,
            easing: n && t || t && !v.isFunction(t) && t
        };
        r.duration = v.fx.off ? 0 : typeof r.duration == "number" ? r.duration : r.duration in v.fx.speeds ? v.fx.speeds[r.duration] : v.fx.speeds._default;
        if (r.queue == null || r.queue === !0) r.queue = "fx";
        return r.old = r.complete, r.complete = function() {
            v.isFunction(r.old) && r.old.call(this), r.queue && v.dequeue(this, r.queue);
        }, r;
    }, v.easing = {
        linear: function(e) {
            return e;
        },
        swing: function(e) {
            return .5 - Math.cos(e * Math.PI) / 2;
        }
    }, v.timers = [], v.fx = Yn.prototype.init, v.fx.tick = function() {
        var e, n = v.timers, r = 0;
        qn = v.now();
        for (;r < n.length; r++) e = n[r], !e() && n[r] === e && n.splice(r--, 1);
        n.length || v.fx.stop(), qn = t;
    }, v.fx.timer = function(e) {
        e() && v.timers.push(e) && !Rn && (Rn = setInterval(v.fx.tick, v.fx.interval));
    }, v.fx.interval = 13, v.fx.stop = function() {
        clearInterval(Rn), Rn = null;
    }, v.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, v.fx.step = {}, v.expr && v.expr.filters && (v.expr.filters.animated = function(e) {
        return v.grep(v.timers, function(t) {
            return e === t.elem;
        }).length;
    });
    var er = /^(?:body|html)$/i;
    v.fn.offset = function(e) {
        if (arguments.length) return e === t ? this : this.each(function(t) {
            v.offset.setOffset(this, e, t);
        });
        var n, r, i, s, o, u, a, f = {
            top: 0,
            left: 0
        }, l = this[0], c = l && l.ownerDocument;
        if (!c) return;
        return (r = c.body) === l ? v.offset.bodyOffset(l) : (n = c.documentElement, v.contains(n, l) ? (typeof l.getBoundingClientRect != "undefined" && (f = l.getBoundingClientRect()), 
        i = tr(c), s = n.clientTop || r.clientTop || 0, o = n.clientLeft || r.clientLeft || 0, 
        u = i.pageYOffset || n.scrollTop, a = i.pageXOffset || n.scrollLeft, {
            top: f.top + u - s,
            left: f.left + a - o
        }) : f);
    }, v.offset = {
        bodyOffset: function(e) {
            var t = e.offsetTop, n = e.offsetLeft;
            return v.support.doesNotIncludeMarginInBodyOffset && (t += parseFloat(v.css(e, "marginTop")) || 0, 
            n += parseFloat(v.css(e, "marginLeft")) || 0), {
                top: t,
                left: n
            };
        },
        setOffset: function(e, t, n) {
            var r = v.css(e, "position");
            r === "static" && (e.style.position = "relative");
            var i = v(e), s = i.offset(), o = v.css(e, "top"), u = v.css(e, "left"), a = (r === "absolute" || r === "fixed") && v.inArray("auto", [ o, u ]) > -1, f = {}, l = {}, c, h;
            a ? (l = i.position(), c = l.top, h = l.left) : (c = parseFloat(o) || 0, h = parseFloat(u) || 0), 
            v.isFunction(t) && (t = t.call(e, n, s)), t.top != null && (f.top = t.top - s.top + c), 
            t.left != null && (f.left = t.left - s.left + h), "using" in t ? t.using.call(e, f) : i.css(f);
        }
    }, v.fn.extend({
        position: function() {
            if (!this[0]) return;
            var e = this[0], t = this.offsetParent(), n = this.offset(), r = er.test(t[0].nodeName) ? {
                top: 0,
                left: 0
            } : t.offset();
            return n.top -= parseFloat(v.css(e, "marginTop")) || 0, n.left -= parseFloat(v.css(e, "marginLeft")) || 0, 
            r.top += parseFloat(v.css(t[0], "borderTopWidth")) || 0, r.left += parseFloat(v.css(t[0], "borderLeftWidth")) || 0, 
            {
                top: n.top - r.top,
                left: n.left - r.left
            };
        },
        offsetParent: function() {
            return this.map(function() {
                var e = this.offsetParent || i.body;
                while (e && !er.test(e.nodeName) && v.css(e, "position") === "static") e = e.offsetParent;
                return e || i.body;
            });
        }
    }), v.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(e, n) {
        var r = /Y/.test(n);
        v.fn[e] = function(i) {
            return v.access(this, function(e, i, s) {
                var o = tr(e);
                if (s === t) return o ? n in o ? o[n] : o.document.documentElement[i] : e[i];
                o ? o.scrollTo(r ? v(o).scrollLeft() : s, r ? s : v(o).scrollTop()) : e[i] = s;
            }, e, i, arguments.length, null);
        };
    }), v.each({
        Height: "height",
        Width: "width"
    }, function(e, n) {
        v.each({
            padding: "inner" + e,
            content: n,
            "": "outer" + e
        }, function(r, i) {
            v.fn[i] = function(i, s) {
                var o = arguments.length && (r || typeof i != "boolean"), u = r || (i === !0 || s === !0 ? "margin" : "border");
                return v.access(this, function(n, r, i) {
                    var s;
                    return v.isWindow(n) ? n.document.documentElement["client" + e] : n.nodeType === 9 ? (s = n.documentElement, 
                    Math.max(n.body["scroll" + e], s["scroll" + e], n.body["offset" + e], s["offset" + e], s["client" + e])) : i === t ? v.css(n, r, i, u) : v.style(n, r, i, u);
                }, n, o ? i : t, o, null);
            };
        });
    }), e.jQuery = e.$ = v, typeof define == "function" && define.amd && define.amd.jQuery && define("jquery", [], function() {
        return v;
    });
})(window);

(function() {
    function n(n) {
        function t(t, r, e, u, i, o) {
            for (;i >= 0 && o > i; i += n) {
                var a = u ? u[i] : i;
                e = r(e, t[a], a, t);
            }
            return e;
        }
        return function(r, e, u, i) {
            e = b(e, i, 4);
            var o = !k(r) && m.keys(r), a = (o || r).length, c = n > 0 ? 0 : a - 1;
            return arguments.length < 3 && (u = r[o ? o[c] : c], c += n), t(r, e, u, o, c, a);
        };
    }
    function t(n) {
        return function(t, r, e) {
            r = x(r, e);
            for (var u = O(t), i = n > 0 ? 0 : u - 1; i >= 0 && u > i; i += n) if (r(t[i], i, t)) return i;
            return -1;
        };
    }
    function r(n, t, r) {
        return function(e, u, i) {
            var o = 0, a = O(e);
            if ("number" == typeof i) n > 0 ? o = i >= 0 ? i : Math.max(i + a, o) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1; else if (r && i && a) return i = r(e, u), 
            e[i] === u ? i : -1;
            if (u !== u) return i = t(l.call(e, o, a), m.isNaN), i >= 0 ? i + o : -1;
            for (i = n > 0 ? o : a - 1; i >= 0 && a > i; i += n) if (e[i] === u) return i;
            return -1;
        };
    }
    function e(n, t) {
        var r = I.length, e = n.constructor, u = m.isFunction(e) && e.prototype || a, i = "constructor";
        for (m.has(n, i) && !m.contains(t, i) && t.push(i); r--; ) i = I[r], i in n && n[i] !== u[i] && !m.contains(t, i) && t.push(i);
    }
    var u = this, i = u._, o = Array.prototype, a = Object.prototype, c = Function.prototype, f = o.push, l = o.slice, s = a.toString, p = a.hasOwnProperty, h = Array.isArray, v = Object.keys, g = c.bind, y = Object.create, d = function() {}, m = function(n) {
        return n instanceof m ? n : this instanceof m ? void (this._wrapped = n) : new m(n);
    };
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = m), 
    exports._ = m) : u._ = m, m.VERSION = "1.8.3";
    var b = function(n, t, r) {
        if (t === void 0) return n;
        switch (null == r ? 3 : r) {
          case 1:
            return function(r) {
                return n.call(t, r);
            };

          case 2:
            return function(r, e) {
                return n.call(t, r, e);
            };

          case 3:
            return function(r, e, u) {
                return n.call(t, r, e, u);
            };

          case 4:
            return function(r, e, u, i) {
                return n.call(t, r, e, u, i);
            };
        }
        return function() {
            return n.apply(t, arguments);
        };
    }, x = function(n, t, r) {
        return null == n ? m.identity : m.isFunction(n) ? b(n, t, r) : m.isObject(n) ? m.matcher(n) : m.property(n);
    };
    m.iteratee = function(n, t) {
        return x(n, t, 1 / 0);
    };
    var _ = function(n, t) {
        return function(r) {
            var e = arguments.length;
            if (2 > e || null == r) return r;
            for (var u = 1; e > u; u++) for (var i = arguments[u], o = n(i), a = o.length, c = 0; a > c; c++) {
                var f = o[c];
                t && r[f] !== void 0 || (r[f] = i[f]);
            }
            return r;
        };
    }, j = function(n) {
        if (!m.isObject(n)) return {};
        if (y) return y(n);
        d.prototype = n;
        var t = new d();
        return d.prototype = null, t;
    }, w = function(n) {
        return function(t) {
            return null == t ? void 0 : t[n];
        };
    }, A = Math.pow(2, 53) - 1, O = w("length"), k = function(n) {
        var t = O(n);
        return "number" == typeof t && t >= 0 && A >= t;
    };
    m.each = m.forEach = function(n, t, r) {
        t = b(t, r);
        var e, u;
        if (k(n)) for (e = 0, u = n.length; u > e; e++) t(n[e], e, n); else {
            var i = m.keys(n);
            for (e = 0, u = i.length; u > e; e++) t(n[i[e]], i[e], n);
        }
        return n;
    }, m.map = m.collect = function(n, t, r) {
        t = x(t, r);
        for (var e = !k(n) && m.keys(n), u = (e || n).length, i = Array(u), o = 0; u > o; o++) {
            var a = e ? e[o] : o;
            i[o] = t(n[a], a, n);
        }
        return i;
    }, m.reduce = m.foldl = m.inject = n(1), m.reduceRight = m.foldr = n(-1), m.find = m.detect = function(n, t, r) {
        var e;
        return e = k(n) ? m.findIndex(n, t, r) : m.findKey(n, t, r), e !== void 0 && e !== -1 ? n[e] : void 0;
    }, m.filter = m.select = function(n, t, r) {
        var e = [];
        return t = x(t, r), m.each(n, function(n, r, u) {
            t(n, r, u) && e.push(n);
        }), e;
    }, m.reject = function(n, t, r) {
        return m.filter(n, m.negate(x(t)), r);
    }, m.every = m.all = function(n, t, r) {
        t = x(t, r);
        for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {
            var o = e ? e[i] : i;
            if (!t(n[o], o, n)) return !1;
        }
        return !0;
    }, m.some = m.any = function(n, t, r) {
        t = x(t, r);
        for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {
            var o = e ? e[i] : i;
            if (t(n[o], o, n)) return !0;
        }
        return !1;
    }, m.contains = m.includes = m.include = function(n, t, r, e) {
        return k(n) || (n = m.values(n)), ("number" != typeof r || e) && (r = 0), m.indexOf(n, t, r) >= 0;
    }, m.invoke = function(n, t) {
        var r = l.call(arguments, 2), e = m.isFunction(t);
        return m.map(n, function(n) {
            var u = e ? t : n[t];
            return null == u ? u : u.apply(n, r);
        });
    }, m.pluck = function(n, t) {
        return m.map(n, m.property(t));
    }, m.where = function(n, t) {
        return m.filter(n, m.matcher(t));
    }, m.findWhere = function(n, t) {
        return m.find(n, m.matcher(t));
    }, m.max = function(n, t, r) {
        var e, u, i = -1 / 0, o = -1 / 0;
        if (null == t && null != n) {
            n = k(n) ? n : m.values(n);
            for (var a = 0, c = n.length; c > a; a++) e = n[a], e > i && (i = e);
        } else t = x(t, r), m.each(n, function(n, r, e) {
            u = t(n, r, e), (u > o || u === -1 / 0 && i === -1 / 0) && (i = n, o = u);
        });
        return i;
    }, m.min = function(n, t, r) {
        var e, u, i = 1 / 0, o = 1 / 0;
        if (null == t && null != n) {
            n = k(n) ? n : m.values(n);
            for (var a = 0, c = n.length; c > a; a++) e = n[a], i > e && (i = e);
        } else t = x(t, r), m.each(n, function(n, r, e) {
            u = t(n, r, e), (o > u || 1 / 0 === u && 1 / 0 === i) && (i = n, o = u);
        });
        return i;
    }, m.shuffle = function(n) {
        for (var t, r = k(n) ? n : m.values(n), e = r.length, u = Array(e), i = 0; e > i; i++) t = m.random(0, i), 
        t !== i && (u[i] = u[t]), u[t] = r[i];
        return u;
    }, m.sample = function(n, t, r) {
        return null == t || r ? (k(n) || (n = m.values(n)), n[m.random(n.length - 1)]) : m.shuffle(n).slice(0, Math.max(0, t));
    }, m.sortBy = function(n, t, r) {
        return t = x(t, r), m.pluck(m.map(n, function(n, r, e) {
            return {
                value: n,
                index: r,
                criteria: t(n, r, e)
            };
        }).sort(function(n, t) {
            var r = n.criteria, e = t.criteria;
            if (r !== e) {
                if (r > e || r === void 0) return 1;
                if (e > r || e === void 0) return -1;
            }
            return n.index - t.index;
        }), "value");
    };
    var F = function(n) {
        return function(t, r, e) {
            var u = {};
            return r = x(r, e), m.each(t, function(e, i) {
                var o = r(e, i, t);
                n(u, e, o);
            }), u;
        };
    };
    m.groupBy = F(function(n, t, r) {
        m.has(n, r) ? n[r].push(t) : n[r] = [ t ];
    }), m.indexBy = F(function(n, t, r) {
        n[r] = t;
    }), m.countBy = F(function(n, t, r) {
        m.has(n, r) ? n[r]++ : n[r] = 1;
    }), m.toArray = function(n) {
        return n ? m.isArray(n) ? l.call(n) : k(n) ? m.map(n, m.identity) : m.values(n) : [];
    }, m.size = function(n) {
        return null == n ? 0 : k(n) ? n.length : m.keys(n).length;
    }, m.partition = function(n, t, r) {
        t = x(t, r);
        var e = [], u = [];
        return m.each(n, function(n, r, i) {
            (t(n, r, i) ? e : u).push(n);
        }), [ e, u ];
    }, m.first = m.head = m.take = function(n, t, r) {
        return null == n ? void 0 : null == t || r ? n[0] : m.initial(n, n.length - t);
    }, m.initial = function(n, t, r) {
        return l.call(n, 0, Math.max(0, n.length - (null == t || r ? 1 : t)));
    }, m.last = function(n, t, r) {
        return null == n ? void 0 : null == t || r ? n[n.length - 1] : m.rest(n, Math.max(0, n.length - t));
    }, m.rest = m.tail = m.drop = function(n, t, r) {
        return l.call(n, null == t || r ? 1 : t);
    }, m.compact = function(n) {
        return m.filter(n, m.identity);
    };
    var S = function(n, t, r, e) {
        for (var u = [], i = 0, o = e || 0, a = O(n); a > o; o++) {
            var c = n[o];
            if (k(c) && (m.isArray(c) || m.isArguments(c))) {
                t || (c = S(c, t, r));
                var f = 0, l = c.length;
                for (u.length += l; l > f; ) u[i++] = c[f++];
            } else r || (u[i++] = c);
        }
        return u;
    };
    m.flatten = function(n, t) {
        return S(n, t, !1);
    }, m.without = function(n) {
        return m.difference(n, l.call(arguments, 1));
    }, m.uniq = m.unique = function(n, t, r, e) {
        m.isBoolean(t) || (e = r, r = t, t = !1), null != r && (r = x(r, e));
        for (var u = [], i = [], o = 0, a = O(n); a > o; o++) {
            var c = n[o], f = r ? r(c, o, n) : c;
            t ? (o && i === f || u.push(c), i = f) : r ? m.contains(i, f) || (i.push(f), u.push(c)) : m.contains(u, c) || u.push(c);
        }
        return u;
    }, m.union = function() {
        return m.uniq(S(arguments, !0, !0));
    }, m.intersection = function(n) {
        for (var t = [], r = arguments.length, e = 0, u = O(n); u > e; e++) {
            var i = n[e];
            if (!m.contains(t, i)) {
                for (var o = 1; r > o && m.contains(arguments[o], i); o++) ;
                o === r && t.push(i);
            }
        }
        return t;
    }, m.difference = function(n) {
        var t = S(arguments, !0, !0, 1);
        return m.filter(n, function(n) {
            return !m.contains(t, n);
        });
    }, m.zip = function() {
        return m.unzip(arguments);
    }, m.unzip = function(n) {
        for (var t = n && m.max(n, O).length || 0, r = Array(t), e = 0; t > e; e++) r[e] = m.pluck(n, e);
        return r;
    }, m.object = function(n, t) {
        for (var r = {}, e = 0, u = O(n); u > e; e++) t ? r[n[e]] = t[e] : r[n[e][0]] = n[e][1];
        return r;
    }, m.findIndex = t(1), m.findLastIndex = t(-1), m.sortedIndex = function(n, t, r, e) {
        r = x(r, e, 1);
        for (var u = r(t), i = 0, o = O(n); o > i; ) {
            var a = Math.floor((i + o) / 2);
            r(n[a]) < u ? i = a + 1 : o = a;
        }
        return i;
    }, m.indexOf = r(1, m.findIndex, m.sortedIndex), m.lastIndexOf = r(-1, m.findLastIndex), 
    m.range = function(n, t, r) {
        null == t && (t = n || 0, n = 0), r = r || 1;
        for (var e = Math.max(Math.ceil((t - n) / r), 0), u = Array(e), i = 0; e > i; i++, 
        n += r) u[i] = n;
        return u;
    };
    var E = function(n, t, r, e, u) {
        if (!(e instanceof t)) return n.apply(r, u);
        var i = j(n.prototype), o = n.apply(i, u);
        return m.isObject(o) ? o : i;
    };
    m.bind = function(n, t) {
        if (g && n.bind === g) return g.apply(n, l.call(arguments, 1));
        if (!m.isFunction(n)) throw new TypeError("Bind must be called on a function");
        var r = l.call(arguments, 2), e = function() {
            return E(n, e, t, this, r.concat(l.call(arguments)));
        };
        return e;
    }, m.partial = function(n) {
        var t = l.call(arguments, 1), r = function() {
            for (var e = 0, u = t.length, i = Array(u), o = 0; u > o; o++) i[o] = t[o] === m ? arguments[e++] : t[o];
            for (;e < arguments.length; ) i.push(arguments[e++]);
            return E(n, r, this, this, i);
        };
        return r;
    }, m.bindAll = function(n) {
        var t, r, e = arguments.length;
        if (1 >= e) throw new Error("bindAll must be passed function names");
        for (t = 1; e > t; t++) r = arguments[t], n[r] = m.bind(n[r], n);
        return n;
    }, m.memoize = function(n, t) {
        var r = function(e) {
            var u = r.cache, i = "" + (t ? t.apply(this, arguments) : e);
            return m.has(u, i) || (u[i] = n.apply(this, arguments)), u[i];
        };
        return r.cache = {}, r;
    }, m.delay = function(n, t) {
        var r = l.call(arguments, 2);
        return setTimeout(function() {
            return n.apply(null, r);
        }, t);
    }, m.defer = m.partial(m.delay, m, 1), m.throttle = function(n, t, r) {
        var e, u, i, o = null, a = 0;
        r || (r = {});
        var c = function() {
            a = r.leading === !1 ? 0 : m.now(), o = null, i = n.apply(e, u), o || (e = u = null);
        };
        return function() {
            var f = m.now();
            a || r.leading !== !1 || (a = f);
            var l = t - (f - a);
            return e = this, u = arguments, 0 >= l || l > t ? (o && (clearTimeout(o), o = null), 
            a = f, i = n.apply(e, u), o || (e = u = null)) : o || r.trailing === !1 || (o = setTimeout(c, l)), 
            i;
        };
    }, m.debounce = function(n, t, r) {
        var e, u, i, o, a, c = function() {
            var f = m.now() - o;
            t > f && f >= 0 ? e = setTimeout(c, t - f) : (e = null, r || (a = n.apply(i, u), 
            e || (i = u = null)));
        };
        return function() {
            i = this, u = arguments, o = m.now();
            var f = r && !e;
            return e || (e = setTimeout(c, t)), f && (a = n.apply(i, u), i = u = null), a;
        };
    }, m.wrap = function(n, t) {
        return m.partial(t, n);
    }, m.negate = function(n) {
        return function() {
            return !n.apply(this, arguments);
        };
    }, m.compose = function() {
        var n = arguments, t = n.length - 1;
        return function() {
            for (var r = t, e = n[t].apply(this, arguments); r--; ) e = n[r].call(this, e);
            return e;
        };
    }, m.after = function(n, t) {
        return function() {
            return --n < 1 ? t.apply(this, arguments) : void 0;
        };
    }, m.before = function(n, t) {
        var r;
        return function() {
            return --n > 0 && (r = t.apply(this, arguments)), 1 >= n && (t = null), r;
        };
    }, m.once = m.partial(m.before, 2);
    var M = !{
        toString: null
    }.propertyIsEnumerable("toString"), I = [ "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString" ];
    m.keys = function(n) {
        if (!m.isObject(n)) return [];
        if (v) return v(n);
        var t = [];
        for (var r in n) m.has(n, r) && t.push(r);
        return M && e(n, t), t;
    }, m.allKeys = function(n) {
        if (!m.isObject(n)) return [];
        var t = [];
        for (var r in n) t.push(r);
        return M && e(n, t), t;
    }, m.values = function(n) {
        for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = n[t[u]];
        return e;
    }, m.mapObject = function(n, t, r) {
        t = x(t, r);
        for (var e, u = m.keys(n), i = u.length, o = {}, a = 0; i > a; a++) e = u[a], o[e] = t(n[e], e, n);
        return o;
    }, m.pairs = function(n) {
        for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = [ t[u], n[t[u]] ];
        return e;
    }, m.invert = function(n) {
        for (var t = {}, r = m.keys(n), e = 0, u = r.length; u > e; e++) t[n[r[e]]] = r[e];
        return t;
    }, m.functions = m.methods = function(n) {
        var t = [];
        for (var r in n) m.isFunction(n[r]) && t.push(r);
        return t.sort();
    }, m.extend = _(m.allKeys), m.extendOwn = m.assign = _(m.keys), m.findKey = function(n, t, r) {
        t = x(t, r);
        for (var e, u = m.keys(n), i = 0, o = u.length; o > i; i++) if (e = u[i], t(n[e], e, n)) return e;
    }, m.pick = function(n, t, r) {
        var e, u, i = {}, o = n;
        if (null == o) return i;
        m.isFunction(t) ? (u = m.allKeys(o), e = b(t, r)) : (u = S(arguments, !1, !1, 1), 
        e = function(n, t, r) {
            return t in r;
        }, o = Object(o));
        for (var a = 0, c = u.length; c > a; a++) {
            var f = u[a], l = o[f];
            e(l, f, o) && (i[f] = l);
        }
        return i;
    }, m.omit = function(n, t, r) {
        if (m.isFunction(t)) t = m.negate(t); else {
            var e = m.map(S(arguments, !1, !1, 1), String);
            t = function(n, t) {
                return !m.contains(e, t);
            };
        }
        return m.pick(n, t, r);
    }, m.defaults = _(m.allKeys, !0), m.create = function(n, t) {
        var r = j(n);
        return t && m.extendOwn(r, t), r;
    }, m.clone = function(n) {
        return m.isObject(n) ? m.isArray(n) ? n.slice() : m.extend({}, n) : n;
    }, m.tap = function(n, t) {
        return t(n), n;
    }, m.isMatch = function(n, t) {
        var r = m.keys(t), e = r.length;
        if (null == n) return !e;
        for (var u = Object(n), i = 0; e > i; i++) {
            var o = r[i];
            if (t[o] !== u[o] || !(o in u)) return !1;
        }
        return !0;
    };
    var N = function(n, t, r, e) {
        if (n === t) return 0 !== n || 1 / n === 1 / t;
        if (null == n || null == t) return n === t;
        n instanceof m && (n = n._wrapped), t instanceof m && (t = t._wrapped);
        var u = s.call(n);
        if (u !== s.call(t)) return !1;
        switch (u) {
          case "[object RegExp]":
          case "[object String]":
            return "" + n == "" + t;

          case "[object Number]":
            return +n !== +n ? +t !== +t : 0 === +n ? 1 / +n === 1 / t : +n === +t;

          case "[object Date]":
          case "[object Boolean]":
            return +n === +t;
        }
        var i = "[object Array]" === u;
        if (!i) {
            if ("object" != typeof n || "object" != typeof t) return !1;
            var o = n.constructor, a = t.constructor;
            if (o !== a && !(m.isFunction(o) && o instanceof o && m.isFunction(a) && a instanceof a) && "constructor" in n && "constructor" in t) return !1;
        }
        r = r || [], e = e || [];
        for (var c = r.length; c--; ) if (r[c] === n) return e[c] === t;
        if (r.push(n), e.push(t), i) {
            if (c = n.length, c !== t.length) return !1;
            for (;c--; ) if (!N(n[c], t[c], r, e)) return !1;
        } else {
            var f, l = m.keys(n);
            if (c = l.length, m.keys(t).length !== c) return !1;
            for (;c--; ) if (f = l[c], !m.has(t, f) || !N(n[f], t[f], r, e)) return !1;
        }
        return r.pop(), e.pop(), !0;
    };
    m.isEqual = function(n, t) {
        return N(n, t);
    }, m.isEmpty = function(n) {
        return null == n ? !0 : k(n) && (m.isArray(n) || m.isString(n) || m.isArguments(n)) ? 0 === n.length : 0 === m.keys(n).length;
    }, m.isElement = function(n) {
        return !(!n || 1 !== n.nodeType);
    }, m.isArray = h || function(n) {
        return "[object Array]" === s.call(n);
    }, m.isObject = function(n) {
        var t = typeof n;
        return "function" === t || "object" === t && !!n;
    }, m.each([ "Arguments", "Function", "String", "Number", "Date", "RegExp", "Error" ], function(n) {
        m["is" + n] = function(t) {
            return s.call(t) === "[object " + n + "]";
        };
    }), m.isArguments(arguments) || (m.isArguments = function(n) {
        return m.has(n, "callee");
    }), "function" != typeof /./ && "object" != typeof Int8Array && (m.isFunction = function(n) {
        return "function" == typeof n || !1;
    }), m.isFinite = function(n) {
        return isFinite(n) && !isNaN(parseFloat(n));
    }, m.isNaN = function(n) {
        return m.isNumber(n) && n !== +n;
    }, m.isBoolean = function(n) {
        return n === !0 || n === !1 || "[object Boolean]" === s.call(n);
    }, m.isNull = function(n) {
        return null === n;
    }, m.isUndefined = function(n) {
        return n === void 0;
    }, m.has = function(n, t) {
        return null != n && p.call(n, t);
    }, m.noConflict = function() {
        return u._ = i, this;
    }, m.identity = function(n) {
        return n;
    }, m.constant = function(n) {
        return function() {
            return n;
        };
    }, m.noop = function() {}, m.property = w, m.propertyOf = function(n) {
        return null == n ? function() {} : function(t) {
            return n[t];
        };
    }, m.matcher = m.matches = function(n) {
        return n = m.extendOwn({}, n), function(t) {
            return m.isMatch(t, n);
        };
    }, m.times = function(n, t, r) {
        var e = Array(Math.max(0, n));
        t = b(t, r, 1);
        for (var u = 0; n > u; u++) e[u] = t(u);
        return e;
    }, m.random = function(n, t) {
        return null == t && (t = n, n = 0), n + Math.floor(Math.random() * (t - n + 1));
    }, m.now = Date.now || function() {
        return new Date().getTime();
    };
    var B = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    }, T = m.invert(B), R = function(n) {
        var t = function(t) {
            return n[t];
        }, r = "(?:" + m.keys(n).join("|") + ")", e = RegExp(r), u = RegExp(r, "g");
        return function(n) {
            return n = null == n ? "" : "" + n, e.test(n) ? n.replace(u, t) : n;
        };
    };
    m.escape = R(B), m.unescape = R(T), m.result = function(n, t, r) {
        var e = null == n ? void 0 : n[t];
        return e === void 0 && (e = r), m.isFunction(e) ? e.call(n) : e;
    };
    var q = 0;
    m.uniqueId = function(n) {
        var t = ++q + "";
        return n ? n + t : t;
    }, m.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    var K = /(.)^/, z = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, D = /\\|'|\r|\n|\u2028|\u2029/g, L = function(n) {
        return "\\" + z[n];
    };
    m.template = function(n, t, r) {
        !t && r && (t = r), t = m.defaults({}, t, m.templateSettings);
        var e = RegExp([ (t.escape || K).source, (t.interpolate || K).source, (t.evaluate || K).source ].join("|") + "|$", "g"), u = 0, i = "__p+='";
        n.replace(e, function(t, r, e, o, a) {
            return i += n.slice(u, a).replace(D, L), u = a + t.length, r ? i += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'" : e ? i += "'+\n((__t=(" + e + "))==null?'':__t)+\n'" : o && (i += "';\n" + o + "\n__p+='"), 
            t;
        }), i += "';\n", t.variable || (i = "with(obj||{}){\n" + i + "}\n"), i = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + i + "return __p;\n";
        try {
            var o = new Function(t.variable || "obj", "_", i);
        } catch (a) {
            throw a.source = i, a;
        }
        var c = function(n) {
            return o.call(this, n, m);
        }, f = t.variable || "obj";
        return c.source = "function(" + f + "){\n" + i + "}", c;
    }, m.chain = function(n) {
        var t = m(n);
        return t._chain = !0, t;
    };
    var P = function(n, t) {
        return n._chain ? m(t).chain() : t;
    };
    m.mixin = function(n) {
        m.each(m.functions(n), function(t) {
            var r = m[t] = n[t];
            m.prototype[t] = function() {
                var n = [ this._wrapped ];
                return f.apply(n, arguments), P(this, r.apply(m, n));
            };
        });
    }, m.mixin(m), m.each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(n) {
        var t = o[n];
        m.prototype[n] = function() {
            var r = this._wrapped;
            return t.apply(r, arguments), "shift" !== n && "splice" !== n || 0 !== r.length || delete r[0], 
            P(this, r);
        };
    }), m.each([ "concat", "join", "slice" ], function(n) {
        var t = o[n];
        m.prototype[n] = function() {
            return P(this, t.apply(this._wrapped, arguments));
        };
    }), m.prototype.value = function() {
        return this._wrapped;
    }, m.prototype.valueOf = m.prototype.toJSON = m.prototype.value, m.prototype.toString = function() {
        return "" + this._wrapped;
    }, "function" == typeof define && define.amd && define("underscore", [], function() {
        return m;
    });
}).call(this);

(function(factory) {
    var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global;
    if (typeof define === "function" && define.amd) {
        define("backbone", [ "underscore", "jquery", "exports" ], function(_, $, exports) {
            root.Backbone = factory(root, exports, _, $);
        });
    } else if (typeof exports !== "undefined") {
        var _ = require("underscore"), $;
        try {
            $ = require("jquery");
        } catch (e) {}
        factory(root, exports, _, $);
    } else {
        root.Backbone = factory(root, {}, root._, root.jQuery || root.Zepto || root.ender || root.$);
    }
})(function(root, Backbone, _, $) {
    var previousBackbone = root.Backbone;
    var slice = Array.prototype.slice;
    Backbone.VERSION = "1.3.3";
    Backbone.$ = $;
    Backbone.noConflict = function() {
        root.Backbone = previousBackbone;
        return this;
    };
    Backbone.emulateHTTP = false;
    Backbone.emulateJSON = false;
    var addMethod = function(length, method, attribute) {
        switch (length) {
          case 1:
            return function() {
                return _[method](this[attribute]);
            };

          case 2:
            return function(value) {
                return _[method](this[attribute], value);
            };

          case 3:
            return function(iteratee, context) {
                return _[method](this[attribute], cb(iteratee, this), context);
            };

          case 4:
            return function(iteratee, defaultVal, context) {
                return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
            };

          default:
            return function() {
                var args = slice.call(arguments);
                args.unshift(this[attribute]);
                return _[method].apply(_, args);
            };
        }
    };
    var addUnderscoreMethods = function(Class, methods, attribute) {
        _.each(methods, function(length, method) {
            if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
        });
    };
    var cb = function(iteratee, instance) {
        if (_.isFunction(iteratee)) return iteratee;
        if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
        if (_.isString(iteratee)) return function(model) {
            return model.get(iteratee);
        };
        return iteratee;
    };
    var modelMatcher = function(attrs) {
        var matcher = _.matches(attrs);
        return function(model) {
            return matcher(model.attributes);
        };
    };
    var Events = Backbone.Events = {};
    var eventSplitter = /\s+/;
    var eventsApi = function(iteratee, events, name, callback, opts) {
        var i = 0, names;
        if (name && typeof name === "object") {
            if (callback !== void 0 && "context" in opts && opts.context === void 0) opts.context = callback;
            for (names = _.keys(name); i < names.length; i++) {
                events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
            }
        } else if (name && eventSplitter.test(name)) {
            for (names = name.split(eventSplitter); i < names.length; i++) {
                events = iteratee(events, names[i], callback, opts);
            }
        } else {
            events = iteratee(events, name, callback, opts);
        }
        return events;
    };
    Events.on = function(name, callback, context) {
        return internalOn(this, name, callback, context);
    };
    var internalOn = function(obj, name, callback, context, listening) {
        obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
            context: context,
            ctx: obj,
            listening: listening
        });
        if (listening) {
            var listeners = obj._listeners || (obj._listeners = {});
            listeners[listening.id] = listening;
        }
        return obj;
    };
    Events.listenTo = function(obj, name, callback) {
        if (!obj) return this;
        var id = obj._listenId || (obj._listenId = _.uniqueId("l"));
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var listening = listeningTo[id];
        if (!listening) {
            var thisId = this._listenId || (this._listenId = _.uniqueId("l"));
            listening = listeningTo[id] = {
                obj: obj,
                objId: id,
                id: thisId,
                listeningTo: listeningTo,
                count: 0
            };
        }
        internalOn(obj, name, callback, this, listening);
        return this;
    };
    var onApi = function(events, name, callback, options) {
        if (callback) {
            var handlers = events[name] || (events[name] = []);
            var context = options.context, ctx = options.ctx, listening = options.listening;
            if (listening) listening.count++;
            handlers.push({
                callback: callback,
                context: context,
                ctx: context || ctx,
                listening: listening
            });
        }
        return events;
    };
    Events.off = function(name, callback, context) {
        if (!this._events) return this;
        this._events = eventsApi(offApi, this._events, name, callback, {
            context: context,
            listeners: this._listeners
        });
        return this;
    };
    Events.stopListening = function(obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo) return this;
        var ids = obj ? [ obj._listenId ] : _.keys(listeningTo);
        for (var i = 0; i < ids.length; i++) {
            var listening = listeningTo[ids[i]];
            if (!listening) break;
            listening.obj.off(name, callback, this);
        }
        return this;
    };
    var offApi = function(events, name, callback, options) {
        if (!events) return;
        var i = 0, listening;
        var context = options.context, listeners = options.listeners;
        if (!name && !callback && !context) {
            var ids = _.keys(listeners);
            for (;i < ids.length; i++) {
                listening = listeners[ids[i]];
                delete listeners[listening.id];
                delete listening.listeningTo[listening.objId];
            }
            return;
        }
        var names = name ? [ name ] : _.keys(events);
        for (;i < names.length; i++) {
            name = names[i];
            var handlers = events[name];
            if (!handlers) break;
            var remaining = [];
            for (var j = 0; j < handlers.length; j++) {
                var handler = handlers[j];
                if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {
                    remaining.push(handler);
                } else {
                    listening = handler.listening;
                    if (listening && --listening.count === 0) {
                        delete listeners[listening.id];
                        delete listening.listeningTo[listening.objId];
                    }
                }
            }
            if (remaining.length) {
                events[name] = remaining;
            } else {
                delete events[name];
            }
        }
        return events;
    };
    Events.once = function(name, callback, context) {
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
        if (typeof name === "string" && context == null) callback = void 0;
        return this.on(events, callback, context);
    };
    Events.listenToOnce = function(obj, name, callback) {
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
        return this.listenTo(obj, events);
    };
    var onceMap = function(map, name, callback, offer) {
        if (callback) {
            var once = map[name] = _.once(function() {
                offer(name, once);
                callback.apply(this, arguments);
            });
            once._callback = callback;
        }
        return map;
    };
    Events.trigger = function(name) {
        if (!this._events) return this;
        var length = Math.max(0, arguments.length - 1);
        var args = Array(length);
        for (var i = 0; i < length; i++) args[i] = arguments[i + 1];
        eventsApi(triggerApi, this._events, name, void 0, args);
        return this;
    };
    var triggerApi = function(objEvents, name, callback, args) {
        if (objEvents) {
            var events = objEvents[name];
            var allEvents = objEvents.all;
            if (events && allEvents) allEvents = allEvents.slice();
            if (events) triggerEvents(events, args);
            if (allEvents) triggerEvents(allEvents, [ name ].concat(args));
        }
        return objEvents;
    };
    var triggerEvents = function(events, args) {
        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
        switch (args.length) {
          case 0:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx);
            return;

          case 1:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);
            return;

          case 2:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);
            return;

          case 3:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
            return;

          default:
            while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
            return;
        }
    };
    Events.bind = Events.on;
    Events.unbind = Events.off;
    _.extend(Backbone, Events);
    var Model = Backbone.Model = function(attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.cid = _.uniqueId(this.cidPrefix);
        this.attributes = {};
        if (options.collection) this.collection = options.collection;
        if (options.parse) attrs = this.parse(attrs, options) || {};
        var defaults = _.result(this, "defaults");
        attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
    };
    _.extend(Model.prototype, Events, {
        changed: null,
        validationError: null,
        idAttribute: "id",
        cidPrefix: "c",
        initialize: function() {},
        toJSON: function(options) {
            return _.clone(this.attributes);
        },
        sync: function() {
            return Backbone.sync.apply(this, arguments);
        },
        get: function(attr) {
            return this.attributes[attr];
        },
        escape: function(attr) {
            return _.escape(this.get(attr));
        },
        has: function(attr) {
            return this.get(attr) != null;
        },
        matches: function(attrs) {
            return !!_.iteratee(attrs, this)(this.attributes);
        },
        set: function(key, val, options) {
            if (key == null) return this;
            var attrs;
            if (typeof key === "object") {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }
            options || (options = {});
            if (!this._validate(attrs, options)) return false;
            var unset = options.unset;
            var silent = options.silent;
            var changes = [];
            var changing = this._changing;
            this._changing = true;
            if (!changing) {
                this._previousAttributes = _.clone(this.attributes);
                this.changed = {};
            }
            var current = this.attributes;
            var changed = this.changed;
            var prev = this._previousAttributes;
            for (var attr in attrs) {
                val = attrs[attr];
                if (!_.isEqual(current[attr], val)) changes.push(attr);
                if (!_.isEqual(prev[attr], val)) {
                    changed[attr] = val;
                } else {
                    delete changed[attr];
                }
                unset ? delete current[attr] : current[attr] = val;
            }
            if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);
            if (!silent) {
                if (changes.length) this._pending = options;
                for (var i = 0; i < changes.length; i++) {
                    this.trigger("change:" + changes[i], this, current[changes[i]], options);
                }
            }
            if (changing) return this;
            if (!silent) {
                while (this._pending) {
                    options = this._pending;
                    this._pending = false;
                    this.trigger("change", this, options);
                }
            }
            this._pending = false;
            this._changing = false;
            return this;
        },
        unset: function(attr, options) {
            return this.set(attr, void 0, _.extend({}, options, {
                unset: true
            }));
        },
        clear: function(options) {
            var attrs = {};
            for (var key in this.attributes) attrs[key] = void 0;
            return this.set(attrs, _.extend({}, options, {
                unset: true
            }));
        },
        hasChanged: function(attr) {
            if (attr == null) return !_.isEmpty(this.changed);
            return _.has(this.changed, attr);
        },
        changedAttributes: function(diff) {
            if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
            var old = this._changing ? this._previousAttributes : this.attributes;
            var changed = {};
            for (var attr in diff) {
                var val = diff[attr];
                if (_.isEqual(old[attr], val)) continue;
                changed[attr] = val;
            }
            return _.size(changed) ? changed : false;
        },
        previous: function(attr) {
            if (attr == null || !this._previousAttributes) return null;
            return this._previousAttributes[attr];
        },
        previousAttributes: function() {
            return _.clone(this._previousAttributes);
        },
        fetch: function(options) {
            options = _.extend({
                parse: true
            }, options);
            var model = this;
            var success = options.success;
            options.success = function(resp) {
                var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                if (!model.set(serverAttrs, options)) return false;
                if (success) success.call(options.context, model, resp, options);
                model.trigger("sync", model, resp, options);
            };
            wrapError(this, options);
            return this.sync("read", this, options);
        },
        save: function(key, val, options) {
            var attrs;
            if (key == null || typeof key === "object") {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }
            options = _.extend({
                validate: true,
                parse: true
            }, options);
            var wait = options.wait;
            if (attrs && !wait) {
                if (!this.set(attrs, options)) return false;
            } else if (!this._validate(attrs, options)) {
                return false;
            }
            var model = this;
            var success = options.success;
            var attributes = this.attributes;
            options.success = function(resp) {
                model.attributes = attributes;
                var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
                if (serverAttrs && !model.set(serverAttrs, options)) return false;
                if (success) success.call(options.context, model, resp, options);
                model.trigger("sync", model, resp, options);
            };
            wrapError(this, options);
            if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);
            var method = this.isNew() ? "create" : options.patch ? "patch" : "update";
            if (method === "patch" && !options.attrs) options.attrs = attrs;
            var xhr = this.sync(method, this, options);
            this.attributes = attributes;
            return xhr;
        },
        destroy: function(options) {
            options = options ? _.clone(options) : {};
            var model = this;
            var success = options.success;
            var wait = options.wait;
            var destroy = function() {
                model.stopListening();
                model.trigger("destroy", model, model.collection, options);
            };
            options.success = function(resp) {
                if (wait) destroy();
                if (success) success.call(options.context, model, resp, options);
                if (!model.isNew()) model.trigger("sync", model, resp, options);
            };
            var xhr = false;
            if (this.isNew()) {
                _.defer(options.success);
            } else {
                wrapError(this, options);
                xhr = this.sync("delete", this, options);
            }
            if (!wait) destroy();
            return xhr;
        },
        url: function() {
            var base = _.result(this, "urlRoot") || _.result(this.collection, "url") || urlError();
            if (this.isNew()) return base;
            var id = this.get(this.idAttribute);
            return base.replace(/[^\/]$/, "$&/") + encodeURIComponent(id);
        },
        parse: function(resp, options) {
            return resp;
        },
        clone: function() {
            return new this.constructor(this.attributes);
        },
        isNew: function() {
            return !this.has(this.idAttribute);
        },
        isValid: function(options) {
            return this._validate({}, _.extend({}, options, {
                validate: true
            }));
        },
        _validate: function(attrs, options) {
            if (!options.validate || !this.validate) return true;
            attrs = _.extend({}, this.attributes, attrs);
            var error = this.validationError = this.validate(attrs, options) || null;
            if (!error) return true;
            this.trigger("invalid", this, error, _.extend(options, {
                validationError: error
            }));
            return false;
        }
    });
    var modelMethods = {
        keys: 1,
        values: 1,
        pairs: 1,
        invert: 1,
        pick: 0,
        omit: 0,
        chain: 1,
        isEmpty: 1
    };
    addUnderscoreMethods(Model, modelMethods, "attributes");
    var Collection = Backbone.Collection = function(models, options) {
        options || (options = {});
        if (options.model) this.model = options.model;
        if (options.comparator !== void 0) this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models) this.reset(models, _.extend({
            silent: true
        }, options));
    };
    var setOptions = {
        add: true,
        remove: true,
        merge: true
    };
    var addOptions = {
        add: true,
        remove: false
    };
    var splice = function(array, insert, at) {
        at = Math.min(Math.max(at, 0), array.length);
        var tail = Array(array.length - at);
        var length = insert.length;
        var i;
        for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
        for (i = 0; i < length; i++) array[i + at] = insert[i];
        for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
    };
    _.extend(Collection.prototype, Events, {
        model: Model,
        initialize: function() {},
        toJSON: function(options) {
            return this.map(function(model) {
                return model.toJSON(options);
            });
        },
        sync: function() {
            return Backbone.sync.apply(this, arguments);
        },
        add: function(models, options) {
            return this.set(models, _.extend({
                merge: false
            }, options, addOptions));
        },
        remove: function(models, options) {
            options = _.extend({}, options);
            var singular = !_.isArray(models);
            models = singular ? [ models ] : models.slice();
            var removed = this._removeModels(models, options);
            if (!options.silent && removed.length) {
                options.changes = {
                    added: [],
                    merged: [],
                    removed: removed
                };
                this.trigger("update", this, options);
            }
            return singular ? removed[0] : removed;
        },
        set: function(models, options) {
            if (models == null) return;
            options = _.extend({}, setOptions, options);
            if (options.parse && !this._isModel(models)) {
                models = this.parse(models, options) || [];
            }
            var singular = !_.isArray(models);
            models = singular ? [ models ] : models.slice();
            var at = options.at;
            if (at != null) at = +at;
            if (at > this.length) at = this.length;
            if (at < 0) at += this.length + 1;
            var set = [];
            var toAdd = [];
            var toMerge = [];
            var toRemove = [];
            var modelMap = {};
            var add = options.add;
            var merge = options.merge;
            var remove = options.remove;
            var sort = false;
            var sortable = this.comparator && at == null && options.sort !== false;
            var sortAttr = _.isString(this.comparator) ? this.comparator : null;
            var model, i;
            for (i = 0; i < models.length; i++) {
                model = models[i];
                var existing = this.get(model);
                if (existing) {
                    if (merge && model !== existing) {
                        var attrs = this._isModel(model) ? model.attributes : model;
                        if (options.parse) attrs = existing.parse(attrs, options);
                        existing.set(attrs, options);
                        toMerge.push(existing);
                        if (sortable && !sort) sort = existing.hasChanged(sortAttr);
                    }
                    if (!modelMap[existing.cid]) {
                        modelMap[existing.cid] = true;
                        set.push(existing);
                    }
                    models[i] = existing;
                } else if (add) {
                    model = models[i] = this._prepareModel(model, options);
                    if (model) {
                        toAdd.push(model);
                        this._addReference(model, options);
                        modelMap[model.cid] = true;
                        set.push(model);
                    }
                }
            }
            if (remove) {
                for (i = 0; i < this.length; i++) {
                    model = this.models[i];
                    if (!modelMap[model.cid]) toRemove.push(model);
                }
                if (toRemove.length) this._removeModels(toRemove, options);
            }
            var orderChanged = false;
            var replace = !sortable && add && remove;
            if (set.length && replace) {
                orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {
                    return m !== set[index];
                });
                this.models.length = 0;
                splice(this.models, set, 0);
                this.length = this.models.length;
            } else if (toAdd.length) {
                if (sortable) sort = true;
                splice(this.models, toAdd, at == null ? this.length : at);
                this.length = this.models.length;
            }
            if (sort) this.sort({
                silent: true
            });
            if (!options.silent) {
                for (i = 0; i < toAdd.length; i++) {
                    if (at != null) options.index = at + i;
                    model = toAdd[i];
                    model.trigger("add", model, this, options);
                }
                if (sort || orderChanged) this.trigger("sort", this, options);
                if (toAdd.length || toRemove.length || toMerge.length) {
                    options.changes = {
                        added: toAdd,
                        removed: toRemove,
                        merged: toMerge
                    };
                    this.trigger("update", this, options);
                }
            }
            return singular ? models[0] : models;
        },
        reset: function(models, options) {
            options = options ? _.clone(options) : {};
            for (var i = 0; i < this.models.length; i++) {
                this._removeReference(this.models[i], options);
            }
            options.previousModels = this.models;
            this._reset();
            models = this.add(models, _.extend({
                silent: true
            }, options));
            if (!options.silent) this.trigger("reset", this, options);
            return models;
        },
        push: function(model, options) {
            return this.add(model, _.extend({
                at: this.length
            }, options));
        },
        pop: function(options) {
            var model = this.at(this.length - 1);
            return this.remove(model, options);
        },
        unshift: function(model, options) {
            return this.add(model, _.extend({
                at: 0
            }, options));
        },
        shift: function(options) {
            var model = this.at(0);
            return this.remove(model, options);
        },
        slice: function() {
            return slice.apply(this.models, arguments);
        },
        get: function(obj) {
            if (obj == null) return void 0;
            return this._byId[obj] || this._byId[this.modelId(obj.attributes || obj)] || obj.cid && this._byId[obj.cid];
        },
        has: function(obj) {
            return this.get(obj) != null;
        },
        at: function(index) {
            if (index < 0) index += this.length;
            return this.models[index];
        },
        where: function(attrs, first) {
            return this[first ? "find" : "filter"](attrs);
        },
        findWhere: function(attrs) {
            return this.where(attrs, true);
        },
        sort: function(options) {
            var comparator = this.comparator;
            if (!comparator) throw new Error("Cannot sort a set without a comparator");
            options || (options = {});
            var length = comparator.length;
            if (_.isFunction(comparator)) comparator = _.bind(comparator, this);
            if (length === 1 || _.isString(comparator)) {
                this.models = this.sortBy(comparator);
            } else {
                this.models.sort(comparator);
            }
            if (!options.silent) this.trigger("sort", this, options);
            return this;
        },
        pluck: function(attr) {
            return this.map(attr + "");
        },
        fetch: function(options) {
            options = _.extend({
                parse: true
            }, options);
            var success = options.success;
            var collection = this;
            options.success = function(resp) {
                var method = options.reset ? "reset" : "set";
                collection[method](resp, options);
                if (success) success.call(options.context, collection, resp, options);
                collection.trigger("sync", collection, resp, options);
            };
            wrapError(this, options);
            return this.sync("read", this, options);
        },
        create: function(model, options) {
            options = options ? _.clone(options) : {};
            var wait = options.wait;
            model = this._prepareModel(model, options);
            if (!model) return false;
            if (!wait) this.add(model, options);
            var collection = this;
            var success = options.success;
            options.success = function(m, resp, callbackOpts) {
                if (wait) collection.add(m, callbackOpts);
                if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
            };
            model.save(null, options);
            return model;
        },
        parse: function(resp, options) {
            return resp;
        },
        clone: function() {
            return new this.constructor(this.models, {
                model: this.model,
                comparator: this.comparator
            });
        },
        modelId: function(attrs) {
            return attrs[this.model.prototype.idAttribute || "id"];
        },
        _reset: function() {
            this.length = 0;
            this.models = [];
            this._byId = {};
        },
        _prepareModel: function(attrs, options) {
            if (this._isModel(attrs)) {
                if (!attrs.collection) attrs.collection = this;
                return attrs;
            }
            options = options ? _.clone(options) : {};
            options.collection = this;
            var model = new this.model(attrs, options);
            if (!model.validationError) return model;
            this.trigger("invalid", this, model.validationError, options);
            return false;
        },
        _removeModels: function(models, options) {
            var removed = [];
            for (var i = 0; i < models.length; i++) {
                var model = this.get(models[i]);
                if (!model) continue;
                var index = this.indexOf(model);
                this.models.splice(index, 1);
                this.length--;
                delete this._byId[model.cid];
                var id = this.modelId(model.attributes);
                if (id != null) delete this._byId[id];
                if (!options.silent) {
                    options.index = index;
                    model.trigger("remove", model, this, options);
                }
                removed.push(model);
                this._removeReference(model, options);
            }
            return removed;
        },
        _isModel: function(model) {
            return model instanceof Model;
        },
        _addReference: function(model, options) {
            this._byId[model.cid] = model;
            var id = this.modelId(model.attributes);
            if (id != null) this._byId[id] = model;
            model.on("all", this._onModelEvent, this);
        },
        _removeReference: function(model, options) {
            delete this._byId[model.cid];
            var id = this.modelId(model.attributes);
            if (id != null) delete this._byId[id];
            if (this === model.collection) delete model.collection;
            model.off("all", this._onModelEvent, this);
        },
        _onModelEvent: function(event, model, collection, options) {
            if (model) {
                if ((event === "add" || event === "remove") && collection !== this) return;
                if (event === "destroy") this.remove(model, options);
                if (event === "change") {
                    var prevId = this.modelId(model.previousAttributes());
                    var id = this.modelId(model.attributes);
                    if (prevId !== id) {
                        if (prevId != null) delete this._byId[prevId];
                        if (id != null) this._byId[id] = model;
                    }
                }
            }
            this.trigger.apply(this, arguments);
        }
    });
    var collectionMethods = {
        forEach: 3,
        each: 3,
        map: 3,
        collect: 3,
        reduce: 0,
        foldl: 0,
        inject: 0,
        reduceRight: 0,
        foldr: 0,
        find: 3,
        detect: 3,
        filter: 3,
        select: 3,
        reject: 3,
        every: 3,
        all: 3,
        some: 3,
        any: 3,
        include: 3,
        includes: 3,
        contains: 3,
        invoke: 0,
        max: 3,
        min: 3,
        toArray: 1,
        size: 1,
        first: 3,
        head: 3,
        take: 3,
        initial: 3,
        rest: 3,
        tail: 3,
        drop: 3,
        last: 3,
        without: 0,
        difference: 0,
        indexOf: 3,
        shuffle: 1,
        lastIndexOf: 3,
        isEmpty: 1,
        chain: 1,
        sample: 3,
        partition: 3,
        groupBy: 3,
        countBy: 3,
        sortBy: 3,
        indexBy: 3,
        findIndex: 3,
        findLastIndex: 3
    };
    addUnderscoreMethods(Collection, collectionMethods, "models");
    var View = Backbone.View = function(options) {
        this.cid = _.uniqueId("view");
        _.extend(this, _.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
    };
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;
    var viewOptions = [ "model", "collection", "el", "id", "attributes", "className", "tagName", "events" ];
    _.extend(View.prototype, Events, {
        tagName: "div",
        $: function(selector) {
            return this.$el.find(selector);
        },
        initialize: function() {},
        render: function() {
            return this;
        },
        remove: function() {
            this._removeElement();
            this.stopListening();
            return this;
        },
        _removeElement: function() {
            this.$el.remove();
        },
        setElement: function(element) {
            this.undelegateEvents();
            this._setElement(element);
            this.delegateEvents();
            return this;
        },
        _setElement: function(el) {
            this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
            this.el = this.$el[0];
        },
        delegateEvents: function(events) {
            events || (events = _.result(this, "events"));
            if (!events) return this;
            this.undelegateEvents();
            for (var key in events) {
                var method = events[key];
                if (!_.isFunction(method)) method = this[method];
                if (!method) continue;
                var match = key.match(delegateEventSplitter);
                this.delegate(match[1], match[2], _.bind(method, this));
            }
            return this;
        },
        delegate: function(eventName, selector, listener) {
            this.$el.on(eventName + ".delegateEvents" + this.cid, selector, listener);
            return this;
        },
        undelegateEvents: function() {
            if (this.$el) this.$el.off(".delegateEvents" + this.cid);
            return this;
        },
        undelegate: function(eventName, selector, listener) {
            this.$el.off(eventName + ".delegateEvents" + this.cid, selector, listener);
            return this;
        },
        _createElement: function(tagName) {
            return document.createElement(tagName);
        },
        _ensureElement: function() {
            if (!this.el) {
                var attrs = _.extend({}, _.result(this, "attributes"));
                if (this.id) attrs.id = _.result(this, "id");
                if (this.className) attrs["class"] = _.result(this, "className");
                this.setElement(this._createElement(_.result(this, "tagName")));
                this._setAttributes(attrs);
            } else {
                this.setElement(_.result(this, "el"));
            }
        },
        _setAttributes: function(attributes) {
            this.$el.attr(attributes);
        }
    });
    Backbone.sync = function(method, model, options) {
        var type = methodMap[method];
        _.defaults(options || (options = {}), {
            emulateHTTP: Backbone.emulateHTTP,
            emulateJSON: Backbone.emulateJSON
        });
        var params = {
            type: type,
            dataType: "json"
        };
        if (!options.url) {
            params.url = _.result(model, "url") || urlError();
        }
        if (options.data == null && model && (method === "create" || method === "update" || method === "patch")) {
            params.contentType = "application/json";
            params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }
        if (options.emulateJSON) {
            params.contentType = "application/x-www-form-urlencoded";
            params.data = params.data ? {
                model: params.data
            } : {};
        }
        if (options.emulateHTTP && (type === "PUT" || type === "DELETE" || type === "PATCH")) {
            params.type = "POST";
            if (options.emulateJSON) params.data._method = type;
            var beforeSend = options.beforeSend;
            options.beforeSend = function(xhr) {
                xhr.setRequestHeader("X-HTTP-Method-Override", type);
                if (beforeSend) return beforeSend.apply(this, arguments);
            };
        }
        if (params.type !== "GET" && !options.emulateJSON) {
            params.processData = false;
        }
        var error = options.error;
        options.error = function(xhr, textStatus, errorThrown) {
            options.textStatus = textStatus;
            options.errorThrown = errorThrown;
            if (error) error.call(options.context, xhr, textStatus, errorThrown);
        };
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger("request", model, xhr, options);
        return xhr;
    };
    var methodMap = {
        create: "POST",
        update: "PUT",
        patch: "PATCH",
        delete: "DELETE",
        read: "GET"
    };
    Backbone.ajax = function() {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
    };
    var Router = Backbone.Router = function(options) {
        options || (options = {});
        if (options.routes) this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
    };
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /(\(\?)?:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
    _.extend(Router.prototype, Events, {
        initialize: function() {},
        route: function(route, name, callback) {
            if (!_.isRegExp(route)) route = this._routeToRegExp(route);
            if (_.isFunction(name)) {
                callback = name;
                name = "";
            }
            if (!callback) callback = this[name];
            var router = this;
            Backbone.history.route(route, function(fragment) {
                var args = router._extractParameters(route, fragment);
                if (router.execute(callback, args, name) !== false) {
                    router.trigger.apply(router, [ "route:" + name ].concat(args));
                    router.trigger("route", name, args);
                    Backbone.history.trigger("route", router, name, args);
                }
            });
            return this;
        },
        execute: function(callback, args, name) {
            if (callback) callback.apply(this, args);
        },
        navigate: function(fragment, options) {
            Backbone.history.navigate(fragment, options);
            return this;
        },
        _bindRoutes: function() {
            if (!this.routes) return;
            this.routes = _.result(this, "routes");
            var route, routes = _.keys(this.routes);
            while ((route = routes.pop()) != null) {
                this.route(route, this.routes[route]);
            }
        },
        _routeToRegExp: function(route) {
            route = route.replace(escapeRegExp, "\\$&").replace(optionalParam, "(?:$1)?").replace(namedParam, function(match, optional) {
                return optional ? match : "([^/?]+)";
            }).replace(splatParam, "([^?]*?)");
            return new RegExp("^" + route + "(?:\\?([\\s\\S]*))?$");
        },
        _extractParameters: function(route, fragment) {
            var params = route.exec(fragment).slice(1);
            return _.map(params, function(param, i) {
                if (i === params.length - 1) return param || null;
                return param ? decodeURIComponent(param) : null;
            });
        }
    });
    var History = Backbone.History = function() {
        this.handlers = [];
        this.checkUrl = _.bind(this.checkUrl, this);
        if (typeof window !== "undefined") {
            this.location = window.location;
            this.history = window.history;
        }
    };
    var routeStripper = /^[#\/]|\s+$/g;
    var rootStripper = /^\/+|\/+$/g;
    var pathStripper = /#.*$/;
    History.started = false;
    _.extend(History.prototype, Events, {
        interval: 50,
        atRoot: function() {
            var path = this.location.pathname.replace(/[^\/]$/, "$&/");
            return path === this.root && !this.getSearch();
        },
        matchRoot: function() {
            var path = this.decodeFragment(this.location.pathname);
            var rootPath = path.slice(0, this.root.length - 1) + "/";
            return rootPath === this.root;
        },
        decodeFragment: function(fragment) {
            return decodeURI(fragment.replace(/%25/g, "%2525"));
        },
        getSearch: function() {
            var match = this.location.href.replace(/#.*/, "").match(/\?.+/);
            return match ? match[0] : "";
        },
        getHash: function(window) {
            var match = (window || this).location.href.match(/#(.*)$/);
            return match ? match[1] : "";
        },
        getPath: function() {
            var path = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);
            return path.charAt(0) === "/" ? path.slice(1) : path;
        },
        getFragment: function(fragment) {
            if (fragment == null) {
                if (this._usePushState || !this._wantsHashChange) {
                    fragment = this.getPath();
                } else {
                    fragment = this.getHash();
                }
            }
            return fragment.replace(routeStripper, "");
        },
        start: function(options) {
            if (History.started) throw new Error("Backbone.history has already been started");
            History.started = true;
            this.options = _.extend({
                root: "/"
            }, this.options, options);
            this.root = this.options.root;
            this._wantsHashChange = this.options.hashChange !== false;
            this._hasHashChange = "onhashchange" in window && (document.documentMode === void 0 || document.documentMode > 7);
            this._useHashChange = this._wantsHashChange && this._hasHashChange;
            this._wantsPushState = !!this.options.pushState;
            this._hasPushState = !!(this.history && this.history.pushState);
            this._usePushState = this._wantsPushState && this._hasPushState;
            this.fragment = this.getFragment();
            this.root = ("/" + this.root + "/").replace(rootStripper, "/");
            if (this._wantsHashChange && this._wantsPushState) {
                if (!this._hasPushState && !this.atRoot()) {
                    var rootPath = this.root.slice(0, -1) || "/";
                    this.location.replace(rootPath + "#" + this.getPath());
                    return true;
                } else if (this._hasPushState && this.atRoot()) {
                    this.navigate(this.getHash(), {
                        replace: true
                    });
                }
            }
            if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
                this.iframe = document.createElement("iframe");
                this.iframe.src = "javascript:0";
                this.iframe.style.display = "none";
                this.iframe.tabIndex = -1;
                var body = document.body;
                var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
                iWindow.document.open();
                iWindow.document.close();
                iWindow.location.hash = "#" + this.fragment;
            }
            var addEventListener = window.addEventListener || function(eventName, listener) {
                return attachEvent("on" + eventName, listener);
            };
            if (this._usePushState) {
                addEventListener("popstate", this.checkUrl, false);
            } else if (this._useHashChange && !this.iframe) {
                addEventListener("hashchange", this.checkUrl, false);
            } else if (this._wantsHashChange) {
                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
            }
            if (!this.options.silent) return this.loadUrl();
        },
        stop: function() {
            var removeEventListener = window.removeEventListener || function(eventName, listener) {
                return detachEvent("on" + eventName, listener);
            };
            if (this._usePushState) {
                removeEventListener("popstate", this.checkUrl, false);
            } else if (this._useHashChange && !this.iframe) {
                removeEventListener("hashchange", this.checkUrl, false);
            }
            if (this.iframe) {
                document.body.removeChild(this.iframe);
                this.iframe = null;
            }
            if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
            History.started = false;
        },
        route: function(route, callback) {
            this.handlers.unshift({
                route: route,
                callback: callback
            });
        },
        checkUrl: function(e) {
            var current = this.getFragment();
            if (current === this.fragment && this.iframe) {
                current = this.getHash(this.iframe.contentWindow);
            }
            if (current === this.fragment) return false;
            if (this.iframe) this.navigate(current);
            this.loadUrl();
        },
        loadUrl: function(fragment) {
            if (!this.matchRoot()) return false;
            fragment = this.fragment = this.getFragment(fragment);
            return _.some(this.handlers, function(handler) {
                if (handler.route.test(fragment)) {
                    handler.callback(fragment);
                    return true;
                }
            });
        },
        navigate: function(fragment, options) {
            if (!History.started) return false;
            if (!options || options === true) options = {
                trigger: !!options
            };
            fragment = this.getFragment(fragment || "");
            var rootPath = this.root;
            if (fragment === "" || fragment.charAt(0) === "?") {
                rootPath = rootPath.slice(0, -1) || "/";
            }
            var url = rootPath + fragment;
            fragment = this.decodeFragment(fragment.replace(pathStripper, ""));
            if (this.fragment === fragment) return;
            this.fragment = fragment;
            if (this._usePushState) {
                this.history[options.replace ? "replaceState" : "pushState"]({}, document.title, url);
            } else if (this._wantsHashChange) {
                this._updateHash(this.location, fragment, options.replace);
                if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
                    var iWindow = this.iframe.contentWindow;
                    if (!options.replace) {
                        iWindow.document.open();
                        iWindow.document.close();
                    }
                    this._updateHash(iWindow.location, fragment, options.replace);
                }
            } else {
                return this.location.assign(url);
            }
            if (options.trigger) return this.loadUrl(fragment);
        },
        _updateHash: function(location, fragment, replace) {
            if (replace) {
                var href = location.href.replace(/(javascript:|#).*$/, "");
                location.replace(href + "#" + fragment);
            } else {
                location.hash = "#" + fragment;
            }
        }
    });
    Backbone.history = new History();
    var extend = function(protoProps, staticProps) {
        var parent = this;
        var child;
        if (protoProps && _.has(protoProps, "constructor")) {
            child = protoProps.constructor;
        } else {
            child = function() {
                return parent.apply(this, arguments);
            };
        }
        _.extend(child, parent, staticProps);
        child.prototype = _.create(parent.prototype, protoProps);
        child.prototype.constructor = child;
        child.__super__ = parent.prototype;
        return child;
    };
    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
    var urlError = function() {
        throw new Error('A "url" property or function must be specified');
    };
    var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
            if (error) error.call(options.context, model, resp, options);
            model.trigger("error", model, resp, options);
        };
    };
    return Backbone;
});

define("app", [ "jquery", "backbone" ], function($, Backbone) {
    "use strict";
    var App = {
        Tracker: function() {
            return {
                sendEvent: function() {}
            };
        }(),
        Config: {
            Urls: {
                get Site() {
                    return window.IsProduction ? "https://mediasave.ru/" : "https://localhost:44365/";
                },
                get Uninstall() {
                    return this.Site + "service/uninstall/";
                },
                get Manual() {
                    return this.Site + "#manual";
                },
                get Api() {
                    return this.Site + "api";
                },
                get ApiRegistration() {
                    return this.Api + "/Registration/Create/";
                },
                get ApiGetConfiguration() {
                    return this.Api + "/Configuration/Get/?rnd=" + Math.random();
                },
                get ApiGetBanners() {
                    return this.Api + "/Banner/GetAll/?lang={0}&rnd=" + Math.random();
                },
                get ApiGetUrlInfoSummary() {
                    return this.Api + "/UrlInfo/Summary/";
                },
                get ApiCreateUrlInfo() {
                    return this.Api + "/UrlInfo/Create/";
                },
                get ApiGetBalance() {
                    return this.Api + "/Subscription/Get/?rnd=" + Math.random();
                },
                get ApiCreateDownload() {
                    return this.Api + "/Download/Create/";
                },
                get ApiGetUrlShareLink() {
                    return this.Api + "/Share/GetLink/?lang={0}&rnd=" + Math.random();
                },
                get UiHtml() {
                    return MS.Browser.extension.getURL("/app/ui/ui.html");
                },
                get PopupHtml() {
                    return MS.Browser.extension.getURL("/app/popup/popup.html");
                }
            },
            PatternInUrls: {
                IsDownloadRequest: "stoploading5600=",
                IsIDEInfoRequest: "ideInfo5600=",
                IsPlayRequest: "play5600="
            },
            StorageKeys: {
                UserData: "UserData",
                IsNotFirstLoad: "IsNotFirstLoad"
            },
            CookieKeys: {
                PlayPromoExample: "x-play-promo-example",
                VisitId: "x-visit-id",
                AccessToken: "x-access-token",
                VersionExtension: "x-version-extension"
            },
            Lang: function() {
                var locale = "en";
                if (MS.Browser.i18n && MS.Browser.i18n.getUILanguage() === "ru") {
                    locale = "ru";
                }
                return locale;
            }(),
            GoogleAnalitycsId: "UA-62809727-1",
            Browser: {
                Firefox: {
                    SiteUrl: "https://mediasave.ru/info/firefox/?utm_source=extension",
                    ExtensionUrl: "https://addons.mozilla.org/Ru/firefox/addon/mediasave/?utm_source=extension",
                    ReviewUrl: "https://addons.mozilla.org/Ru/firefox/addon/mediasave/?utm_source=extension"
                },
                Chrome: {
                    SiteUrl: "https://mediasave.ru/info/chrome/?utm_source=extension",
                    ExtensionUrl: "https://chrome.google.com/webstore/detail/mediasave-download-music/hfgbpkkdodfihabamnkhoaeamkdhnoec?utm_source=extension",
                    ReviewUrl: "https://chrome.google.com/webstore/detail/mediasave-download-music/hfgbpkkdodfihabamnkhoaeamkdhnoec/reviews?utm_source=extension"
                },
                Opera: {
                    SiteUrl: "https://mediasave.ru/info/opera/?utm_source=extension",
                    ExtensionUrl: "https://addons.opera.com/ru/extensions/details/mediasave-download-music-free/?utm_source=extension",
                    ReviewUrl: "https://addons.opera.com/ru/extensions/details/mediasave-download-music-free/?utm_source=extension"
                }
            }
        },
        Source: {
            View: {},
            Model: {},
            Collection: {},
            Router: {}
        },
        Runtime: {
            View: {},
            Models: {},
            Collection: {},
            Router: {}
        },
        MessageBind: window.Backbone ? _.extend(Backbone.Events) : {},
        Helpers: {
            GetUnixTime: function() {
                return parseInt(new Date().getTime() / 1e3);
            },
            ToFormattedTime: function(input) {
                var roundSeconds = true;
                if (roundSeconds) {
                    input = Math.ceil(input);
                }
                var hoursString = "00";
                var minutesString = "00";
                var secondsString = "00";
                var hours = 0;
                var minutes = 0;
                var seconds = 0;
                hours = Math.floor(input / (60 * 60));
                input = input % (60 * 60);
                minutes = Math.floor(input / 60);
                input = input % 60;
                seconds = input;
                hoursString = hours >= 10 ? hours.toString() : "0" + hours.toString();
                minutesString = minutes >= 10 ? minutes.toString() : "0" + minutes.toString();
                secondsString = seconds >= 10 ? seconds.toString() : "0" + seconds.toString();
                return (hoursString > 0 ? hoursString + ":" : "") + minutesString + ":" + secondsString;
            },
            SendMessage: function(name, to, data, tabId) {
                if (typeof to !== "object") {
                    to = [ to ];
                }
                for (var key in to) {
                    if (to[key] === "background" || to[key] === "popup") {
                        MS.Browser.runtime.sendMessage({
                            name: name,
                            data: data
                        });
                    } else if (to[key] === "app") {
                        MS.Browser.MessageBind.trigger(name, data);
                    } else if (to[key] === "client") {
                        MS.Browser.tabs.sendMessage(tabId, {
                            name: name,
                            data: data
                        });
                    }
                }
            },
            OnMessage: function(name, to, callback) {
                if (typeof to !== "object") {
                    to = [ to ];
                }
                for (var key in to) {
                    if (to[key] === "background" || to[key] === "popup" || to[key] === "client") {
                        MS.Browser.runtime.onMessage.addListener(function(request, sender, sendResponse) {
                            var id = sender.extensionId ? sender.extensionId : sender.id;
                            if (id !== MS.Browser.runtime.id) {
                                return;
                            }
                            if (request.name === name) {
                                callback(request.data, sender);
                            }
                        });
                    }
                }
            },
            Win2ToUnicode: function(str) {
                if (!str) {
                    return "";
                }
                var result = "";
                var o_code = "";
                var i_code = "";
                for (var I = 0; I < str.length; I++) {
                    i_code = str.charCodeAt(I);
                    if (i_code == 184) {
                        o_code = 1105;
                    } else if (i_code == 168) {
                        o_code = 1025;
                    } else if (i_code > 191 && i_code < 256) {
                        o_code = i_code + 848;
                    } else {
                        o_code = i_code;
                    }
                    result = result + String.fromCharCode(o_code);
                }
                var koi2utf = {
                    163: 1105,
                    179: 1025,
                    192: 1102,
                    193: 1072,
                    194: 1073,
                    195: 1094,
                    196: 1076,
                    197: 1077,
                    198: 1092,
                    199: 1075,
                    200: 1093,
                    201: 1080,
                    202: 1081,
                    203: 1082,
                    204: 1083,
                    205: 1084,
                    206: 1085,
                    207: 1086,
                    208: 1087,
                    209: 1103,
                    210: 1088,
                    211: 1089,
                    212: 1090,
                    213: 1091,
                    214: 1078,
                    215: 1074,
                    216: 1100,
                    217: 1099,
                    218: 1079,
                    219: 1096,
                    220: 1101,
                    221: 1097,
                    222: 1095,
                    223: 1098
                };
                function koi2unicode(str) {
                    if (str === null) {
                        return null;
                    }
                    var result = "";
                    var o_code = "";
                    var i_code = "";
                    for (var I = 0; I < str.length; I++) {
                        i_code = str.charCodeAt(I);
                        if (koi2utf[i_code] !== null) {
                            o_code = koi2utf[i_code];
                        } else if (i_code > 223 && koi2utf[i_code - 32] !== null) {
                            o_code = koi2utf[i_code - 32] - 32;
                        } else {
                            o_code = i_code;
                        }
                        result = result + String.fromCharCode(o_code);
                    }
                    return result;
                }
                return result;
            },
            GetNewGuid: function() {
                function s4() {
                    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
                }
                return s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
            },
            GetUserData: function(callback) {
                var key = App.Config.StorageKeys.UserData;
                var storage = this.Storage;
                storage.Get(key, $.proxy(function(data) {
                    if (data) {
                        callback({
                            AccessToken: data["AccessToken"]
                        });
                    } else {
                        callback({});
                    }
                }, this));
            },
            GoogleAnalitycs: {
                SendEvent: function(eventCategory, eventAction, value) {
                    var userId = App.Data.UserData.Id;
                    var request = new XMLHttpRequest();
                    var message = "v=1&t=event&ec=" + encodeURIComponent(eventCategory) + "&ev=" + encodeURIComponent(value) + "&ea=play&tid=" + App.Config.GoogleAnalitycsId + "&cid=" + userId;
                    request.open("POST", "https://www.google-analytics.com/collect", true);
                    request.send(message);
                }
            },
            Storage: {
                Get: function(key, callback) {
                    var storage = MS.Browser.storage.sync ? MS.Browser.storage.sync : MS.Browser.storage.local;
                    storage.get(key, function(data) {
                        var result = null;
                        if (data.hasOwnProperty(key)) {
                            result = data[key];
                        }
                        callback(result);
                    });
                },
                Save: function(key, data, callback) {
                    var storage = MS.Browser.storage.sync ? MS.Browser.storage.sync : MS.Browser.storage.local;
                    var obj = {};
                    obj[key] = data;
                    storage.set(obj, callback ? callback : null);
                }
            },
            Round: function(number, accuracy) {
                accuracy = accuracy || 0;
                return number.toFixed(accuracy);
            },
            Error: function(error) {
                console.error(error);
            },
            Log: function(mess) {
                if (!window.IsProduction) {
                    console.log(mess);
                }
            }
        },
        DB: window.MS.Db,
        Data: function() {
            return {
                Browser: null,
                CurrentDomain: function() {
                    if (window.location.search) {
                        var arr = window.location.search.substr(1).split("&");
                        for (var key in arr) {
                            var arr2 = arr[key].split("=");
                            if (arr2[0] === "domain") {
                                return arr2[1];
                            }
                        }
                    }
                    return null;
                }(),
                CurrentProtocol: function() {
                    if (window.location.search) {
                        var arr = window.location.search.substr(1).split("&");
                        for (var key in arr) {
                            var arr2 = arr[key].split("=");
                            if (arr2[0] === "protocol") {
                                return arr2[1];
                            }
                        }
                    }
                    return null;
                }(),
                CurrentTabInfo: {},
                FirstImageInPage: function() {
                    if (window.location.search) {
                        var arr = window.location.search.substr(1).split("&");
                        for (var key in arr) {
                            var arr2 = arr[key].split("=");
                            if (arr2[0] === "image") {
                                return arr2[1];
                            }
                        }
                    }
                    return null;
                }(),
                UserData: {}
            };
        }(),
        Initialize: function() {
            var locale = "en";
            if (MS.Browser.i18n.getUILanguage() === "ru") {
                locale = "ru";
            }
            if (window.i18n) {
                i18n.init({
                    lng: locale,
                    resStore: MS.Translate
                });
            }
            if (window.moment) {
                moment.locale(locale);
            }
            this.Helpers.GetUserData($.proxy(function(data) {
                this.Data.UserData = data;
            }, this));
            var ua = navigator.userAgent;
            if (ua.indexOf("Firefox/") > -1) {
                App.Data.Browser = "Firefox";
            } else if (ua.indexOf("OPR/") > -1) {
                App.Data.Browser = "Opera";
            } else if (ua.indexOf("YaBrowser") > -1) {
                App.Data.Browser = "Yandex";
            } else if (ua.indexOf("Amigo/") > -1) {
                App.Data.Browser = "Amigo";
            } else {
                App.Data.Browser = "Chrome";
            }
            window.StorageSync = MS.Browser.storage;
            window._A_h = this.Helpers;
        }
    };
    return App;
});

!function(a) {
    function b(a, b) {
        if (!b || "function" == typeof b) return a;
        for (var c in b) a[c] = b[c];
        return a;
    }
    function c(a, b) {
        for (var d in b) d in a ? c(a[d], b[d]) : a[d] = b[d];
        return a;
    }
    function d(a, b, c) {
        var d, e = 0, f = a.length, g = void 0 === f || "[object Array]" !== Object.prototype.toString.apply(a) || "function" == typeof a;
        if (c) if (g) {
            for (d in a) if (b.apply(a[d], c) === !1) break;
        } else for (;f > e && b.apply(a[e++], c) !== !1; ) ; else if (g) {
            for (d in a) if (b.call(a[d], d, a[d]) === !1) break;
        } else for (;f > e && b.call(a[e], e, a[e++]) !== !1; ) ;
        return a;
    }
    function e(a) {
        return "string" == typeof a ? a.replace(/[&<>"'\/]/g, function(a) {
            return Q[a];
        }) : a;
    }
    function f(a) {
        var b = function(a) {
            if (window.XMLHttpRequest) return a(null, new XMLHttpRequest());
            if (window.ActiveXObject) try {
                return a(null, new ActiveXObject("Msxml2.XMLHTTP"));
            } catch (b) {
                return a(null, new ActiveXObject("Microsoft.XMLHTTP"));
            }
            return a(new Error());
        }, c = function(a) {
            if ("string" == typeof a) return a;
            var b = [];
            for (var c in a) a.hasOwnProperty(c) && b.push(encodeURIComponent(c) + "=" + encodeURIComponent(a[c]));
            return b.join("&");
        }, d = function(a) {
            a = a.replace(/\r\n/g, "\n");
            for (var b = "", c = 0; c < a.length; c++) {
                var d = a.charCodeAt(c);
                128 > d ? b += String.fromCharCode(d) : d > 127 && 2048 > d ? (b += String.fromCharCode(d >> 6 | 192), 
                b += String.fromCharCode(63 & d | 128)) : (b += String.fromCharCode(d >> 12 | 224), 
                b += String.fromCharCode(d >> 6 & 63 | 128), b += String.fromCharCode(63 & d | 128));
            }
            return b;
        }, e = function(a) {
            var b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            a = d(a);
            var c, e, f, g, h, i, j, k = "", l = 0;
            do c = a.charCodeAt(l++), e = a.charCodeAt(l++), f = a.charCodeAt(l++), g = c >> 2, 
            h = (3 & c) << 4 | e >> 4, i = (15 & e) << 2 | f >> 6, j = 63 & f, isNaN(e) ? i = j = 64 : isNaN(f) && (j = 64), 
            k += b.charAt(g) + b.charAt(h) + b.charAt(i) + b.charAt(j), c = e = f = "", g = h = i = j = ""; while (l < a.length);
            return k;
        }, f = function() {
            for (var a = arguments[0], b = 1; b < arguments.length; b++) {
                var c = arguments[b];
                for (var d in c) c.hasOwnProperty(d) && (a[d] = c[d]);
            }
            return a;
        }, g = function(a, d, e, h) {
            "function" == typeof e && (h = e, e = {}), e.cache = e.cache || !1, e.data = e.data || {}, 
            e.headers = e.headers || {}, e.jsonp = e.jsonp || !1, e.async = void 0 === e.async ? !0 : e.async;
            var i, j = f({
                accept: "*/*",
                "content-type": "application/x-www-form-urlencoded;charset=UTF-8"
            }, g.headers, e.headers);
            if (i = "application/json" === j["content-type"] ? JSON.stringify(e.data) : c(e.data), 
            "GET" === a) {
                var k = [];
                if (i && (k.push(i), i = null), e.cache || k.push("_=" + new Date().getTime()), 
                e.jsonp && (k.push("callback=" + e.jsonp), k.push("jsonp=" + e.jsonp)), k = k.join("&"), 
                k.length > 1 && (d += d.indexOf("?") > -1 ? "&" + k : "?" + k), e.jsonp) {
                    var l = document.getElementsByTagName("head")[0], m = document.createElement("script");
                    return m.type = "text/javascript", m.src = d, void l.appendChild(m);
                }
            }
            b(function(b, c) {
                if (b) return h(b);
                c.open(a, d, e.async);
                for (var f in j) j.hasOwnProperty(f) && c.setRequestHeader(f, j[f]);
                c.onreadystatechange = function() {
                    if (4 === c.readyState) {
                        var a = c.responseText || "";
                        if (!h) return;
                        h(c.status, {
                            text: function() {
                                return a;
                            },
                            json: function() {
                                try {
                                    return JSON.parse(a);
                                } catch (b) {
                                    return T.error("Can not parse JSON. URL: " + d), {};
                                }
                            }
                        });
                    }
                }, c.send(i);
            });
        }, h = {
            authBasic: function(a, b) {
                g.headers.Authorization = "Basic " + e(a + ":" + b);
            },
            connect: function(a, b, c) {
                return g("CONNECT", a, b, c);
            },
            del: function(a, b, c) {
                return g("DELETE", a, b, c);
            },
            get: function(a, b, c) {
                return g("GET", a, b, c);
            },
            head: function(a, b, c) {
                return g("HEAD", a, b, c);
            },
            headers: function(a) {
                g.headers = a || {};
            },
            isAllowed: function(a, b, c) {
                this.options(a, function(a, d) {
                    c(-1 !== d.text().indexOf(b));
                });
            },
            options: function(a, b, c) {
                return g("OPTIONS", a, b, c);
            },
            patch: function(a, b, c) {
                return g("PATCH", a, b, c);
            },
            post: function(a, b, c) {
                return g("POST", a, b, c);
            },
            put: function(a, b, c) {
                return g("PUT", a, b, c);
            },
            trace: function(a, b, c) {
                return g("TRACE", a, b, c);
            }
        }, i = a.type ? a.type.toLowerCase() : "get";
        h[i](a.url, a, function(b, c) {
            200 === b || 0 === b && c.text() ? a.success(c.json(), b, null) : a.error(c.text(), b, null);
        });
    }
    function g(a, b) {
        "function" == typeof a && (b = a, a = {}), a = a || {}, T.extend(P, a), delete P.fixLng, 
        P.functions && (delete P.functions, T.extend(T, a.functions)), "string" == typeof P.ns && (P.ns = {
            namespaces: [ P.ns ],
            defaultNs: P.ns
        }), "string" == typeof P.fallbackNS && (P.fallbackNS = [ P.fallbackNS ]), ("string" == typeof P.fallbackLng || "boolean" == typeof P.fallbackLng) && (P.fallbackLng = [ P.fallbackLng ]), 
        P.interpolationPrefixEscaped = T.regexEscape(P.interpolationPrefix), P.interpolationSuffixEscaped = T.regexEscape(P.interpolationSuffix), 
        P.lng || (P.lng = T.detectLanguage()), M = T.toLanguages(P.lng), H = M[0], T.log("currentLng set to: " + H), 
        P.useCookie && T.cookie.read(P.cookieName) !== H && T.cookie.create(P.cookieName, H, P.cookieExpirationTime, P.cookieDomain), 
        P.detectLngFromLocalStorage && "undefined" != typeof document && window.localStorage && T.localStorage.setItem("i18next_lng", H);
        var c = B;
        a.fixLng && (c = function(a, b) {
            return b = b || {}, b.lng = b.lng || c.lng, B(a, b);
        }, c.lng = H), W.setCurrentLng(H), I && P.setJqueryExt && u();
        var d;
        if (I && I.Deferred && (d = I.Deferred()), !P.resStore) {
            var e = T.toLanguages(P.lng);
            "string" == typeof P.preload && (P.preload = [ P.preload ]);
            for (var f = 0, g = P.preload.length; g > f; f++) for (var h = T.toLanguages(P.preload[f]), i = 0, j = h.length; j > i; i++) e.indexOf(h[i]) < 0 && e.push(h[i]);
            return J.sync.load(e, P, function(a, e) {
                K = e, N = !0, b && b(c), d && d.resolve(c);
            }), d ? d.promise() : void 0;
        }
        return K = P.resStore, N = !0, b && b(c), d && d.resolve(c), d ? d.promise() : void 0;
    }
    function h(a, b) {
        "string" == typeof a && (a = [ a ]);
        for (var c = 0, d = a.length; d > c; c++) P.preload.indexOf(a[c]) < 0 && P.preload.push(a[c]);
        return g(b);
    }
    function i(a, b, c, d) {
        "string" != typeof b ? (c = b, b = P.ns.defaultNs) : P.ns.namespaces.indexOf(b) < 0 && P.ns.namespaces.push(b), 
        K[a] = K[a] || {}, K[a][b] = K[a][b] || {}, d ? T.deepExtend(K[a][b], c) : T.extend(K[a][b], c), 
        P.useLocalStorage && O._storeLocal(K);
    }
    function j(a, b) {
        "string" != typeof b && (b = P.ns.defaultNs), K[a] = K[a] || {};
        var c = K[a][b] || {}, d = !1;
        for (var e in c) c.hasOwnProperty(e) && (d = !0);
        return d;
    }
    function k(a, b) {
        return "string" != typeof b && (b = P.ns.defaultNs), K[a] = K[a] || {}, T.extend({}, K[a][b]);
    }
    function l(a, b) {
        "string" != typeof b && (b = P.ns.defaultNs), K[a] = K[a] || {}, K[a][b] = {}, P.useLocalStorage && O._storeLocal(K);
    }
    function m(a, b, c, d) {
        "string" != typeof b ? (resource = b, b = P.ns.defaultNs) : P.ns.namespaces.indexOf(b) < 0 && P.ns.namespaces.push(b), 
        K[a] = K[a] || {}, K[a][b] = K[a][b] || {};
        for (var e = c.split(P.keyseparator), f = 0, g = K[a][b]; e[f]; ) f == e.length - 1 ? g[e[f]] = d : (null == g[e[f]] && (g[e[f]] = {}), 
        g = g[e[f]]), f++;
        P.useLocalStorage && O._storeLocal(K);
    }
    function n(a, b, c) {
        "string" != typeof b ? (resource = b, b = P.ns.defaultNs) : P.ns.namespaces.indexOf(b) < 0 && P.ns.namespaces.push(b);
        for (var d in c) "string" == typeof c[d] && m(a, b, d, c[d]);
    }
    function o(a) {
        P.ns.defaultNs = a;
    }
    function p(a, b) {
        q([ a ], b);
    }
    function q(a, b) {
        var c = {
            dynamicLoad: P.dynamicLoad,
            resGetPath: P.resGetPath,
            getAsync: P.getAsync,
            customLoad: P.customLoad,
            ns: {
                namespaces: a,
                defaultNs: ""
            }
        }, d = T.toLanguages(P.lng);
        "string" == typeof P.preload && (P.preload = [ P.preload ]);
        for (var e = 0, f = P.preload.length; f > e; e++) for (var g = T.toLanguages(P.preload[e]), h = 0, i = g.length; i > h; h++) d.indexOf(g[h]) < 0 && d.push(g[h]);
        for (var j = [], k = 0, l = d.length; l > k; k++) {
            var m = !1, n = K[d[k]];
            if (n) for (var o = 0, p = a.length; p > o; o++) n[a[o]] || (m = !0); else m = !0;
            m && j.push(d[k]);
        }
        j.length ? J.sync._fetch(j, c, function(c, d) {
            var e = a.length * j.length;
            T.each(a, function(a, c) {
                P.ns.namespaces.indexOf(c) < 0 && P.ns.namespaces.push(c), T.each(j, function(a, f) {
                    K[f] = K[f] || {}, K[f][c] = d[f][c], e--, 0 === e && b && (P.useLocalStorage && J.sync._storeLocal(K), 
                    b());
                });
            });
        }) : b && b();
    }
    function r(a, b, c) {
        return "function" == typeof b ? (c = b, b = {}) : b || (b = {}), b.lng = a, g(b, c);
    }
    function s() {
        return H;
    }
    function t(a) {
        K = {}, r(H, a);
    }
    function u() {
        function a(a, b, c) {
            if (0 !== b.length) {
                var d = "text";
                if (0 === b.indexOf("[")) {
                    var e = b.split("]");
                    b = e[1], d = e[0].substr(1, e[0].length - 1);
                }
                b.indexOf(";") === b.length - 1 && (b = b.substr(0, b.length - 2));
                var f;
                if ("html" === d) f = P.defaultValueFromContent ? I.extend({
                    defaultValue: a.html()
                }, c) : c, a.html(I.t(b, f)); else if ("text" === d) f = P.defaultValueFromContent ? I.extend({
                    defaultValue: a.text()
                }, c) : c, a.text(I.t(b, f)); else if ("prepend" === d) f = P.defaultValueFromContent ? I.extend({
                    defaultValue: a.html()
                }, c) : c, a.prepend(I.t(b, f)); else if ("append" === d) f = P.defaultValueFromContent ? I.extend({
                    defaultValue: a.html()
                }, c) : c, a.append(I.t(b, f)); else if (0 === d.indexOf("data-")) {
                    var g = d.substr("data-".length);
                    f = P.defaultValueFromContent ? I.extend({
                        defaultValue: a.data(g)
                    }, c) : c;
                    var h = I.t(b, f);
                    a.data(g, h), a.attr(d, h);
                } else f = P.defaultValueFromContent ? I.extend({
                    defaultValue: a.attr(d)
                }, c) : c, a.attr(d, I.t(b, f));
            }
        }
        function b(b, c) {
            var d = b.attr(P.selectorAttr);
            if (d || "undefined" == typeof d || d === !1 || (d = b.text() || b.val()), d) {
                var e = b, f = b.data("i18n-target");
                if (f && (e = b.find(f) || b), c || P.useDataAttrOptions !== !0 || (c = b.data("i18n-options")), 
                c = c || {}, d.indexOf(";") >= 0) {
                    var g = d.split(";");
                    I.each(g, function(b, d) {
                        "" !== d && a(e, d, c);
                    });
                } else a(e, d, c);
                P.useDataAttrOptions === !0 && b.data("i18n-options", c);
            }
        }
        I.t = I.t || B, I.fn.i18n = function(a) {
            return this.each(function() {
                b(I(this), a);
                var c = I(this).find("[" + P.selectorAttr + "]");
                c.each(function() {
                    b(I(this), a);
                });
            });
        };
    }
    function v(a, b, c, d) {
        if (!a) return a;
        if (d = d || b, a.indexOf(d.interpolationPrefix || P.interpolationPrefix) < 0) return a;
        var e = d.interpolationPrefix ? T.regexEscape(d.interpolationPrefix) : P.interpolationPrefixEscaped, f = d.interpolationSuffix ? T.regexEscape(d.interpolationSuffix) : P.interpolationSuffixEscaped, g = "HTML" + f, h = b.replace && "object" == typeof b.replace ? b.replace : b;
        return T.each(h, function(b, h) {
            var i = c ? c + P.keyseparator + b : b;
            "object" == typeof h && null !== h ? a = v(a, h, i, d) : d.escapeInterpolation || P.escapeInterpolation ? (a = a.replace(new RegExp([ e, i, g ].join(""), "g"), T.regexReplacementEscape(h)), 
            a = a.replace(new RegExp([ e, i, f ].join(""), "g"), T.regexReplacementEscape(T.escape(h)))) : a = a.replace(new RegExp([ e, i, f ].join(""), "g"), T.regexReplacementEscape(h));
        }), a;
    }
    function w(a, b) {
        var c = ",", d = "{", e = "}", f = T.extend({}, b);
        for (delete f.postProcess; -1 != a.indexOf(P.reusePrefix) && (L++, !(L > P.maxRecursion)); ) {
            var g = a.lastIndexOf(P.reusePrefix), h = a.indexOf(P.reuseSuffix, g) + P.reuseSuffix.length, i = a.substring(g, h), j = i.replace(P.reusePrefix, "").replace(P.reuseSuffix, "");
            if (g >= h) return T.error("there is an missing closing in following translation value", a), 
            "";
            if (-1 != j.indexOf(c)) {
                var k = j.indexOf(c);
                if (-1 != j.indexOf(d, k) && -1 != j.indexOf(e, k)) {
                    var l = j.indexOf(d, k), m = j.indexOf(e, l) + e.length;
                    try {
                        f = T.extend(f, JSON.parse(j.substring(l, m))), j = j.substring(0, k);
                    } catch (n) {}
                }
            }
            var o = E(j, f);
            a = a.replace(i, T.regexReplacementEscape(o));
        }
        return a;
    }
    function x(a) {
        return a.context && ("string" == typeof a.context || "number" == typeof a.context);
    }
    function y(a) {
        return void 0 !== a.count && "string" != typeof a.count;
    }
    function z(a) {
        return void 0 !== a.indefinite_article && "string" != typeof a.indefinite_article && a.indefinite_article;
    }
    function A(a, b) {
        b = b || {};
        var c = C(a, b), d = F(a, b);
        return void 0 !== d || d === c;
    }
    function B(a, b) {
        return b = b || {}, N ? (L = 0, E.apply(null, arguments)) : (T.log("i18next not finished initialization. you might have called t function before loading resources finished."), 
        b.defaultValue || "");
    }
    function C(a, b) {
        return void 0 !== b.defaultValue ? b.defaultValue : a;
    }
    function D() {
        for (var a = [], b = 1; b < arguments.length; b++) a.push(arguments[b]);
        return {
            postProcess: "sprintf",
            sprintf: a
        };
    }
    function E(a, b) {
        if (b && "object" != typeof b ? "sprintf" === P.shortcutFunction ? b = D.apply(null, arguments) : "defaultValue" === P.shortcutFunction && (b = {
            defaultValue: b
        }) : b = b || {}, "object" == typeof P.defaultVariables && (b = T.extend({}, P.defaultVariables, b)), 
        void 0 === a || null === a || "" === a) return "";
        "number" == typeof a && (a = String(a)), "string" == typeof a && (a = [ a ]);
        var c = a[0];
        if (a.length > 1) for (var d = 0; d < a.length && (c = a[d], !A(c, b)); d++) ;
        var e, f = C(c, b), g = F(c, b), h = b.lng ? T.toLanguages(b.lng, b.fallbackLng) : M, i = b.ns || P.ns.defaultNs;
        c.indexOf(P.nsseparator) > -1 && (e = c.split(P.nsseparator), i = e[0], c = e[1]), 
        void 0 === g && P.sendMissing && "function" == typeof P.missingKeyHandler && (b.lng ? P.missingKeyHandler(h[0], i, c, f, h) : P.missingKeyHandler(P.lng, i, c, f, h));
        var j;
        j = "string" == typeof P.postProcess && "" !== P.postProcess ? [ P.postProcess ] : "array" == typeof P.postProcess || "object" == typeof P.postProcess ? P.postProcess : [], 
        "string" == typeof b.postProcess && "" !== b.postProcess ? j = j.concat([ b.postProcess ]) : ("array" == typeof b.postProcess || "object" == typeof b.postProcess) && (j = j.concat(b.postProcess)), 
        void 0 !== g && j.length && j.forEach(function(a) {
            X[a] && (g = X[a](g, c, b));
        });
        var k = f;
        if (f.indexOf(P.nsseparator) > -1 && (e = f.split(P.nsseparator), k = e[1]), k === c && P.parseMissingKey && (f = P.parseMissingKey(f)), 
        void 0 === g && (f = v(f, b), f = w(f, b), j.length)) {
            var l = C(c, b);
            j.forEach(function(a) {
                X[a] && (g = X[a](l, c, b));
            });
        }
        return void 0 !== g ? g : f;
    }
    function F(a, b) {
        b = b || {};
        var c, d, e = C(a, b), f = M;
        if (!K) return e;
        if ("cimode" === f[0].toLowerCase()) return e;
        if (b.lngs && (f = b.lngs), b.lng && (f = T.toLanguages(b.lng, b.fallbackLng), !K[f[0]])) {
            var g = P.getAsync;
            P.getAsync = !1, J.sync.load(f, P, function(a, b) {
                T.extend(K, b), P.getAsync = g;
            });
        }
        var h = b.ns || P.ns.defaultNs;
        if (a.indexOf(P.nsseparator) > -1) {
            var i = a.split(P.nsseparator);
            h = i[0], a = i[1];
        }
        if (x(b)) {
            c = T.extend({}, b), delete c.context, c.defaultValue = P.contextNotFound;
            var j = h + P.nsseparator + a + "_" + b.context;
            if (d = B(j, c), d != P.contextNotFound) return v(d, {
                context: b.context
            });
        }
        if (y(b, f[0])) {
            c = T.extend({
                lngs: [ f[0] ]
            }, b), delete c.count, c._origLng = c._origLng || c.lng || f[0], delete c.lng, c.defaultValue = P.pluralNotFound;
            var k;
            if (W.needsPlural(f[0], b.count)) {
                k = h + P.nsseparator + a + P.pluralSuffix;
                var l = W.get(f[0], b.count);
                l >= 0 ? k = k + "_" + l : 1 === l && (k = h + P.nsseparator + a);
            } else k = h + P.nsseparator + a;
            if (d = B(k, c), d != P.pluralNotFound) return v(d, {
                count: b.count,
                interpolationPrefix: b.interpolationPrefix,
                interpolationSuffix: b.interpolationSuffix
            });
            if (!(f.length > 1)) return c.lng = c._origLng, delete c._origLng, d = B(h + P.nsseparator + a, c), 
            v(d, {
                count: b.count,
                interpolationPrefix: b.interpolationPrefix,
                interpolationSuffix: b.interpolationSuffix
            });
            var m = f.slice();
            if (m.shift(), b = T.extend(b, {
                lngs: m
            }), b._origLng = c._origLng, delete b.lng, d = B(h + P.nsseparator + a, b), d != P.pluralNotFound) return d;
        }
        if (z(b)) {
            var n = T.extend({}, b);
            delete n.indefinite_article, n.defaultValue = P.indefiniteNotFound;
            var o = h + P.nsseparator + a + (b.count && !y(b, f[0]) || !b.count ? P.indefiniteSuffix : "");
            if (d = B(o, n), d != P.indefiniteNotFound) return d;
        }
        for (var p, q = a.split(P.keyseparator), r = 0, s = f.length; s > r && void 0 === p; r++) {
            for (var t = f[r], u = 0, A = K[t] && K[t][h]; q[u]; ) A = A && A[q[u]], u++;
            if (void 0 !== A) {
                var D = Object.prototype.toString.apply(A);
                if ("string" == typeof A) A = v(A, b), A = w(A, b); else if ("[object Array]" !== D || P.returnObjectTrees || b.returnObjectTrees) {
                    if (null === A && P.fallbackOnNull === !0) A = void 0; else if (null !== A) if (P.returnObjectTrees || b.returnObjectTrees) {
                        if ("[object Number]" !== D && "[object Function]" !== D && "[object RegExp]" !== D) {
                            var G = "[object Array]" === D ? [] : {};
                            T.each(A, function(c) {
                                G[c] = E(h + P.nsseparator + a + P.keyseparator + c, b);
                            }), A = G;
                        }
                    } else P.objectTreeKeyHandler && "function" == typeof P.objectTreeKeyHandler ? A = P.objectTreeKeyHandler(a, A, t, h, b) : (A = "key '" + h + ":" + a + " (" + t + ")' returned an object instead of string.", 
                    T.log(A));
                } else A = A.join("\n"), A = v(A, b), A = w(A, b);
                "string" == typeof A && "" === A.trim() && P.fallbackOnEmpty === !0 && (A = void 0), 
                p = A;
            }
        }
        if (void 0 === p && !b.isFallbackLookup && (P.fallbackToDefaultNS === !0 || P.fallbackNS && P.fallbackNS.length > 0)) {
            if (b.isFallbackLookup = !0, P.fallbackNS.length) {
                for (var H = 0, I = P.fallbackNS.length; I > H; H++) if (p = F(P.fallbackNS[H] + P.nsseparator + a, b), 
                p || "" === p && P.fallbackOnEmpty === !1) {
                    var L = p.indexOf(P.nsseparator) > -1 ? p.split(P.nsseparator)[1] : p, N = e.indexOf(P.nsseparator) > -1 ? e.split(P.nsseparator)[1] : e;
                    if (L !== N) break;
                }
            } else p = F(a, b);
            b.isFallbackLookup = !1;
        }
        return p;
    }
    function G() {
        var a, b = P.lngWhitelist || [], c = [];
        if ("undefined" != typeof window && !function() {
            for (var a = window.location.search.substring(1), b = a.split("&"), d = 0; d < b.length; d++) {
                var e = b[d].indexOf("=");
                if (e > 0) {
                    var f = b[d].substring(0, e);
                    f == P.detectLngQS && c.push(b[d].substring(e + 1));
                }
            }
        }(), P.useCookie && "undefined" != typeof document) {
            var d = T.cookie.read(P.cookieName);
            d && c.push(d);
        }
        if (P.detectLngFromLocalStorage && "undefined" != typeof window && window.localStorage && c.push(T.localStorage.getItem("i18next_lng")), 
        "undefined" != typeof navigator) {
            if (navigator.languages) for (var e = 0; e < navigator.languages.length; e++) c.push(navigator.languages[e]);
            navigator.userLanguage && c.push(navigator.userLanguage), navigator.language && c.push(navigator.language);
        }
        return function() {
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                if (e.indexOf("-") > -1) {
                    var f = e.split("-");
                    e = P.lowerCaseLng ? f[0].toLowerCase() + "-" + f[1].toLowerCase() : f[0].toLowerCase() + "-" + f[1].toUpperCase();
                }
                if (0 === b.length || b.indexOf(e) > -1) {
                    a = e;
                    break;
                }
            }
        }(), a || (a = P.fallbackLng[0]), a;
    }
    Array.prototype.indexOf || (Array.prototype.indexOf = function(a) {
        "use strict";
        if (null == this) throw new TypeError();
        var b = Object(this), c = b.length >>> 0;
        if (0 === c) return -1;
        var d = 0;
        if (arguments.length > 0 && (d = Number(arguments[1]), d != d ? d = 0 : 0 != d && d != 1 / 0 && d != -(1 / 0) && (d = (d > 0 || -1) * Math.floor(Math.abs(d)))), 
        d >= c) return -1;
        for (var e = d >= 0 ? d : Math.max(c - Math.abs(d), 0); c > e; e++) if (e in b && b[e] === a) return e;
        return -1;
    }), Array.prototype.lastIndexOf || (Array.prototype.lastIndexOf = function(a) {
        "use strict";
        if (null == this) throw new TypeError();
        var b = Object(this), c = b.length >>> 0;
        if (0 === c) return -1;
        var d = c;
        arguments.length > 1 && (d = Number(arguments[1]), d != d ? d = 0 : 0 != d && d != 1 / 0 && d != -(1 / 0) && (d = (d > 0 || -1) * Math.floor(Math.abs(d))));
        for (var e = d >= 0 ? Math.min(d, c - 1) : c - Math.abs(d); e >= 0; e--) if (e in b && b[e] === a) return e;
        return -1;
    }), "function" != typeof String.prototype.trim && (String.prototype.trim = function() {
        return this.replace(/^\s+|\s+$/g, "");
    });
    var H, I = a.jQuery || a.Zepto, J = {}, K = {}, L = 0, M = [], N = !1, O = {};
    "undefined" != typeof module && module.exports ? module.exports = J : (I && (I.i18n = I.i18n || J), 
    a.i18n = a.i18n || J), O = {
        load: function(a, b, c) {
            b.useLocalStorage ? O._loadLocal(a, b, function(d, e) {
                for (var f = [], g = 0, h = a.length; h > g; g++) e[a[g]] || f.push(a[g]);
                f.length > 0 ? O._fetch(f, b, function(a, b) {
                    T.extend(e, b), O._storeLocal(b), c(null, e);
                }) : c(null, e);
            }) : O._fetch(a, b, function(a, b) {
                c(null, b);
            });
        },
        _loadLocal: function(a, b, c) {
            var d = {}, e = new Date().getTime();
            if (window.localStorage) {
                var f = a.length;
                T.each(a, function(a, g) {
                    var h = T.localStorage.getItem("res_" + g);
                    h && (h = JSON.parse(h), h.i18nStamp && h.i18nStamp + b.localStorageExpirationTime > e && (d[g] = h)), 
                    f--, 0 === f && c(null, d);
                });
            }
        },
        _storeLocal: function(a) {
            if (window.localStorage) for (var b in a) a[b].i18nStamp = new Date().getTime(), 
            T.localStorage.setItem("res_" + b, JSON.stringify(a[b]));
        },
        _fetch: function(a, b, c) {
            var d = b.ns, e = {};
            if (b.dynamicLoad) {
                var f = function(a, b) {
                    c(null, b);
                };
                if ("function" == typeof b.customLoad) b.customLoad(a, d.namespaces, b, f); else {
                    var g = v(b.resGetPath, {
                        lng: a.join("+"),
                        ns: d.namespaces.join("+")
                    });
                    T.ajax({
                        url: g,
                        success: function(a) {
                            T.log("loaded: " + g), f(null, a);
                        },
                        error: function(a, b, c) {
                            T.log("failed loading: " + g), f("failed loading resource.json error: " + c);
                        },
                        dataType: "json",
                        async: b.getAsync
                    });
                }
            } else {
                var h, i = d.namespaces.length * a.length;
                T.each(d.namespaces, function(d, f) {
                    T.each(a, function(a, d) {
                        var g = function(a, b) {
                            a && (h = h || [], h.push(a)), e[d] = e[d] || {}, e[d][f] = b, i--, 0 === i && c(h, e);
                        };
                        "function" == typeof b.customLoad ? b.customLoad(d, f, b, g) : O._fetchOne(d, f, b, g);
                    });
                });
            }
        },
        _fetchOne: function(a, b, c, d) {
            var e = v(c.resGetPath, {
                lng: a,
                ns: b
            });
            T.ajax({
                url: e,
                success: function(a) {
                    T.log("loaded: " + e), d(null, a);
                },
                error: function(a, b, c) {
                    if (b && 200 == b || a && a.status && 200 == a.status) T.error("There is a typo in: " + e); else if (b && 404 == b || a && a.status && 404 == a.status) T.log("Does not exist: " + e); else {
                        var f = b ? b : a && a.status ? a.status : null;
                        T.log(f + " when loading " + e);
                    }
                    d(c, {});
                },
                dataType: "json",
                async: c.getAsync
            });
        },
        postMissing: function(a, b, c, d, e) {
            var f = {};
            f[c] = d;
            var g = [];
            if ("fallback" === P.sendMissingTo && P.fallbackLng[0] !== !1) for (var h = 0; h < P.fallbackLng.length; h++) g.push({
                lng: P.fallbackLng[h],
                url: v(P.resPostPath, {
                    lng: P.fallbackLng[h],
                    ns: b
                })
            }); else if ("current" === P.sendMissingTo || "fallback" === P.sendMissingTo && P.fallbackLng[0] === !1) g.push({
                lng: a,
                url: v(P.resPostPath, {
                    lng: a,
                    ns: b
                })
            }); else if ("all" === P.sendMissingTo) for (var h = 0, i = e.length; i > h; h++) g.push({
                lng: e[h],
                url: v(P.resPostPath, {
                    lng: e[h],
                    ns: b
                })
            });
            for (var j = 0, k = g.length; k > j; j++) {
                var l = g[j];
                T.ajax({
                    url: l.url,
                    type: P.sendType,
                    data: f,
                    success: function() {
                        T.log("posted missing key '" + c + "' to: " + l.url);
                        for (var a = c.split("."), e = 0, f = K[l.lng][b]; a[e]; ) f = f[a[e]] = e === a.length - 1 ? d : f[a[e]] || {}, 
                        e++;
                    },
                    error: function() {
                        T.log("failed posting missing key '" + c + "' to: " + l.url);
                    },
                    dataType: "json",
                    async: P.postAsync
                });
            }
        },
        reload: t
    };
    var P = {
        lng: void 0,
        load: "all",
        preload: [],
        lowerCaseLng: !1,
        returnObjectTrees: !1,
        fallbackLng: [ "dev" ],
        fallbackNS: [],
        detectLngQS: "setLng",
        detectLngFromLocalStorage: !1,
        ns: "translation",
        fallbackOnNull: !0,
        fallbackOnEmpty: !1,
        fallbackToDefaultNS: !1,
        nsseparator: ":",
        keyseparator: ".",
        selectorAttr: "data-i18n",
        debug: !1,
        resGetPath: "locales/__lng__/__ns__.json",
        resPostPath: "locales/add/__lng__/__ns__",
        getAsync: !0,
        postAsync: !0,
        resStore: void 0,
        useLocalStorage: !1,
        localStorageExpirationTime: 6048e5,
        dynamicLoad: !1,
        sendMissing: !1,
        sendMissingTo: "fallback",
        sendType: "POST",
        interpolationPrefix: "__",
        interpolationSuffix: "__",
        defaultVariables: !1,
        reusePrefix: "$t(",
        reuseSuffix: ")",
        pluralSuffix: "_plural",
        pluralNotFound: [ "plural_not_found", Math.random() ].join(""),
        contextNotFound: [ "context_not_found", Math.random() ].join(""),
        escapeInterpolation: !1,
        indefiniteSuffix: "_indefinite",
        indefiniteNotFound: [ "indefinite_not_found", Math.random() ].join(""),
        setJqueryExt: !0,
        defaultValueFromContent: !0,
        useDataAttrOptions: !1,
        cookieExpirationTime: void 0,
        useCookie: !0,
        cookieName: "i18next",
        cookieDomain: void 0,
        objectTreeKeyHandler: void 0,
        postProcess: void 0,
        parseMissingKey: void 0,
        missingKeyHandler: O.postMissing,
        shortcutFunction: "sprintf"
    }, Q = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;"
    }, R = {
        create: function(a, b, c, d) {
            var e;
            if (c) {
                var f = new Date();
                f.setTime(f.getTime() + 60 * c * 1e3), e = "; expires=" + f.toGMTString();
            } else e = "";
            d = d ? "domain=" + d + ";" : "", document.cookie = a + "=" + b + e + ";" + d + "path=/";
        },
        read: function(a) {
            for (var b = a + "=", c = document.cookie.split(";"), d = 0; d < c.length; d++) {
                for (var e = c[d]; " " == e.charAt(0); ) e = e.substring(1, e.length);
                if (0 === e.indexOf(b)) return e.substring(b.length, e.length);
            }
            return null;
        },
        remove: function(a) {
            this.create(a, "", -1);
        }
    }, S = {
        create: function() {},
        read: function() {
            return null;
        },
        remove: function() {}
    }, T = {
        extend: I ? I.extend : b,
        deepExtend: c,
        each: I ? I.each : d,
        ajax: I ? I.ajax : "undefined" != typeof document ? f : function() {},
        cookie: "undefined" != typeof document ? R : S,
        detectLanguage: G,
        escape: e,
        log: function(a) {
            P.debug && "undefined" != typeof console && console.log(a);
        },
        error: function(a) {
            "undefined" != typeof console && console.error(a);
        },
        getCountyIndexOfLng: function(a) {
            var b = 0;
            return ("nb-NO" === a || "nn-NO" === a || "nb-no" === a || "nn-no" === a) && (b = 1), 
            b;
        },
        toLanguages: function(a) {
            function b(a) {
                var b = a;
                if ("string" == typeof a && a.indexOf("-") > -1) {
                    var c = a.split("-");
                    b = P.lowerCaseLng ? c[0].toLowerCase() + "-" + c[1].toLowerCase() : c[0].toLowerCase() + "-" + c[1].toUpperCase();
                } else b = P.lowerCaseLng ? a.toLowerCase() : a;
                return b;
            }
            var c = this.log, d = [], e = P.lngWhitelist || !1, f = function(a) {
                !e || e.indexOf(a) > -1 ? d.push(a) : c("rejecting non-whitelisted language: " + a);
            };
            if ("string" == typeof a && a.indexOf("-") > -1) {
                var g = a.split("-");
                "unspecific" !== P.load && f(b(a)), "current" !== P.load && f(b(g[this.getCountyIndexOfLng(a)]));
            } else f(b(a));
            for (var h = 0; h < P.fallbackLng.length; h++) -1 === d.indexOf(P.fallbackLng[h]) && P.fallbackLng[h] && d.push(b(P.fallbackLng[h]));
            return d;
        },
        regexEscape: function(a) {
            return a.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        },
        regexReplacementEscape: function(a) {
            return "string" == typeof a ? a.replace(/\$/g, "$$$$") : a;
        },
        localStorage: {
            setItem: function(a, b) {
                if (window.localStorage) try {
                    window.localStorage.setItem(a, b);
                } catch (c) {
                    T.log('failed to set value for key "' + a + '" to localStorage.');
                }
            },
            getItem: function(a, b) {
                if (window.localStorage) try {
                    return window.localStorage.getItem(a, b);
                } catch (c) {
                    return void T.log('failed to get value for key "' + a + '" from localStorage.');
                }
            }
        }
    };
    T.applyReplacement = v;
    var U = [ [ "ach", "Acholi", [ 1, 2 ], 1 ], [ "af", "Afrikaans", [ 1, 2 ], 2 ], [ "ak", "Akan", [ 1, 2 ], 1 ], [ "am", "Amharic", [ 1, 2 ], 1 ], [ "an", "Aragonese", [ 1, 2 ], 2 ], [ "ar", "Arabic", [ 0, 1, 2, 3, 11, 100 ], 5 ], [ "arn", "Mapudungun", [ 1, 2 ], 1 ], [ "ast", "Asturian", [ 1, 2 ], 2 ], [ "ay", "Aymar谩", [ 1 ], 3 ], [ "az", "Azerbaijani", [ 1, 2 ], 2 ], [ "be", "Belarusian", [ 1, 2, 5 ], 4 ], [ "bg", "Bulgarian", [ 1, 2 ], 2 ], [ "bn", "Bengali", [ 1, 2 ], 2 ], [ "bo", "Tibetan", [ 1 ], 3 ], [ "br", "Breton", [ 1, 2 ], 1 ], [ "bs", "Bosnian", [ 1, 2, 5 ], 4 ], [ "ca", "Catalan", [ 1, 2 ], 2 ], [ "cgg", "Chiga", [ 1 ], 3 ], [ "cs", "Czech", [ 1, 2, 5 ], 6 ], [ "csb", "Kashubian", [ 1, 2, 5 ], 7 ], [ "cy", "Welsh", [ 1, 2, 3, 8 ], 8 ], [ "da", "Danish", [ 1, 2 ], 2 ], [ "de", "German", [ 1, 2 ], 2 ], [ "dev", "Development Fallback", [ 1, 2 ], 2 ], [ "dz", "Dzongkha", [ 1 ], 3 ], [ "el", "Greek", [ 1, 2 ], 2 ], [ "en", "English", [ 1, 2 ], 2 ], [ "eo", "Esperanto", [ 1, 2 ], 2 ], [ "es", "Spanish", [ 1, 2 ], 2 ], [ "es_ar", "Argentinean Spanish", [ 1, 2 ], 2 ], [ "et", "Estonian", [ 1, 2 ], 2 ], [ "eu", "Basque", [ 1, 2 ], 2 ], [ "fa", "Persian", [ 1 ], 3 ], [ "fi", "Finnish", [ 1, 2 ], 2 ], [ "fil", "Filipino", [ 1, 2 ], 1 ], [ "fo", "Faroese", [ 1, 2 ], 2 ], [ "fr", "French", [ 1, 2 ], 9 ], [ "fur", "Friulian", [ 1, 2 ], 2 ], [ "fy", "Frisian", [ 1, 2 ], 2 ], [ "ga", "Irish", [ 1, 2, 3, 7, 11 ], 10 ], [ "gd", "Scottish Gaelic", [ 1, 2, 3, 20 ], 11 ], [ "gl", "Galician", [ 1, 2 ], 2 ], [ "gu", "Gujarati", [ 1, 2 ], 2 ], [ "gun", "Gun", [ 1, 2 ], 1 ], [ "ha", "Hausa", [ 1, 2 ], 2 ], [ "he", "Hebrew", [ 1, 2 ], 2 ], [ "hi", "Hindi", [ 1, 2 ], 2 ], [ "hr", "Croatian", [ 1, 2, 5 ], 4 ], [ "hu", "Hungarian", [ 1, 2 ], 2 ], [ "hy", "Armenian", [ 1, 2 ], 2 ], [ "ia", "Interlingua", [ 1, 2 ], 2 ], [ "id", "Indonesian", [ 1 ], 3 ], [ "is", "Icelandic", [ 1, 2 ], 12 ], [ "it", "Italian", [ 1, 2 ], 2 ], [ "ja", "Japanese", [ 1 ], 3 ], [ "jbo", "Lojban", [ 1 ], 3 ], [ "jv", "Javanese", [ 0, 1 ], 13 ], [ "ka", "Georgian", [ 1 ], 3 ], [ "kk", "Kazakh", [ 1 ], 3 ], [ "km", "Khmer", [ 1 ], 3 ], [ "kn", "Kannada", [ 1, 2 ], 2 ], [ "ko", "Korean", [ 1 ], 3 ], [ "ku", "Kurdish", [ 1, 2 ], 2 ], [ "kw", "Cornish", [ 1, 2, 3, 4 ], 14 ], [ "ky", "Kyrgyz", [ 1 ], 3 ], [ "lb", "Letzeburgesch", [ 1, 2 ], 2 ], [ "ln", "Lingala", [ 1, 2 ], 1 ], [ "lo", "Lao", [ 1 ], 3 ], [ "lt", "Lithuanian", [ 1, 2, 10 ], 15 ], [ "lv", "Latvian", [ 1, 2, 0 ], 16 ], [ "mai", "Maithili", [ 1, 2 ], 2 ], [ "mfe", "Mauritian Creole", [ 1, 2 ], 1 ], [ "mg", "Malagasy", [ 1, 2 ], 1 ], [ "mi", "Maori", [ 1, 2 ], 1 ], [ "mk", "Macedonian", [ 1, 2 ], 17 ], [ "ml", "Malayalam", [ 1, 2 ], 2 ], [ "mn", "Mongolian", [ 1, 2 ], 2 ], [ "mnk", "Mandinka", [ 0, 1, 2 ], 18 ], [ "mr", "Marathi", [ 1, 2 ], 2 ], [ "ms", "Malay", [ 1 ], 3 ], [ "mt", "Maltese", [ 1, 2, 11, 20 ], 19 ], [ "nah", "Nahuatl", [ 1, 2 ], 2 ], [ "nap", "Neapolitan", [ 1, 2 ], 2 ], [ "nb", "Norwegian Bokmal", [ 1, 2 ], 2 ], [ "ne", "Nepali", [ 1, 2 ], 2 ], [ "nl", "Dutch", [ 1, 2 ], 2 ], [ "nn", "Norwegian Nynorsk", [ 1, 2 ], 2 ], [ "no", "Norwegian", [ 1, 2 ], 2 ], [ "nso", "Northern Sotho", [ 1, 2 ], 2 ], [ "oc", "Occitan", [ 1, 2 ], 1 ], [ "or", "Oriya", [ 2, 1 ], 2 ], [ "pa", "Punjabi", [ 1, 2 ], 2 ], [ "pap", "Papiamento", [ 1, 2 ], 2 ], [ "pl", "Polish", [ 1, 2, 5 ], 7 ], [ "pms", "Piemontese", [ 1, 2 ], 2 ], [ "ps", "Pashto", [ 1, 2 ], 2 ], [ "pt", "Portuguese", [ 1, 2 ], 2 ], [ "pt_br", "Brazilian Portuguese", [ 1, 2 ], 2 ], [ "rm", "Romansh", [ 1, 2 ], 2 ], [ "ro", "Romanian", [ 1, 2, 20 ], 20 ], [ "ru", "Russian", [ 1, 2, 5 ], 4 ], [ "sah", "Yakut", [ 1 ], 3 ], [ "sco", "Scots", [ 1, 2 ], 2 ], [ "se", "Northern Sami", [ 1, 2 ], 2 ], [ "si", "Sinhala", [ 1, 2 ], 2 ], [ "sk", "Slovak", [ 1, 2, 5 ], 6 ], [ "sl", "Slovenian", [ 5, 1, 2, 3 ], 21 ], [ "so", "Somali", [ 1, 2 ], 2 ], [ "son", "Songhay", [ 1, 2 ], 2 ], [ "sq", "Albanian", [ 1, 2 ], 2 ], [ "sr", "Serbian", [ 1, 2, 5 ], 4 ], [ "su", "Sundanese", [ 1 ], 3 ], [ "sv", "Swedish", [ 1, 2 ], 2 ], [ "sw", "Swahili", [ 1, 2 ], 2 ], [ "ta", "Tamil", [ 1, 2 ], 2 ], [ "te", "Telugu", [ 1, 2 ], 2 ], [ "tg", "Tajik", [ 1, 2 ], 1 ], [ "th", "Thai", [ 1 ], 3 ], [ "ti", "Tigrinya", [ 1, 2 ], 1 ], [ "tk", "Turkmen", [ 1, 2 ], 2 ], [ "tr", "Turkish", [ 1, 2 ], 1 ], [ "tt", "Tatar", [ 1 ], 3 ], [ "ug", "Uyghur", [ 1 ], 3 ], [ "uk", "Ukrainian", [ 1, 2, 5 ], 4 ], [ "ur", "Urdu", [ 1, 2 ], 2 ], [ "uz", "Uzbek", [ 1, 2 ], 1 ], [ "vi", "Vietnamese", [ 1 ], 3 ], [ "wa", "Walloon", [ 1, 2 ], 1 ], [ "wo", "Wolof", [ 1 ], 3 ], [ "yo", "Yoruba", [ 1, 2 ], 2 ], [ "zh", "Chinese", [ 1 ], 3 ] ], V = {
        1: function(a) {
            return Number(a > 1);
        },
        2: function(a) {
            return Number(1 != a);
        },
        3: function() {
            return 0;
        },
        4: function(a) {
            return Number(a % 10 == 1 && a % 100 != 11 ? 0 : a % 10 >= 2 && 4 >= a % 10 && (10 > a % 100 || a % 100 >= 20) ? 1 : 2);
        },
        5: function(a) {
            return Number(0 === a ? 0 : 1 == a ? 1 : 2 == a ? 2 : a % 100 >= 3 && 10 >= a % 100 ? 3 : a % 100 >= 11 ? 4 : 5);
        },
        6: function(a) {
            return Number(1 == a ? 0 : a >= 2 && 4 >= a ? 1 : 2);
        },
        7: function(a) {
            return Number(1 == a ? 0 : a % 10 >= 2 && 4 >= a % 10 && (10 > a % 100 || a % 100 >= 20) ? 1 : 2);
        },
        8: function(a) {
            return Number(1 == a ? 0 : 2 == a ? 1 : 8 != a && 11 != a ? 2 : 3);
        },
        9: function(a) {
            return Number(a >= 2);
        },
        10: function(a) {
            return Number(1 == a ? 0 : 2 == a ? 1 : 7 > a ? 2 : 11 > a ? 3 : 4);
        },
        11: function(a) {
            return Number(1 == a || 11 == a ? 0 : 2 == a || 12 == a ? 1 : a > 2 && 20 > a ? 2 : 3);
        },
        12: function(a) {
            return Number(a % 10 != 1 || a % 100 == 11);
        },
        13: function(a) {
            return Number(0 !== a);
        },
        14: function(a) {
            return Number(1 == a ? 0 : 2 == a ? 1 : 3 == a ? 2 : 3);
        },
        15: function(a) {
            return Number(a % 10 == 1 && a % 100 != 11 ? 0 : a % 10 >= 2 && (10 > a % 100 || a % 100 >= 20) ? 1 : 2);
        },
        16: function(a) {
            return Number(a % 10 == 1 && a % 100 != 11 ? 0 : 0 !== a ? 1 : 2);
        },
        17: function(a) {
            return Number(1 == a || a % 10 == 1 ? 0 : 1);
        },
        18: function(a) {
            return Number(1 == a ? 1 : 2);
        },
        19: function(a) {
            return Number(1 == a ? 0 : 0 === a || a % 100 > 1 && 11 > a % 100 ? 1 : a % 100 > 10 && 20 > a % 100 ? 2 : 3);
        },
        20: function(a) {
            return Number(1 == a ? 0 : 0 === a || a % 100 > 0 && 20 > a % 100 ? 1 : 2);
        },
        21: function(a) {
            return Number(a % 100 == 1 ? 1 : a % 100 == 2 ? 2 : a % 100 == 3 || a % 100 == 4 ? 3 : 0);
        }
    }, W = {
        rules: function() {
            var a, b = {};
            for (a = U.length; a--; ) b[U[a][0]] = {
                name: U[a][1],
                numbers: U[a][2],
                plurals: V[U[a][3]]
            };
            return b;
        }(),
        addRule: function(a, b) {
            W.rules[a] = b;
        },
        setCurrentLng: function(a) {
            if (!W.currentRule || W.currentRule.lng !== a) {
                var b = a.split("-");
                W.currentRule = {
                    lng: a,
                    rule: W.rules[b[0]]
                };
            }
        },
        needsPlural: function(a, b) {
            var c, d = a.split("-");
            return c = W.currentRule && W.currentRule.lng === a ? W.currentRule.rule : W.rules[d[T.getCountyIndexOfLng(a)]], 
            c && c.numbers.length <= 1 ? !1 : 1 !== this.get(a, b);
        },
        get: function(a, b) {
            function c(b, c) {
                var d;
                if (d = W.currentRule && W.currentRule.lng === a ? W.currentRule.rule : W.rules[b]) {
                    var e;
                    e = d.plurals(d.noAbs ? c : Math.abs(c));
                    var f = d.numbers[e];
                    return 2 === d.numbers.length && 1 === d.numbers[0] && (2 === f ? f = -1 : 1 === f && (f = 1)), 
                    f;
                }
                return 1 === c ? "1" : "-1";
            }
            var d = a.split("-");
            return c(d[T.getCountyIndexOfLng(a)], b);
        }
    }, X = {}, Y = function(a, b) {
        X[a] = b;
    }, Z = function() {
        function a(a) {
            return Object.prototype.toString.call(a).slice(8, -1).toLowerCase();
        }
        function b(a, b) {
            for (var c = []; b > 0; c[--b] = a) ;
            return c.join("");
        }
        var c = function() {
            return c.cache.hasOwnProperty(arguments[0]) || (c.cache[arguments[0]] = c.parse(arguments[0])), 
            c.format.call(null, c.cache[arguments[0]], arguments);
        };
        return c.format = function(c, d) {
            var e, f, g, h, i, j, k, l = 1, m = c.length, n = "", o = [];
            for (f = 0; m > f; f++) if (n = a(c[f]), "string" === n) o.push(c[f]); else if ("array" === n) {
                if (h = c[f], h[2]) for (e = d[l], g = 0; g < h[2].length; g++) {
                    if (!e.hasOwnProperty(h[2][g])) throw Z('[sprintf] property "%s" does not exist', h[2][g]);
                    e = e[h[2][g]];
                } else e = h[1] ? d[h[1]] : d[l++];
                if (/[^s]/.test(h[8]) && "number" != a(e)) throw Z("[sprintf] expecting number but found %s", a(e));
                switch (h[8]) {
                  case "b":
                    e = e.toString(2);
                    break;

                  case "c":
                    e = String.fromCharCode(e);
                    break;

                  case "d":
                    e = parseInt(e, 10);
                    break;

                  case "e":
                    e = h[7] ? e.toExponential(h[7]) : e.toExponential();
                    break;

                  case "f":
                    e = h[7] ? parseFloat(e).toFixed(h[7]) : parseFloat(e);
                    break;

                  case "o":
                    e = e.toString(8);
                    break;

                  case "s":
                    e = (e = String(e)) && h[7] ? e.substring(0, h[7]) : e;
                    break;

                  case "u":
                    e = Math.abs(e);
                    break;

                  case "x":
                    e = e.toString(16);
                    break;

                  case "X":
                    e = e.toString(16).toUpperCase();
                }
                e = /[def]/.test(h[8]) && h[3] && e >= 0 ? "+" + e : e, j = h[4] ? "0" == h[4] ? "0" : h[4].charAt(1) : " ", 
                k = h[6] - String(e).length, i = h[6] ? b(j, k) : "", o.push(h[5] ? e + i : i + e);
            }
            return o.join("");
        }, c.cache = {}, c.parse = function(a) {
            for (var b = a, c = [], d = [], e = 0; b; ) {
                if (null !== (c = /^[^\x25]+/.exec(b))) d.push(c[0]); else if (null !== (c = /^\x25{2}/.exec(b))) d.push("%"); else {
                    if (null === (c = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(b))) throw "[sprintf] huh?";
                    if (c[2]) {
                        e |= 1;
                        var f = [], g = c[2], h = [];
                        if (null === (h = /^([a-z_][a-z_\d]*)/i.exec(g))) throw "[sprintf] huh?";
                        for (f.push(h[1]); "" !== (g = g.substring(h[0].length)); ) if (null !== (h = /^\.([a-z_][a-z_\d]*)/i.exec(g))) f.push(h[1]); else {
                            if (null === (h = /^\[(\d+)\]/.exec(g))) throw "[sprintf] huh?";
                            f.push(h[1]);
                        }
                        c[2] = f;
                    } else e |= 2;
                    if (3 === e) throw "[sprintf] mixing positional and named placeholders is not (yet) supported";
                    d.push(c);
                }
                b = b.substring(c[0].length);
            }
            return d;
        }, c;
    }(), $ = function(a, b) {
        return b.unshift(a), Z.apply(null, b);
    };
    Y("sprintf", function(a, b, c) {
        return c.sprintf ? "[object Array]" === Object.prototype.toString.apply(c.sprintf) ? $(a, c.sprintf) : "object" == typeof c.sprintf ? Z(a, c.sprintf) : a : a;
    }), J.init = g, J.setLng = r, J.preload = h, J.addResourceBundle = i, J.hasResourceBundle = j, 
    J.getResourceBundle = k, J.addResource = m, J.addResources = n, J.removeResourceBundle = l, 
    J.loadNamespace = p, J.loadNamespaces = q, J.setDefaultNamespace = o, J.t = B, J.translate = B, 
    J.exists = A, J.detectLanguage = T.detectLanguage, J.pluralExtensions = W, J.sync = O, 
    J.functions = T, J.lng = s, J.addPostProcessor = Y, J.applyReplacement = T.applyReplacement, 
    J.options = P;
}("undefined" == typeof exports ? window : exports);

define("i18n", function(global) {
    return function() {
        var ret, fn;
        return ret || global.i18n;
    };
}(this));

(function defineMustache(global, factory) {
    if (typeof exports === "object" && exports && typeof exports.nodeName !== "string") {
        factory(exports);
    } else if (typeof define === "function" && define.amd) {
        define("mustache", [ "exports" ], factory);
    } else {
        global.Mustache = {};
        factory(global.Mustache);
    }
})(this, function mustacheFactory(mustache) {
    var objectToString = Object.prototype.toString;
    var isArray = Array.isArray || function isArrayPolyfill(object) {
        return objectToString.call(object) === "[object Array]";
    };
    function isFunction(object) {
        return typeof object === "function";
    }
    function typeStr(obj) {
        return isArray(obj) ? "array" : typeof obj;
    }
    function escapeRegExp(string) {
        return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function hasProperty(obj, propName) {
        return obj != null && typeof obj === "object" && propName in obj;
    }
    var regExpTest = RegExp.prototype.test;
    function testRegExp(re, string) {
        return regExpTest.call(re, string);
    }
    var nonSpaceRe = /\S/;
    function isWhitespace(string) {
        return !testRegExp(nonSpaceRe, string);
    }
    var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
    };
    function escapeHtml(string) {
        return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
            return entityMap[s];
        });
    }
    var whiteRe = /\s*/;
    var spaceRe = /\s+/;
    var equalsRe = /\s*=/;
    var curlyRe = /\s*\}/;
    var tagRe = /#|\^|\/|>|\{|&|=|!/;
    function parseTemplate(template, tags) {
        if (!template) return [];
        var sections = [];
        var tokens = [];
        var spaces = [];
        var hasTag = false;
        var nonSpace = false;
        function stripSpace() {
            if (hasTag && !nonSpace) {
                while (spaces.length) delete tokens[spaces.pop()];
            } else {
                spaces = [];
            }
            hasTag = false;
            nonSpace = false;
        }
        var openingTagRe, closingTagRe, closingCurlyRe;
        function compileTags(tagsToCompile) {
            if (typeof tagsToCompile === "string") tagsToCompile = tagsToCompile.split(spaceRe, 2);
            if (!isArray(tagsToCompile) || tagsToCompile.length !== 2) throw new Error("Invalid tags: " + tagsToCompile);
            openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
            closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
            closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
        }
        compileTags(tags || mustache.tags);
        var scanner = new Scanner(template);
        var start, type, value, chr, token, openSection;
        while (!scanner.eos()) {
            start = scanner.pos;
            value = scanner.scanUntil(openingTagRe);
            if (value) {
                for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
                    chr = value.charAt(i);
                    if (isWhitespace(chr)) {
                        spaces.push(tokens.length);
                    } else {
                        nonSpace = true;
                    }
                    tokens.push([ "text", chr, start, start + 1 ]);
                    start += 1;
                    if (chr === "\n") stripSpace();
                }
            }
            if (!scanner.scan(openingTagRe)) break;
            hasTag = true;
            type = scanner.scan(tagRe) || "name";
            scanner.scan(whiteRe);
            if (type === "=") {
                value = scanner.scanUntil(equalsRe);
                scanner.scan(equalsRe);
                scanner.scanUntil(closingTagRe);
            } else if (type === "{") {
                value = scanner.scanUntil(closingCurlyRe);
                scanner.scan(curlyRe);
                scanner.scanUntil(closingTagRe);
                type = "&";
            } else {
                value = scanner.scanUntil(closingTagRe);
            }
            if (!scanner.scan(closingTagRe)) throw new Error("Unclosed tag at " + scanner.pos);
            token = [ type, value, start, scanner.pos ];
            tokens.push(token);
            if (type === "#" || type === "^") {
                sections.push(token);
            } else if (type === "/") {
                openSection = sections.pop();
                if (!openSection) throw new Error('Unopened section "' + value + '" at ' + start);
                if (openSection[1] !== value) throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
            } else if (type === "name" || type === "{" || type === "&") {
                nonSpace = true;
            } else if (type === "=") {
                compileTags(value);
            }
        }
        openSection = sections.pop();
        if (openSection) throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
        return nestTokens(squashTokens(tokens));
    }
    function squashTokens(tokens) {
        var squashedTokens = [];
        var token, lastToken;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
            token = tokens[i];
            if (token) {
                if (token[0] === "text" && lastToken && lastToken[0] === "text") {
                    lastToken[1] += token[1];
                    lastToken[3] = token[3];
                } else {
                    squashedTokens.push(token);
                    lastToken = token;
                }
            }
        }
        return squashedTokens;
    }
    function nestTokens(tokens) {
        var nestedTokens = [];
        var collector = nestedTokens;
        var sections = [];
        var token, section;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
            token = tokens[i];
            switch (token[0]) {
              case "#":
              case "^":
                collector.push(token);
                sections.push(token);
                collector = token[4] = [];
                break;

              case "/":
                section = sections.pop();
                section[5] = token[2];
                collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
                break;

              default:
                collector.push(token);
            }
        }
        return nestedTokens;
    }
    function Scanner(string) {
        this.string = string;
        this.tail = string;
        this.pos = 0;
    }
    Scanner.prototype.eos = function eos() {
        return this.tail === "";
    };
    Scanner.prototype.scan = function scan(re) {
        var match = this.tail.match(re);
        if (!match || match.index !== 0) return "";
        var string = match[0];
        this.tail = this.tail.substring(string.length);
        this.pos += string.length;
        return string;
    };
    Scanner.prototype.scanUntil = function scanUntil(re) {
        var index = this.tail.search(re), match;
        switch (index) {
          case -1:
            match = this.tail;
            this.tail = "";
            break;

          case 0:
            match = "";
            break;

          default:
            match = this.tail.substring(0, index);
            this.tail = this.tail.substring(index);
        }
        this.pos += match.length;
        return match;
    };
    function Context(view, parentContext) {
        this.view = view;
        this.cache = {
            ".": this.view
        };
        this.parent = parentContext;
    }
    Context.prototype.push = function push(view) {
        return new Context(view, this);
    };
    Context.prototype.lookup = function lookup(name) {
        var cache = this.cache;
        var value;
        if (cache.hasOwnProperty(name)) {
            value = cache[name];
        } else {
            var context = this, names, index, lookupHit = false;
            while (context) {
                if (name.indexOf(".") > 0) {
                    value = context.view;
                    names = name.split(".");
                    index = 0;
                    while (value != null && index < names.length) {
                        if (index === names.length - 1) lookupHit = hasProperty(value, names[index]);
                        value = value[names[index++]];
                    }
                } else {
                    value = context.view[name];
                    lookupHit = hasProperty(context.view, name);
                }
                if (lookupHit) break;
                context = context.parent;
            }
            cache[name] = value;
        }
        if (isFunction(value)) value = value.call(this.view);
        return value;
    };
    function Writer() {
        this.cache = {};
    }
    Writer.prototype.clearCache = function clearCache() {
        this.cache = {};
    };
    Writer.prototype.parse = function parse(template, tags) {
        var cache = this.cache;
        var tokens = cache[template];
        if (tokens == null) tokens = cache[template] = parseTemplate(template, tags);
        return tokens;
    };
    Writer.prototype.render = function render(template, view, partials) {
        var tokens = this.parse(template);
        var context = view instanceof Context ? view : new Context(view);
        return this.renderTokens(tokens, context, partials, template);
    };
    Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate) {
        var buffer = "";
        var token, symbol, value;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
            value = undefined;
            token = tokens[i];
            symbol = token[0];
            if (symbol === "#") value = this.renderSection(token, context, partials, originalTemplate); else if (symbol === "^") value = this.renderInverted(token, context, partials, originalTemplate); else if (symbol === ">") value = this.renderPartial(token, context, partials, originalTemplate); else if (symbol === "&") value = this.unescapedValue(token, context); else if (symbol === "name") value = this.escapedValue(token, context); else if (symbol === "text") value = this.rawValue(token);
            if (value !== undefined) buffer += value;
        }
        return buffer;
    };
    Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate) {
        var self = this;
        var buffer = "";
        var value = context.lookup(token[1]);
        function subRender(template) {
            return self.render(template, context, partials);
        }
        if (!value) return;
        if (isArray(value)) {
            for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
                buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
            }
        } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
            buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
        } else if (isFunction(value)) {
            if (typeof originalTemplate !== "string") throw new Error("Cannot use higher-order sections without the original template");
            value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
            if (value != null) buffer += value;
        } else {
            buffer += this.renderTokens(token[4], context, partials, originalTemplate);
        }
        return buffer;
    };
    Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate) {
        var value = context.lookup(token[1]);
        if (!value || isArray(value) && value.length === 0) return this.renderTokens(token[4], context, partials, originalTemplate);
    };
    Writer.prototype.renderPartial = function renderPartial(token, context, partials) {
        if (!partials) return;
        var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
        if (value != null) return this.renderTokens(this.parse(value), context, partials, value);
    };
    Writer.prototype.unescapedValue = function unescapedValue(token, context) {
        var value = context.lookup(token[1]);
        if (value != null) return value;
    };
    Writer.prototype.escapedValue = function escapedValue(token, context) {
        var value = context.lookup(token[1]);
        if (value != null) return mustache.escape(value);
    };
    Writer.prototype.rawValue = function rawValue(token) {
        return token[1];
    };
    mustache.name = "mustache.js";
    mustache.version = "2.3.0";
    mustache.tags = [ "{{", "}}" ];
    var defaultWriter = new Writer();
    mustache.clearCache = function clearCache() {
        return defaultWriter.clearCache();
    };
    mustache.parse = function parse(template, tags) {
        return defaultWriter.parse(template, tags);
    };
    mustache.render = function render(template, view, partials) {
        if (typeof template !== "string") {
            throw new TypeError('Invalid template! Template should be a "string" ' + 'but "' + typeStr(template) + '" was given as the first ' + "argument for mustache#render(template, view, partials)");
        }
        return defaultWriter.render(template, view, partials);
    };
    mustache.to_html = function to_html(template, view, partials, send) {
        var result = mustache.render(template, view, partials);
        if (isFunction(send)) {
            send(result);
        } else {
            return result;
        }
    };
    mustache.escape = escapeHtml;
    mustache.Scanner = Scanner;
    mustache.Context = Context;
    mustache.Writer = Writer;
    return mustache;
});

(function(undefined) {
    var moment, VERSION = "2.9.0", globalScope = typeof global !== "undefined" && (typeof window === "undefined" || window === global.window) ? global : this, oldGlobalMoment, round = Math.round, hasOwnProperty = Object.prototype.hasOwnProperty, i, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, locales = {}, momentProperties = [], hasModule = typeof module !== "undefined" && module && module.exports, aspNetJsonRegex = /^\/?Date\((\-?\d+)/i, aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/, isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/, formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, parseTokenOneOrTwoDigits = /\d\d?/, parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenOneToFourDigits = /\d{1,4}/, parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, parseTokenDigits = /\d+/, parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, parseTokenT = /T/i, parseTokenOffsetMs = /[\+\-]?\d+/, parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, parseTokenOneDigit = /\d/, parseTokenTwoDigits = /\d\d/, parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{4}/, parseTokenSixDigits = /[+-]?\d{6}/, parseTokenSignedNumber = /[+-]?\d+/, isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, isoFormat = "YYYY-MM-DDTHH:mm:ssZ", isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/ ], [ "YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d{2}/ ], [ "YYYY-DDD", /\d{4}-\d{3}/ ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss", /(T| )\d\d:\d\d:\d\d/ ], [ "HH:mm", /(T| )\d\d:\d\d/ ], [ "HH", /(T| )\d\d/ ] ], parseTimezoneChunker = /([\+\-]|\d\d)/gi, proxyGettersAndSetters = "Date|Hours|Minutes|Seconds|Milliseconds".split("|"), unitMillisecondFactors = {
        Milliseconds: 1,
        Seconds: 1e3,
        Minutes: 6e4,
        Hours: 36e5,
        Days: 864e5,
        Months: 2592e6,
        Years: 31536e6
    }, unitAliases = {
        ms: "millisecond",
        s: "second",
        m: "minute",
        h: "hour",
        d: "day",
        D: "date",
        w: "week",
        W: "isoWeek",
        M: "month",
        Q: "quarter",
        y: "year",
        DDD: "dayOfYear",
        e: "weekday",
        E: "isoWeekday",
        gg: "weekYear",
        GG: "isoWeekYear"
    }, camelFunctions = {
        dayofyear: "dayOfYear",
        isoweekday: "isoWeekday",
        isoweek: "isoWeek",
        weekyear: "weekYear",
        isoweekyear: "isoWeekYear"
    }, formatFunctions = {}, relativeTimeThresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    }, ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "), formatTokenFunctions = {
        M: function() {
            return this.month() + 1;
        },
        MMM: function(format) {
            return this.localeData().monthsShort(this, format);
        },
        MMMM: function(format) {
            return this.localeData().months(this, format);
        },
        D: function() {
            return this.date();
        },
        DDD: function() {
            return this.dayOfYear();
        },
        d: function() {
            return this.day();
        },
        dd: function(format) {
            return this.localeData().weekdaysMin(this, format);
        },
        ddd: function(format) {
            return this.localeData().weekdaysShort(this, format);
        },
        dddd: function(format) {
            return this.localeData().weekdays(this, format);
        },
        w: function() {
            return this.week();
        },
        W: function() {
            return this.isoWeek();
        },
        YY: function() {
            return leftZeroFill(this.year() % 100, 2);
        },
        YYYY: function() {
            return leftZeroFill(this.year(), 4);
        },
        YYYYY: function() {
            return leftZeroFill(this.year(), 5);
        },
        YYYYYY: function() {
            var y = this.year(), sign = y >= 0 ? "+" : "-";
            return sign + leftZeroFill(Math.abs(y), 6);
        },
        gg: function() {
            return leftZeroFill(this.weekYear() % 100, 2);
        },
        gggg: function() {
            return leftZeroFill(this.weekYear(), 4);
        },
        ggggg: function() {
            return leftZeroFill(this.weekYear(), 5);
        },
        GG: function() {
            return leftZeroFill(this.isoWeekYear() % 100, 2);
        },
        GGGG: function() {
            return leftZeroFill(this.isoWeekYear(), 4);
        },
        GGGGG: function() {
            return leftZeroFill(this.isoWeekYear(), 5);
        },
        e: function() {
            return this.weekday();
        },
        E: function() {
            return this.isoWeekday();
        },
        a: function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), true);
        },
        A: function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), false);
        },
        H: function() {
            return this.hours();
        },
        h: function() {
            return this.hours() % 12 || 12;
        },
        m: function() {
            return this.minutes();
        },
        s: function() {
            return this.seconds();
        },
        S: function() {
            return toInt(this.milliseconds() / 100);
        },
        SS: function() {
            return leftZeroFill(toInt(this.milliseconds() / 10), 2);
        },
        SSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        SSSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        Z: function() {
            var a = this.utcOffset(), b = "+";
            if (a < 0) {
                a = -a;
                b = "-";
            }
            return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
        },
        ZZ: function() {
            var a = this.utcOffset(), b = "+";
            if (a < 0) {
                a = -a;
                b = "-";
            }
            return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
        },
        z: function() {
            return this.zoneAbbr();
        },
        zz: function() {
            return this.zoneName();
        },
        x: function() {
            return this.valueOf();
        },
        X: function() {
            return this.unix();
        },
        Q: function() {
            return this.quarter();
        }
    }, deprecations = {}, lists = [ "months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin" ], updateInProgress = false;
    function dfl(a, b, c) {
        switch (arguments.length) {
          case 2:
            return a != null ? a : b;

          case 3:
            return a != null ? a : b != null ? b : c;

          default:
            throw new Error("Implement me");
        }
    }
    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b);
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        };
    }
    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
            if (firstTime) {
                printMsg(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true;
        }
    }
    function padToken(func, count) {
        return function(a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function(a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }
    function monthDiff(a, b) {
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust);
    }
    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            return hour;
        }
    }
    function Locale() {}
    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
            checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
        if (updateInProgress === false) {
            updateInProgress = true;
            moment.updateOffset(this);
            updateInProgress = false;
        }
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = moment.localeData();
        this._bubble();
    }
    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
        if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function copyConfig(to, from) {
        var i, prop, val;
        if (typeof from._isAMomentObject !== "undefined") {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== "undefined") {
            to._i = from._i;
        }
        if (typeof from._f !== "undefined") {
            to._f = from._f;
        }
        if (typeof from._l !== "undefined") {
            to._l = from._l;
        }
        if (typeof from._strict !== "undefined") {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== "undefined") {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== "undefined") {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== "undefined") {
            to._offset = from._offset;
        }
        if (typeof from._pf !== "undefined") {
            to._pf = from._pf;
        }
        if (typeof from._locale !== "undefined") {
            to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== "undefined") {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }
    function leftZeroFill(number, targetLength, forceSign) {
        var output = "" + Math.abs(number), sign = number >= 0;
        while (output.length < targetLength) {
            output = "0" + output;
        }
        return (sign ? forceSign ? "+" : "" : "-") + output;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period).");
                tmp = val;
                val = period;
                period = tmp;
            }
            val = typeof val === "string" ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this;
        };
    }
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, "Date", rawGetter(mom, "Date") + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, "Month") + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }
    function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]";
    }
    function isDate(input) {
        return Object.prototype.toString.call(input) === "[object Date]" || input instanceof Date;
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, "$1");
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    function makeList(field) {
        var count, setter;
        if (field.indexOf("week") === 0) {
            count = 7;
            setter = "day";
        } else if (field.indexOf("month") === 0) {
            count = 12;
            setter = "month";
        } else {
            return;
        }
        moment[field] = function(format, index) {
            var i, getter, method = moment._locale[field], results = [];
            if (typeof format === "number") {
                index = format;
                format = undefined;
            }
            getter = function(i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || "");
            };
            if (index != null) {
                return getter(index);
            } else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }
        return value;
    }
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([ year, 11, 31 + dow - doy ]), dow, doy).week;
    }
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow = m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH : m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE : m._a[HOUR] < 0 || m._a[HOUR] > 24 || m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 || m._a[SECOND] !== 0 || m._a[MILLISECOND] !== 0) ? HOUR : m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE : m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND : m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            m._pf.overflow = overflow;
        }
    }
    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) && m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated;
            if (m._strict) {
                m._isValid = m._isValid && m._pf.charsLeftOver === 0 && m._pf.unusedTokens.length === 0 && m._pf.bigHour === undefined;
            }
        }
        return m._isValid;
    }
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join("-"));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
            try {
                oldLocale = moment.locale();
                require("./locale/" + name);
                moment.locale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }
    function makeAs(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (moment.isMoment(input) || isDate(input) ? +input : +moment(input)) - +res;
            res._d.setTime(+res._d + diff);
            moment.updateOffset(res, false);
            return res;
        } else {
            return moment(input).local();
        }
    }
    extend(Locale.prototype, {
        set: function(config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === "function") {
                    this[i] = prop;
                } else {
                    this["_" + i] = prop;
                }
            }
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source);
        },
        _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months: function(m) {
            return this._months[m.month()];
        },
        _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort: function(m) {
            return this._monthsShort[m.month()];
        },
        monthsParse: function(monthName, format, strict) {
            var i, mom, regex;
            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }
            for (i = 0; i < 12; i++) {
                mom = moment.utc([ 2e3, i ]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                    this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
                }
                if (!strict && !this._monthsParse[i]) {
                    regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                    this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
                }
                if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
                    return i;
                } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },
        _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays: function(m) {
            return this._weekdays[m.day()];
        },
        _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort: function(m) {
            return this._weekdaysShort[m.day()];
        },
        _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin: function(m) {
            return this._weekdaysMin[m.day()];
        },
        weekdaysParse: function(weekdayName) {
            var i, mom, regex;
            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }
            for (i = 0; i < 7; i++) {
                if (!this._weekdaysParse[i]) {
                    mom = moment([ 2e3, 1 ]).day(i);
                    regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                    this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
                }
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },
        _longDateFormat: {
            LTS: "h:mm:ss A",
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY LT",
            LLLL: "dddd, MMMM D, YYYY LT"
        },
        longDateFormat: function(key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },
        isPM: function(input) {
            return (input + "").toLowerCase().charAt(0) === "p";
        },
        _meridiemParse: /[ap]\.?m?\.?/i,
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "pm" : "PM";
            } else {
                return isLower ? "am" : "AM";
            }
        },
        _calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        calendar: function(key, mom, now) {
            var output = this._calendar[key];
            return typeof output === "function" ? output.apply(mom, [ now ]) : output;
        },
        _relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        relativeTime: function(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return typeof output === "function" ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        },
        pastFuture: function(diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"];
            return typeof format === "function" ? format(output) : format.replace(/%s/i, output);
        },
        ordinal: function(number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal: "%d",
        _ordinalParse: /\d{1,2}/,
        preparse: function(string) {
            return string;
        },
        postformat: function(string) {
            return string;
        },
        week: function(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },
        _week: {
            dow: 0,
            doy: 6
        },
        firstDayOfWeek: function() {
            return this._week.dow;
        },
        firstDayOfYear: function() {
            return this._week.doy;
        },
        _invalidDate: "Invalid date",
        invalidDate: function() {
            return this._invalidDate;
        }
    });
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function(mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
          case "Q":
            return parseTokenOneDigit;

          case "DDDD":
            return parseTokenThreeDigits;

          case "YYYY":
          case "GGGG":
          case "gggg":
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;

          case "Y":
          case "G":
          case "g":
            return parseTokenSignedNumber;

          case "YYYYYY":
          case "YYYYY":
          case "GGGGG":
          case "ggggg":
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;

          case "S":
            if (strict) {
                return parseTokenOneDigit;
            }

          case "SS":
            if (strict) {
                return parseTokenTwoDigits;
            }

          case "SSS":
            if (strict) {
                return parseTokenThreeDigits;
            }

          case "DDD":
            return parseTokenOneToThreeDigits;

          case "MMM":
          case "MMMM":
          case "dd":
          case "ddd":
          case "dddd":
            return parseTokenWord;

          case "a":
          case "A":
            return config._locale._meridiemParse;

          case "x":
            return parseTokenOffsetMs;

          case "X":
            return parseTokenTimestampMs;

          case "Z":
          case "ZZ":
            return parseTokenTimezone;

          case "T":
            return parseTokenT;

          case "SSSS":
            return parseTokenDigits;

          case "MM":
          case "DD":
          case "YY":
          case "GG":
          case "gg":
          case "HH":
          case "hh":
          case "mm":
          case "ss":
          case "ww":
          case "WW":
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;

          case "M":
          case "D":
          case "d":
          case "H":
          case "h":
          case "m":
          case "s":
          case "w":
          case "W":
          case "e":
          case "E":
            return parseTokenOneOrTwoDigits;

          case "Do":
            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;

          default:
            a = new RegExp(regexpEscape(unescapeFormat(token.replace("\\", "")), "i"));
            return a;
        }
    }
    function utcOffsetFromString(string) {
        string = string || "";
        var possibleTzMatches = string.match(parseTokenTimezone) || [], tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [], parts = (tzChunk + "").match(parseTimezoneChunker) || [ "-", 0, 0 ], minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === "+" ? minutes : -minutes;
    }
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;
        switch (token) {
          case "Q":
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;

          case "M":
          case "MM":
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;

          case "MMM":
          case "MMMM":
            a = config._locale.monthsParse(input, token, config._strict);
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;

          case "D":
          case "DD":
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;

          case "Do":
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(input.match(/\d{1,2}/)[0], 10));
            }
            break;

          case "DDD":
          case "DDDD":
            if (input != null) {
                config._dayOfYear = toInt(input);
            }
            break;

          case "YY":
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;

          case "YYYY":
          case "YYYYY":
          case "YYYYYY":
            datePartArray[YEAR] = toInt(input);
            break;

          case "a":
          case "A":
            config._meridiem = input;
            break;

          case "h":
          case "hh":
            config._pf.bigHour = true;

          case "H":
          case "HH":
            datePartArray[HOUR] = toInt(input);
            break;

          case "m":
          case "mm":
            datePartArray[MINUTE] = toInt(input);
            break;

          case "s":
          case "ss":
            datePartArray[SECOND] = toInt(input);
            break;

          case "S":
          case "SS":
          case "SSS":
          case "SSSS":
            datePartArray[MILLISECOND] = toInt(("0." + input) * 1e3);
            break;

          case "x":
            config._d = new Date(toInt(input));
            break;

          case "X":
            config._d = new Date(parseFloat(input) * 1e3);
            break;

          case "Z":
          case "ZZ":
            config._useUTC = true;
            config._tzm = utcOffsetFromString(input);
            break;

          case "dd":
          case "ddd":
          case "dddd":
            a = config._locale.weekdaysParse(input);
            if (a != null) {
                config._w = config._w || {};
                config._w["d"] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;

          case "w":
          case "ww":
          case "W":
          case "WW":
          case "d":
          case "e":
          case "E":
            token = token.substr(0, 1);

          case "gggg":
          case "GGGG":
          case "GGGGG":
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;

          case "gg":
          case "GG":
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                weekday = w.e + dow;
            } else {
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }
            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (;i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }
    function dateFromObject(config) {
        var normalizedInput;
        if (config._d) {
            return;
        }
        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [ normalizedInput.year, normalizedInput.month, normalizedInput.day || normalizedInput.date, normalizedInput.hour, normalizedInput.minute, normalizedInput.second, normalizedInput.millisecond ];
        dateFromConfig(config);
    }
    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [ now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() ];
        } else {
            return [ now.getFullYear(), now.getMonth(), now.getDate() ];
        }
    }
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }
        config._a = [];
        config._pf.empty = true;
        var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                } else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
            config._pf.bigHour = undefined;
        }
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        dateFromConfig(config);
        checkOverflow(config);
    }
    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function makeDateFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);
            if (!isValid(tempConfig)) {
                continue;
            }
            currentScore += tempConfig._pf.charsLeftOver;
            currentScore += tempConfig._pf.unusedTokens.length * 10;
            tempConfig._pf.score = currentScore;
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    function parseISO(config) {
        var i, l, string = config._i, match = isoRegex.exec(string);
        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }
    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === "string") {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10);
            });
            dateFromConfig(config);
        } else if (typeof input === "object") {
            dateFromObject(config);
        } else if (typeof input === "number") {
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }
    function makeDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }
    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }
    function parseWeekday(input, locale) {
        if (typeof input === "string") {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            } else {
                input = locale.weekdaysParse(input);
                if (typeof input !== "number") {
                    return null;
                }
            }
        }
        return input;
    }
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), years = round(duration.as("y")), args = seconds < relativeTimeThresholds.s && [ "s", seconds ] || minutes === 1 && [ "m" ] || minutes < relativeTimeThresholds.m && [ "mm", minutes ] || hours === 1 && [ "h" ] || hours < relativeTimeThresholds.h && [ "hh", hours ] || days === 1 && [ "d" ] || days < relativeTimeThresholds.d && [ "dd", days ] || months === 1 && [ "M" ] || months < relativeTimeThresholds.M && [ "MM", months ] || years === 1 && [ "y" ] || [ "yy", years ];
        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
    }
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }
        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }
        adjustedMoment = moment(mom).add(daysToDayOfWeek, "d");
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;
        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }
    function makeMoment(config) {
        var input = config._i, format = config._f, res;
        config._locale = config._locale || moment.localeData(config._l);
        if (input === null || format === undefined && input === "") {
            return moment.invalid({
                nullInput: true
            });
        }
        if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
        }
        if (moment.isMoment(input)) {
            return new Moment(input, true);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }
        res = new Moment(config);
        if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = undefined;
        }
        return res;
    }
    moment = function(input, format, locale, strict) {
        var c;
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined;
        }
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();
        return makeMoment(c);
    };
    moment.suppressDeprecationWarnings = false;
    moment.createFromInputFallback = deprecate("moment construction falls back to js Date. This is " + "discouraged and will be removed in upcoming major " + "release. Please refer to " + "https://github.com/moment/moment/issues/1407 for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    });
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    moment.min = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
    };
    moment.max = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
    };
    moment.utc = function(input, format, locale, strict) {
        var c;
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined;
        }
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();
        return makeMoment(c).utc();
    };
    moment.unix = function(input) {
        return moment(input * 1e3);
    };
    moment.duration = function(input, key) {
        var duration = input, match = null, sign, ret, parseIso, diffRes;
        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === "number") {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            parseIso = function(inp) {
                var res = inp && parseFloat(inp.replace(",", "."));
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        } else if (duration == null) {
            duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (moment.isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
        }
        return ret;
    };
    moment.version = VERSION;
    moment.defaultFormat = isoFormat;
    moment.ISO_8601 = function() {};
    moment.momentProperties = momentProperties;
    moment.updateOffset = function() {};
    moment.relativeTimeThreshold = function(threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
    };
    moment.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", function(key, value) {
        return moment.locale(key, value);
    });
    moment.locale = function(key, values) {
        var data;
        if (key) {
            if (typeof values !== "undefined") {
                data = moment.defineLocale(key, values);
            } else {
                data = moment.localeData(key);
            }
            if (data) {
                moment.duration._locale = moment._locale = data;
            }
        }
        return moment._locale._abbr;
    };
    moment.defineLocale = function(name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);
            moment.locale(name);
            return locales[name];
        } else {
            delete locales[name];
            return null;
        }
    };
    moment.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", function(key) {
        return moment.localeData(key);
    });
    moment.localeData = function(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return moment._locale;
        }
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [ key ];
        }
        return chooseLocale(key);
    };
    moment.isMoment = function(obj) {
        return obj instanceof Moment || obj != null && hasOwnProp(obj, "_isAMomentObject");
    };
    moment.isDuration = function(obj) {
        return obj instanceof Duration;
    };
    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }
    moment.normalizeUnits = function(units) {
        return normalizeUnits(units);
    };
    moment.invalid = function(flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        } else {
            m._pf.userInvalidated = true;
        }
        return m;
    };
    moment.parseZone = function() {
        return moment.apply(null, arguments).parseZone();
    };
    moment.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    moment.isDate = isDate;
    extend(moment.fn = Moment.prototype, {
        clone: function() {
            return moment(this);
        },
        valueOf: function() {
            return +this._d - (this._offset || 0) * 6e4;
        },
        unix: function() {
            return Math.floor(+this / 1e3);
        },
        toString: function() {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },
        toDate: function() {
            return this._offset ? new Date(+this) : this._d;
        },
        toISOString: function() {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                if ("function" === typeof Date.prototype.toISOString) {
                    return this.toDate().toISOString();
                } else {
                    return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
                }
            } else {
                return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
            }
        },
        toArray: function() {
            var m = this;
            return [ m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds() ];
        },
        isValid: function() {
            return isValid(this);
        },
        isDSTShifted: function() {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }
            return false;
        },
        parsingFlags: function() {
            return extend({}, this._pf);
        },
        invalidAt: function() {
            return this._pf.overflow;
        },
        utc: function(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
        },
        local: function(keepLocalTime) {
            if (this._isUTC) {
                this.utcOffset(0, keepLocalTime);
                this._isUTC = false;
                if (keepLocalTime) {
                    this.subtract(this._dateUtcOffset(), "m");
                }
            }
            return this;
        },
        format: function(inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },
        add: createAdder(1, "add"),
        subtract: createAdder(-1, "subtract"),
        diff: function(input, units, asFloat) {
            var that = makeAs(input, this), zoneDiff = (that.utcOffset() - this.utcOffset()) * 6e4, anchor, diff, output, daysAdjust;
            units = normalizeUnits(units);
            if (units === "year" || units === "month" || units === "quarter") {
                output = monthDiff(this, that);
                if (units === "quarter") {
                    output = output / 3;
                } else if (units === "year") {
                    output = output / 12;
                }
            } else {
                diff = this - that;
                output = units === "second" ? diff / 1e3 : units === "minute" ? diff / 6e4 : units === "hour" ? diff / 36e5 : units === "day" ? (diff - zoneDiff) / 864e5 : units === "week" ? (diff - zoneDiff) / 6048e5 : diff;
            }
            return asFloat ? output : absRound(output);
        },
        from: function(time, withoutSuffix) {
            return moment.duration({
                to: this,
                from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        },
        fromNow: function(withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },
        calendar: function(time) {
            var now = time || moment(), sod = makeAs(now, this).startOf("day"), diff = this.diff(sod, "days", true), format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
            return this.format(this.localeData().calendar(format, this, moment(now)));
        },
        isLeapYear: function() {
            return isLeapYear(this.year());
        },
        isDST: function() {
            return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        },
        day: function(input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, "d");
            } else {
                return day;
            }
        },
        month: makeAccessor("Month", true),
        startOf: function(units) {
            units = normalizeUnits(units);
            switch (units) {
              case "year":
                this.month(0);

              case "quarter":
              case "month":
                this.date(1);

              case "week":
              case "isoWeek":
              case "day":
                this.hours(0);

              case "hour":
                this.minutes(0);

              case "minute":
                this.seconds(0);

              case "second":
                this.milliseconds(0);
            }
            if (units === "week") {
                this.weekday(0);
            } else if (units === "isoWeek") {
                this.isoWeekday(1);
            }
            if (units === "quarter") {
                this.month(Math.floor(this.month() / 3) * 3);
            }
            return this;
        },
        endOf: function(units) {
            units = normalizeUnits(units);
            if (units === undefined || units === "millisecond") {
                return this;
            }
            return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms");
        },
        isAfter: function(input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
            if (units === "millisecond") {
                input = moment.isMoment(input) ? input : moment(input);
                return +this > +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return inputMs < +this.clone().startOf(units);
            }
        },
        isBefore: function(input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
            if (units === "millisecond") {
                input = moment.isMoment(input) ? input : moment(input);
                return +this < +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return +this.clone().endOf(units) < inputMs;
            }
        },
        isBetween: function(from, to, units) {
            return this.isAfter(from, units) && this.isBefore(to, units);
        },
        isSame: function(input, units) {
            var inputMs;
            units = normalizeUnits(units || "millisecond");
            if (units === "millisecond") {
                input = moment.isMoment(input) ? input : moment(input);
                return +this === +input;
            } else {
                inputMs = +moment(input);
                return +this.clone().startOf(units) <= inputMs && inputMs <= +this.clone().endOf(units);
            }
        },
        min: deprecate("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function(other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        }),
        max: deprecate("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function(other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        }),
        zone: deprecate("moment().zone is deprecated, use moment().utcOffset instead. " + "https://github.com/moment/moment/issues/1779", function(input, keepLocalTime) {
            if (input != null) {
                if (typeof input !== "string") {
                    input = -input;
                }
                this.utcOffset(input, keepLocalTime);
                return this;
            } else {
                return -this.utcOffset();
            }
        }),
        utcOffset: function(input, keepLocalTime) {
            var offset = this._offset || 0, localAdjust;
            if (input != null) {
                if (typeof input === "string") {
                    input = utcOffsetFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = this._dateUtcOffset();
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.add(localAdjust, "m");
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this, moment.duration(input - offset, "m"), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
                return this;
            } else {
                return this._isUTC ? offset : this._dateUtcOffset();
            }
        },
        isLocal: function() {
            return !this._isUTC;
        },
        isUtcOffset: function() {
            return this._isUTC;
        },
        isUtc: function() {
            return this._isUTC && this._offset === 0;
        },
        zoneAbbr: function() {
            return this._isUTC ? "UTC" : "";
        },
        zoneName: function() {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },
        parseZone: function() {
            if (this._tzm) {
                this.utcOffset(this._tzm);
            } else if (typeof this._i === "string") {
                this.utcOffset(utcOffsetFromString(this._i));
            }
            return this;
        },
        hasAlignedHourOffset: function(input) {
            if (!input) {
                input = 0;
            } else {
                input = moment(input).utcOffset();
            }
            return (this.utcOffset() - input) % 60 === 0;
        },
        daysInMonth: function() {
            return daysInMonth(this.year(), this.month());
        },
        dayOfYear: function(input) {
            var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864e5) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        },
        quarter: function(input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },
        weekYear: function(input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add(input - year, "y");
        },
        isoWeekYear: function(input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add(input - year, "y");
        },
        week: function(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, "d");
        },
        isoWeek: function(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, "d");
        },
        weekday: function(input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, "d");
        },
        isoWeekday: function(input) {
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },
        isoWeeksInYear: function() {
            return weeksInYear(this.year(), 1, 4);
        },
        weeksInYear: function() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },
        get: function(units) {
            units = normalizeUnits(units);
            return this[units]();
        },
        set: function(units, value) {
            var unit;
            if (typeof units === "object") {
                for (unit in units) {
                    this.set(unit, units[unit]);
                }
            } else {
                units = normalizeUnits(units);
                if (typeof this[units] === "function") {
                    this[units](value);
                }
            }
            return this;
        },
        locale: function(key) {
            var newLocaleData;
            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = moment.localeData(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        },
        lang: deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }),
        localeData: function() {
            return this._locale;
        },
        _dateUtcOffset: function() {
            return -Math.round(this._d.getTimezoneOffset() / 15) * 15;
        }
    });
    function rawMonthSetter(mom, value) {
        var dayOfMonth;
        if (typeof value === "string") {
            value = mom.localeData().monthsParse(value);
            if (typeof value !== "number") {
                return mom;
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
    }
    function rawGetter(mom, unit) {
        return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]();
    }
    function rawSetter(mom, unit, value) {
        if (unit === "Month") {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
        }
    }
    function makeAccessor(unit, keepTime) {
        return function(value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }
    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor("Milliseconds", false);
    moment.fn.second = moment.fn.seconds = makeAccessor("Seconds", false);
    moment.fn.minute = moment.fn.minutes = makeAccessor("Minutes", false);
    moment.fn.hour = moment.fn.hours = makeAccessor("Hours", true);
    moment.fn.date = makeAccessor("Date", true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor("Date", true));
    moment.fn.year = makeAccessor("FullYear", true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor("FullYear", true));
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;
    moment.fn.toJSON = moment.fn.toISOString;
    moment.fn.isUTC = moment.fn.isUtc;
    function daysToYears(days) {
        return days * 400 / 146097;
    }
    function yearsToDays(years) {
        return years * 146097 / 400;
    }
    extend(moment.duration.fn = Duration.prototype, {
        _bubble: function() {
            var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years = 0;
            data.milliseconds = milliseconds % 1e3;
            seconds = absRound(milliseconds / 1e3);
            data.seconds = seconds % 60;
            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;
            hours = absRound(minutes / 60);
            data.hours = hours % 24;
            days += absRound(hours / 24);
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));
            months += absRound(days / 30);
            days %= 30;
            years += absRound(months / 12);
            months %= 12;
            data.days = days;
            data.months = months;
            data.years = years;
        },
        abs: function() {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);
            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);
            return this;
        },
        weeks: function() {
            return absRound(this.days() / 7);
        },
        valueOf: function() {
            return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        },
        humanize: function(withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());
            if (withSuffix) {
                output = this.localeData().pastFuture(+this, output);
            }
            return this.localeData().postformat(output);
        },
        add: function(input, val) {
            var dur = moment.duration(input, val);
            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;
            this._bubble();
            return this;
        },
        subtract: function(input, val) {
            var dur = moment.duration(input, val);
            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;
            this._bubble();
            return this;
        },
        get: function(units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + "s"]();
        },
        as: function(units) {
            var days, months;
            units = normalizeUnits(units);
            if (units === "month" || units === "year") {
                days = this._days + this._milliseconds / 864e5;
                months = this._months + daysToYears(days) * 12;
                return units === "month" ? months : months / 12;
            } else {
                days = this._days + Math.round(yearsToDays(this._months / 12));
                switch (units) {
                  case "week":
                    return days / 7 + this._milliseconds / 6048e5;

                  case "day":
                    return days + this._milliseconds / 864e5;

                  case "hour":
                    return days * 24 + this._milliseconds / 36e5;

                  case "minute":
                    return days * 24 * 60 + this._milliseconds / 6e4;

                  case "second":
                    return days * 24 * 60 * 60 + this._milliseconds / 1e3;

                  case "millisecond":
                    return Math.floor(days * 24 * 60 * 60 * 1e3) + this._milliseconds;

                  default:
                    throw new Error("Unknown unit " + units);
                }
            }
        },
        lang: moment.fn.lang,
        locale: moment.fn.locale,
        toIsoString: deprecate("toIsoString() is deprecated. Please use toISOString() instead " + "(notice the capitals)", function() {
            return this.toISOString();
        }),
        toISOString: function() {
            var years = Math.abs(this.years()), months = Math.abs(this.months()), days = Math.abs(this.days()), hours = Math.abs(this.hours()), minutes = Math.abs(this.minutes()), seconds = Math.abs(this.seconds() + this.milliseconds() / 1e3);
            if (!this.asSeconds()) {
                return "P0D";
            }
            return (this.asSeconds() < 0 ? "-" : "") + "P" + (years ? years + "Y" : "") + (months ? months + "M" : "") + (days ? days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hours + "H" : "") + (minutes ? minutes + "M" : "") + (seconds ? seconds + "S" : "");
        },
        localeData: function() {
            return this._locale;
        },
        toJSON: function() {
            return this.toISOString();
        }
    });
    moment.duration.fn.toString = moment.duration.fn.toISOString;
    function makeDurationGetter(name) {
        moment.duration.fn[name] = function() {
            return this._data[name];
        };
    }
    for (i in unitMillisecondFactors) {
        if (hasOwnProp(unitMillisecondFactors, i)) {
            makeDurationGetter(i.toLowerCase());
        }
    }
    moment.duration.fn.asMilliseconds = function() {
        return this.as("ms");
    };
    moment.duration.fn.asSeconds = function() {
        return this.as("s");
    };
    moment.duration.fn.asMinutes = function() {
        return this.as("m");
    };
    moment.duration.fn.asHours = function() {
        return this.as("h");
    };
    moment.duration.fn.asDays = function() {
        return this.as("d");
    };
    moment.duration.fn.asWeeks = function() {
        return this.as("weeks");
    };
    moment.duration.fn.asMonths = function() {
        return this.as("M");
    };
    moment.duration.fn.asYears = function() {
        return this.as("y");
    };
    moment.locale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("af", {
            months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),
            weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"),
            weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),
            weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"),
            meridiemParse: /vm|nm/i,
            isPM: function(input) {
                return /^nm$/i.test(input);
            },
            meridiem: function(hours, minutes, isLower) {
                if (hours < 12) {
                    return isLower ? "vm" : "VM";
                } else {
                    return isLower ? "nm" : "NM";
                }
            },
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Vandag om] LT",
                nextDay: "[M么re om] LT",
                nextWeek: "dddd [om] LT",
                lastDay: "[Gister om] LT",
                lastWeek: "[Laas] dddd [om] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "oor %s",
                past: "%s gelede",
                s: "'n paar sekondes",
                m: "'n minuut",
                mm: "%d minute",
                h: "'n uur",
                hh: "%d ure",
                d: "'n dag",
                dd: "%d dae",
                M: "'n maand",
                MM: "%d maande",
                y: "'n jaar",
                yy: "%d jaar"
            },
            ordinalParse: /\d{1,2}(ste|de)/,
            ordinal: function(number) {
                return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("ar-ma", {
            months: "賷賳丕賷乇_賮亘乇丕賷乇_賲丕乇爻_兀亘乇賷賱_賲丕賷_賷賵賳賷賵_賷賵賱賷賵夭_睾卮鬲_卮鬲賳亘乇_兀賰鬲賵亘乇_賳賵賳亘乇_丿噩賳亘乇".split("_"),
            monthsShort: "賷賳丕賷乇_賮亘乇丕賷乇_賲丕乇爻_兀亘乇賷賱_賲丕賷_賷賵賳賷賵_賷賵賱賷賵夭_睾卮鬲_卮鬲賳亘乇_兀賰鬲賵亘乇_賳賵賳亘乇_丿噩賳亘乇".split("_"),
            weekdays: "丕賱兀丨丿_丕賱廿鬲賳賷賳_丕賱孬賱丕孬丕亍_丕賱兀乇亘毓丕亍_丕賱禺賲賷爻_丕賱噩賲毓丞_丕賱爻亘鬲".split("_"),
            weekdaysShort: "丕丨丿_丕鬲賳賷賳_孬賱丕孬丕亍_丕乇亘毓丕亍_禺賲賷爻_噩賲毓丞_爻亘鬲".split("_"),
            weekdaysMin: "丨_賳_孬_乇_禺_噩_爻".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[丕賱賷賵賲 毓賱賶 丕賱爻丕毓丞] LT",
                nextDay: "[睾丿丕 毓賱賶 丕賱爻丕毓丞] LT",
                nextWeek: "dddd [毓賱賶 丕賱爻丕毓丞] LT",
                lastDay: "[兀賲爻 毓賱賶 丕賱爻丕毓丞] LT",
                lastWeek: "dddd [毓賱賶 丕賱爻丕毓丞] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "賮賷 %s",
                past: "賲賳匕 %s",
                s: "孬賵丕賳",
                m: "丿賯賷賯丞",
                mm: "%d 丿賯丕卅賯",
                h: "爻丕毓丞",
                hh: "%d 爻丕毓丕鬲",
                d: "賷賵賲",
                dd: "%d 兀賷丕賲",
                M: "卮賴乇",
                MM: "%d 兀卮賴乇",
                y: "爻賳丞",
                yy: "%d 爻賳賵丕鬲"
            },
            week: {
                dow: 6,
                doy: 12
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "佟",
            "2": "佗",
            "3": "伲",
            "4": "伽",
            "5": "佶",
            "6": "佴",
            "7": "侑",
            "8": "侉",
            "9": "侃",
            "0": "贍"
        }, numberMap = {
            "佟": "1",
            "佗": "2",
            "伲": "3",
            "伽": "4",
            "佶": "5",
            "佴": "6",
            "侑": "7",
            "侉": "8",
            "侃": "9",
            "贍": "0"
        };
        return moment.defineLocale("ar-sa", {
            months: "賷賳丕賷乇_賮亘乇丕賷乇_賲丕乇爻_兀亘乇賷賱_賲丕賷賵_賷賵賳賷賵_賷賵賱賷賵_兀睾爻胤爻_爻亘鬲賲亘乇_兀賰鬲賵亘乇_賳賵賮賲亘乇_丿賷爻賲亘乇".split("_"),
            monthsShort: "賷賳丕賷乇_賮亘乇丕賷乇_賲丕乇爻_兀亘乇賷賱_賲丕賷賵_賷賵賳賷賵_賷賵賱賷賵_兀睾爻胤爻_爻亘鬲賲亘乇_兀賰鬲賵亘乇_賳賵賮賲亘乇_丿賷爻賲亘乇".split("_"),
            weekdays: "丕賱兀丨丿_丕賱廿孬賳賷賳_丕賱孬賱丕孬丕亍_丕賱兀乇亘毓丕亍_丕賱禺賲賷爻_丕賱噩賲毓丞_丕賱爻亘鬲".split("_"),
            weekdaysShort: "兀丨丿_廿孬賳賷賳_孬賱丕孬丕亍_兀乇亘毓丕亍_禺賲賷爻_噩賲毓丞_爻亘鬲".split("_"),
            weekdaysMin: "丨_賳_孬_乇_禺_噩_爻".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            meridiemParse: /氐|賲/,
            isPM: function(input) {
                return "賲" === input;
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 12) {
                    return "氐";
                } else {
                    return "賲";
                }
            },
            calendar: {
                sameDay: "[丕賱賷賵賲 毓賱賶 丕賱爻丕毓丞] LT",
                nextDay: "[睾丿丕 毓賱賶 丕賱爻丕毓丞] LT",
                nextWeek: "dddd [毓賱賶 丕賱爻丕毓丞] LT",
                lastDay: "[兀賲爻 毓賱賶 丕賱爻丕毓丞] LT",
                lastWeek: "dddd [毓賱賶 丕賱爻丕毓丞] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "賮賷 %s",
                past: "賲賳匕 %s",
                s: "孬賵丕賳",
                m: "丿賯賷賯丞",
                mm: "%d 丿賯丕卅賯",
                h: "爻丕毓丞",
                hh: "%d 爻丕毓丕鬲",
                d: "賷賵賲",
                dd: "%d 兀賷丕賲",
                M: "卮賴乇",
                MM: "%d 兀卮賴乇",
                y: "爻賳丞",
                yy: "%d 爻賳賵丕鬲"
            },
            preparse: function(string) {
                return string.replace(/[佟佗伲伽佶佴侑侉侃贍]/g, function(match) {
                    return numberMap[match];
                }).replace(/貙/g, ",");
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                }).replace(/,/g, "貙");
            },
            week: {
                dow: 6,
                doy: 12
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("ar-tn", {
            months: "噩丕賳賮賷_賮賷賮乇賷_賲丕乇爻_兀賮乇賷賱_賲丕賷_噩賵丕賳_噩賵賷賱賷丞_兀賵鬲_爻亘鬲賲亘乇_兀賰鬲賵亘乇_賳賵賮賲亘乇_丿賷爻賲亘乇".split("_"),
            monthsShort: "噩丕賳賮賷_賮賷賮乇賷_賲丕乇爻_兀賮乇賷賱_賲丕賷_噩賵丕賳_噩賵賷賱賷丞_兀賵鬲_爻亘鬲賲亘乇_兀賰鬲賵亘乇_賳賵賮賲亘乇_丿賷爻賲亘乇".split("_"),
            weekdays: "丕賱兀丨丿_丕賱廿孬賳賷賳_丕賱孬賱丕孬丕亍_丕賱兀乇亘毓丕亍_丕賱禺賲賷爻_丕賱噩賲毓丞_丕賱爻亘鬲".split("_"),
            weekdaysShort: "兀丨丿_廿孬賳賷賳_孬賱丕孬丕亍_兀乇亘毓丕亍_禺賲賷爻_噩賲毓丞_爻亘鬲".split("_"),
            weekdaysMin: "丨_賳_孬_乇_禺_噩_爻".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[丕賱賷賵賲 毓賱賶 丕賱爻丕毓丞] LT",
                nextDay: "[睾丿丕 毓賱賶 丕賱爻丕毓丞] LT",
                nextWeek: "dddd [毓賱賶 丕賱爻丕毓丞] LT",
                lastDay: "[兀賲爻 毓賱賶 丕賱爻丕毓丞] LT",
                lastWeek: "dddd [毓賱賶 丕賱爻丕毓丞] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "賮賷 %s",
                past: "賲賳匕 %s",
                s: "孬賵丕賳",
                m: "丿賯賷賯丞",
                mm: "%d 丿賯丕卅賯",
                h: "爻丕毓丞",
                hh: "%d 爻丕毓丕鬲",
                d: "賷賵賲",
                dd: "%d 兀賷丕賲",
                M: "卮賴乇",
                MM: "%d 兀卮賴乇",
                y: "爻賳丞",
                yy: "%d 爻賳賵丕鬲"
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "佟",
            "2": "佗",
            "3": "伲",
            "4": "伽",
            "5": "佶",
            "6": "佴",
            "7": "侑",
            "8": "侉",
            "9": "侃",
            "0": "贍"
        }, numberMap = {
            "佟": "1",
            "佗": "2",
            "伲": "3",
            "伽": "4",
            "佶": "5",
            "佴": "6",
            "侑": "7",
            "侉": "8",
            "侃": "9",
            "贍": "0"
        }, pluralForm = function(n) {
            return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
        }, plurals = {
            s: [ "兀賯賱 賲賳 孬丕賳賷丞", "孬丕賳賷丞 賵丕丨丿丞", [ "孬丕賳賷鬲丕賳", "孬丕賳賷鬲賷賳" ], "%d 孬賵丕賳", "%d 孬丕賳賷丞", "%d 孬丕賳賷丞" ],
            m: [ "兀賯賱 賲賳 丿賯賷賯丞", "丿賯賷賯丞 賵丕丨丿丞", [ "丿賯賷賯鬲丕賳", "丿賯賷賯鬲賷賳" ], "%d 丿賯丕卅賯", "%d 丿賯賷賯丞", "%d 丿賯賷賯丞" ],
            h: [ "兀賯賱 賲賳 爻丕毓丞", "爻丕毓丞 賵丕丨丿丞", [ "爻丕毓鬲丕賳", "爻丕毓鬲賷賳" ], "%d 爻丕毓丕鬲", "%d 爻丕毓丞", "%d 爻丕毓丞" ],
            d: [ "兀賯賱 賲賳 賷賵賲", "賷賵賲 賵丕丨丿", [ "賷賵賲丕賳", "賷賵賲賷賳" ], "%d 兀賷丕賲", "%d 賷賵賲賸丕", "%d 賷賵賲" ],
            M: [ "兀賯賱 賲賳 卮賴乇", "卮賴乇 賵丕丨丿", [ "卮賴乇丕賳", "卮賴乇賷賳" ], "%d 兀卮賴乇", "%d 卮賴乇丕", "%d 卮賴乇" ],
            y: [ "兀賯賱 賲賳 毓丕賲", "毓丕賲 賵丕丨丿", [ "毓丕賲丕賳", "毓丕賲賷賳" ], "%d 兀毓賵丕賲", "%d 毓丕賲賸丕", "%d 毓丕賲" ]
        }, pluralize = function(u) {
            return function(number, withoutSuffix, string, isFuture) {
                var f = pluralForm(number), str = plurals[u][pluralForm(number)];
                if (f === 2) {
                    str = str[withoutSuffix ? 0 : 1];
                }
                return str.replace(/%d/i, number);
            };
        }, months = [ "賰丕賳賵賳 丕賱孬丕賳賷 賷賳丕賷乇", "卮亘丕胤 賮亘乇丕賷乇", "丌匕丕乇 賲丕乇爻", "賳賷爻丕賳 兀亘乇賷賱", "兀賷丕乇 賲丕賷賵", "丨夭賷乇丕賳 賷賵賳賷賵", "鬲賲賵夭 賷賵賱賷賵", "丌亘 兀睾爻胤爻", "兀賷賱賵賱 爻亘鬲賲亘乇", "鬲卮乇賷賳 丕賱兀賵賱 兀賰鬲賵亘乇", "鬲卮乇賷賳 丕賱孬丕賳賷 賳賵賮賲亘乇", "賰丕賳賵賳 丕賱兀賵賱 丿賷爻賲亘乇" ];
        return moment.defineLocale("ar", {
            months: months,
            monthsShort: months,
            weekdays: "丕賱兀丨丿_丕賱廿孬賳賷賳_丕賱孬賱丕孬丕亍_丕賱兀乇亘毓丕亍_丕賱禺賲賷爻_丕賱噩賲毓丞_丕賱爻亘鬲".split("_"),
            weekdaysShort: "兀丨丿_廿孬賳賷賳_孬賱丕孬丕亍_兀乇亘毓丕亍_禺賲賷爻_噩賲毓丞_爻亘鬲".split("_"),
            weekdaysMin: "丨_賳_孬_乇_禺_噩_爻".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            meridiemParse: /氐|賲/,
            isPM: function(input) {
                return "賲" === input;
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 12) {
                    return "氐";
                } else {
                    return "賲";
                }
            },
            calendar: {
                sameDay: "[丕賱賷賵賲 毓賳丿 丕賱爻丕毓丞] LT",
                nextDay: "[睾丿賸丕 毓賳丿 丕賱爻丕毓丞] LT",
                nextWeek: "dddd [毓賳丿 丕賱爻丕毓丞] LT",
                lastDay: "[兀賲爻 毓賳丿 丕賱爻丕毓丞] LT",
                lastWeek: "dddd [毓賳丿 丕賱爻丕毓丞] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "亘毓丿 %s",
                past: "賲賳匕 %s",
                s: pluralize("s"),
                m: pluralize("m"),
                mm: pluralize("m"),
                h: pluralize("h"),
                hh: pluralize("h"),
                d: pluralize("d"),
                dd: pluralize("d"),
                M: pluralize("M"),
                MM: pluralize("M"),
                y: pluralize("y"),
                yy: pluralize("y")
            },
            preparse: function(string) {
                return string.replace(/[佟佗伲伽佶佴侑侉侃贍]/g, function(match) {
                    return numberMap[match];
                }).replace(/貙/g, ",");
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                }).replace(/,/g, "貙");
            },
            week: {
                dow: 6,
                doy: 12
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var suffixes = {
            1: "-inci",
            5: "-inci",
            8: "-inci",
            70: "-inci",
            80: "-inci",
            2: "-nci",
            7: "-nci",
            20: "-nci",
            50: "-nci",
            3: "-眉nc眉",
            4: "-眉nc眉",
            100: "-眉nc眉",
            6: "-nc谋",
            9: "-uncu",
            10: "-uncu",
            30: "-uncu",
            60: "-谋nc谋",
            90: "-谋nc谋"
        };
        return moment.defineLocale("az", {
            months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"),
            monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),
            weekdays: "Bazar_Bazar ert蓹si_脟蓹r艧蓹nb蓹 ax艧am谋_脟蓹r艧蓹nb蓹_C眉m蓹 ax艧am谋_C眉m蓹_艦蓹nb蓹".split("_"),
            weekdaysShort: "Baz_BzE_脟Ax_脟蓹r_CAx_C眉m_艦蓹n".split("_"),
            weekdaysMin: "Bz_BE_脟A_脟蓹_CA_C眉_艦蓹".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[bug眉n saat] LT",
                nextDay: "[sabah saat] LT",
                nextWeek: "[g蓹l蓹n h蓹ft蓹] dddd [saat] LT",
                lastDay: "[d眉n蓹n] LT",
                lastWeek: "[ke莽蓹n h蓹ft蓹] dddd [saat] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s sonra",
                past: "%s 蓹vv蓹l",
                s: "birne莽蓹 saniyy蓹",
                m: "bir d蓹qiq蓹",
                mm: "%d d蓹qiq蓹",
                h: "bir saat",
                hh: "%d saat",
                d: "bir g眉n",
                dd: "%d g眉n",
                M: "bir ay",
                MM: "%d ay",
                y: "bir il",
                yy: "%d il"
            },
            meridiemParse: /gec蓹|s蓹h蓹r|g眉nd眉z|ax艧am/,
            isPM: function(input) {
                return /^(g眉nd眉z|ax艧am)$/.test(input);
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "gec蓹";
                } else if (hour < 12) {
                    return "s蓹h蓹r";
                } else if (hour < 17) {
                    return "g眉nd眉z";
                } else {
                    return "ax艧am";
                }
            },
            ordinalParse: /\d{1,2}-(谋nc谋|inci|nci|眉nc眉|nc谋|uncu)/,
            ordinal: function(number) {
                if (number === 0) {
                    return number + "-谋nc谋";
                }
                var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
                return number + (suffixes[a] || suffixes[b] || suffixes[c]);
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function plural(word, num) {
            var forms = word.split("_");
            return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
        }
        function relativeTimeWithPlural(number, withoutSuffix, key) {
            var format = {
                mm: withoutSuffix ? "褏胁褨谢褨薪邪_褏胁褨谢褨薪褘_褏胁褨谢褨薪" : "褏胁褨谢褨薪褍_褏胁褨谢褨薪褘_褏胁褨谢褨薪",
                hh: withoutSuffix ? "谐邪写蟹褨薪邪_谐邪写蟹褨薪褘_谐邪写蟹褨薪" : "谐邪写蟹褨薪褍_谐邪写蟹褨薪褘_谐邪写蟹褨薪",
                dd: "写蟹械薪褜_写薪褨_写蟹褢薪",
                MM: "屑械褋褟褑_屑械褋褟褑褘_屑械褋褟褑邪褳",
                yy: "谐芯写_谐邪写褘_谐邪写芯褳"
            };
            if (key === "m") {
                return withoutSuffix ? "褏胁褨谢褨薪邪" : "褏胁褨谢褨薪褍";
            } else if (key === "h") {
                return withoutSuffix ? "谐邪写蟹褨薪邪" : "谐邪写蟹褨薪褍";
            } else {
                return number + " " + plural(format[key], +number);
            }
        }
        function monthsCaseReplace(m, format) {
            var months = {
                nominative: "褋褌褍写蟹械薪褜_谢褞褌褘_褋邪泻邪胁褨泻_泻褉邪褋邪胁褨泻_褌褉邪胁械薪褜_褔褝褉胁械薪褜_谢褨锌械薪褜_卸薪褨胁械薪褜_胁械褉邪褋械薪褜_泻邪褋褌褉褘褔薪褨泻_谢褨褋褌邪锌邪写_褋薪械卸邪薪褜".split("_"),
                accusative: "褋褌褍写蟹械薪褟_谢褞褌邪谐邪_褋邪泻邪胁褨泻邪_泻褉邪褋邪胁褨泻邪_褌褉邪褳薪褟_褔褝褉胁械薪褟_谢褨锌械薪褟_卸薪褨褳薪褟_胁械褉邪褋薪褟_泻邪褋褌褉褘褔薪褨泻邪_谢褨褋褌邪锌邪写邪_褋薪械卸薪褟".split("_")
            }, nounCase = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(format) ? "accusative" : "nominative";
            return months[nounCase][m.month()];
        }
        function weekdaysCaseReplace(m, format) {
            var weekdays = {
                nominative: "薪褟写蟹械谢褟_锌邪薪褟写蟹械谢邪泻_邪褳褌芯褉邪泻_褋械褉邪写邪_褔邪褑胁械褉_锌褟褌薪褨褑邪_褋褍斜芯褌邪".split("_"),
                accusative: "薪褟写蟹械谢褞_锌邪薪褟写蟹械谢邪泻_邪褳褌芯褉邪泻_褋械褉邪写褍_褔邪褑胁械褉_锌褟褌薪褨褑褍_褋褍斜芯褌褍".split("_")
            }, nounCase = /\[ ?[袙胁] ?(?:屑褨薪褍谢褍褞|薪邪褋褌褍锌薪褍褞)? ?\] ?dddd/.test(format) ? "accusative" : "nominative";
            return weekdays[nounCase][m.day()];
        }
        return moment.defineLocale("be", {
            months: monthsCaseReplace,
            monthsShort: "褋褌褍写_谢褞褌_褋邪泻_泻褉邪褋_褌褉邪胁_褔褝褉胁_谢褨锌_卸薪褨胁_胁械褉_泻邪褋褌_谢褨褋褌_褋薪械卸".split("_"),
            weekdays: weekdaysCaseReplace,
            weekdaysShort: "薪写_锌薪_邪褌_褋褉_褔褑_锌褌_褋斜".split("_"),
            weekdaysMin: "薪写_锌薪_邪褌_褋褉_褔褑_锌褌_褋斜".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY 谐.",
                LLL: "D MMMM YYYY 谐., LT",
                LLLL: "dddd, D MMMM YYYY 谐., LT"
            },
            calendar: {
                sameDay: "[小褢薪薪褟 褳] LT",
                nextDay: "[袟邪褳褌褉邪 褳] LT",
                lastDay: "[校褔芯褉邪 褳] LT",
                nextWeek: function() {
                    return "[校] dddd [褳] LT";
                },
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                      case 3:
                      case 5:
                      case 6:
                        return "[校 屑褨薪褍谢褍褞] dddd [褳] LT";

                      case 1:
                      case 2:
                      case 4:
                        return "[校 屑褨薪褍谢褘] dddd [褳] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "锌褉邪蟹 %s",
                past: "%s 褌邪屑褍",
                s: "薪械泻邪谢褜泻褨 褋械泻褍薪写",
                m: relativeTimeWithPlural,
                mm: relativeTimeWithPlural,
                h: relativeTimeWithPlural,
                hh: relativeTimeWithPlural,
                d: "写蟹械薪褜",
                dd: relativeTimeWithPlural,
                M: "屑械褋褟褑",
                MM: relativeTimeWithPlural,
                y: "谐芯写",
                yy: relativeTimeWithPlural
            },
            meridiemParse: /薪芯褔褘|褉邪薪褨褑褘|写薪褟|胁械褔邪褉邪/,
            isPM: function(input) {
                return /^(写薪褟|胁械褔邪褉邪)$/.test(input);
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "薪芯褔褘";
                } else if (hour < 12) {
                    return "褉邪薪褨褑褘";
                } else if (hour < 17) {
                    return "写薪褟";
                } else {
                    return "胁械褔邪褉邪";
                }
            },
            ordinalParse: /\d{1,2}-(褨|褘|谐邪)/,
            ordinal: function(number, period) {
                switch (period) {
                  case "M":
                  case "d":
                  case "DDD":
                  case "w":
                  case "W":
                    return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + "-褨" : number + "-褘";

                  case "D":
                    return number + "-谐邪";

                  default:
                    return number;
                }
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("bg", {
            months: "褟薪褍邪褉懈_褎械胁褉褍邪褉懈_屑邪褉褌_邪锌褉懈谢_屑邪泄_褞薪懈_褞谢懈_邪胁谐褍褋褌_褋械锌褌械屑胁褉懈_芯泻褌芯屑胁褉懈_薪芯械屑胁褉懈_写械泻械屑胁褉懈".split("_"),
            monthsShort: "褟薪褉_褎械胁_屑邪褉_邪锌褉_屑邪泄_褞薪懈_褞谢懈_邪胁谐_褋械锌_芯泻褌_薪芯械_写械泻".split("_"),
            weekdays: "薪械写械谢褟_锌芯薪械写械谢薪懈泻_胁褌芯褉薪懈泻_褋褉褟写邪_褔械褌胁褗褉褌褗泻_锌械褌褗泻_褋褗斜芯褌邪".split("_"),
            weekdaysShort: "薪械写_锌芯薪_胁褌芯_褋褉褟_褔械褌_锌械褌_褋褗斜".split("_"),
            weekdaysMin: "薪写_锌薪_胁褌_褋褉_褔褌_锌褌_褋斜".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "D.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[袛薪械褋 胁] LT",
                nextDay: "[校褌褉械 胁] LT",
                nextWeek: "dddd [胁] LT",
                lastDay: "[袙褔械褉邪 胁] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                      case 3:
                      case 6:
                        return "[袙 懈蟹屑懈薪邪谢邪褌邪] dddd [胁] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[袙 懈蟹屑懈薪邪谢懈褟] dddd [胁] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "褋谢械写 %s",
                past: "锌褉械写懈 %s",
                s: "薪褟泻芯谢泻芯 褋械泻褍薪写懈",
                m: "屑懈薪褍褌邪",
                mm: "%d 屑懈薪褍褌懈",
                h: "褔邪褋",
                hh: "%d 褔邪褋邪",
                d: "写械薪",
                dd: "%d 写薪懈",
                M: "屑械褋械褑",
                MM: "%d 屑械褋械褑邪",
                y: "谐芯写懈薪邪",
                yy: "%d 谐芯写懈薪懈"
            },
            ordinalParse: /\d{1,2}-(械胁|械薪|褌懈|胁懈|褉懈|屑懈)/,
            ordinal: function(number) {
                var lastDigit = number % 10, last2Digits = number % 100;
                if (number === 0) {
                    return number + "-械胁";
                } else if (last2Digits === 0) {
                    return number + "-械薪";
                } else if (last2Digits > 10 && last2Digits < 20) {
                    return number + "-褌懈";
                } else if (lastDigit === 1) {
                    return number + "-胁懈";
                } else if (lastDigit === 2) {
                    return number + "-褉懈";
                } else if (lastDigit === 7 || lastDigit === 8) {
                    return number + "-屑懈";
                } else {
                    return number + "-褌懈";
                }
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "唰�",
            "2": "唰�",
            "3": "唰�",
            "4": "唰�",
            "5": "唰�",
            "6": "唰�",
            "7": "唰�",
            "8": "唰�",
            "9": "唰�",
            "0": "唰�"
        }, numberMap = {
            "唰�": "1",
            "唰�": "2",
            "唰�": "3",
            "唰�": "4",
            "唰�": "5",
            "唰�": "6",
            "唰�": "7",
            "唰�": "8",
            "唰�": "9",
            "唰�": "0"
        };
        return moment.defineLocale("bn", {
            months: "唳溹唳ㄠ唰熰唳班_唳唳唰熰唳班_唳唳班唳歘唳忇Κ唰嵿Π唳苦Σ_唳_唳溹唳╛唳溹唳侧唳嘷唳呧唳距Ω唰嵿_唳膏唳唳熰唳唳Π_唳呧唰嵿唰嬥Μ唳癬唳ㄠΝ唰囙Ξ唰嵿Μ唳癬唳∴唳膏唳唳Π".split("_"),
            monthsShort: "唳溹唳ㄠ_唳唳琠唳唳班唳歘唳忇Κ唳癬唳_唳溹唳╛唳溹唳瞋唳呧_唳膏唳唳焈唳呧唰嵿唰媉唳ㄠΝ_唳∴唳膏唳".split("_"),
            weekdays: "唳班Μ唳苦Μ唳距Π_唳膏唳Μ唳距Π_唳唰嵿唳侧Μ唳距Π_唳唳оΜ唳距Π_唳唳灌Ω唰嵿Κ唳む唳む唳唳癬唳多唳曕唳班唳唳癬唳多Θ唳苦Μ唳距Π".split("_"),
            weekdaysShort: "唳班Μ唳縚唳膏唳甠唳唰嵿唳瞋唳唳唳唳灌Ω唰嵿Κ唳む唳む_唳多唳曕唳班_唳多Θ唳�".split("_"),
            weekdaysMin: "唳班Μ_唳膏Ξ_唳唰嵿_唳_唳唳班唳筥唳多_唳多Θ唳�".split("_"),
            longDateFormat: {
                LT: "A h:mm 唳膏Ξ唰�",
                LTS: "A h:mm:ss 唳膏Ξ唰�",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, LT",
                LLLL: "dddd, D MMMM YYYY, LT"
            },
            calendar: {
                sameDay: "[唳嗋] LT",
                nextDay: "[唳嗋唳距Ξ唰€唳曕唳瞉 LT",
                nextWeek: "dddd, LT",
                lastDay: "[唳椸Δ唳曕唳瞉 LT",
                lastWeek: "[唳椸Δ] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s 唳Π唰�",
                past: "%s 唳嗋唰�",
                s: "唳曕唳� 唳膏唳曕唳ㄠ唳�",
                m: "唳忇 唳唳ㄠ唳�",
                mm: "%d 唳唳ㄠ唳�",
                h: "唳忇 唳樴Θ唰嵿唳�",
                hh: "%d 唳樴Θ唰嵿唳�",
                d: "唳忇 唳︵唳�",
                dd: "%d 唳︵唳�",
                M: "唳忇 唳唳�",
                MM: "%d 唳唳�",
                y: "唳忇 唳唳�",
                yy: "%d 唳唳�"
            },
            preparse: function(string) {
                return string.replace(/[唰оЖ唰┼И唰К唰М唰Е]/g, function(match) {
                    return numberMap[match];
                });
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                });
            },
            meridiemParse: /唳班唳唳多唳距Σ|唳︵唳唳皘唳唳曕唳瞸唳班唳�/,
            isPM: function(input) {
                return /^(唳︵唳唳皘唳唳曕唳瞸唳班唳�)$/.test(input);
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "唳班唳�";
                } else if (hour < 10) {
                    return "唳多唳距Σ";
                } else if (hour < 17) {
                    return "唳︵唳唳�";
                } else if (hour < 20) {
                    return "唳唳曕唳�";
                } else {
                    return "唳班唳�";
                }
            },
            week: {
                dow: 0,
                doy: 6
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "嗉�",
            "2": "嗉�",
            "3": "嗉�",
            "4": "嗉�",
            "5": "嗉�",
            "6": "嗉�",
            "7": "嗉�",
            "8": "嗉�",
            "9": "嗉�",
            "0": "嗉�"
        }, numberMap = {
            "嗉�": "1",
            "嗉�": "2",
            "嗉�": "3",
            "嗉�": "4",
            "嗉�": "5",
            "嗉�": "6",
            "嗉�": "7",
            "嗉�": "8",
            "嗉�": "9",
            "嗉�": "0"
        };
        return moment.defineLocale("bo", {
            months: "嘟熰境嗉嬥綎嗉嬥綉嘟勦紜嘟斷郊_嘟熰境嗉嬥綎嗉嬥絺嘟夃讲嘟︵紜嘟擾嘟熰境嗉嬥綎嗉嬥絺嘟︵酱嘟樴紜嘟擾嘟熰境嗉嬥綎嗉嬥綎嘟炧讲嗉嬥綌_嘟熰境嗉嬥綎嗉嬥剑嗑斷紜嘟擾嘟熰境嗉嬥綎嗉嬥綉嗑侧酱嘟傕紜嘟擾嘟熰境嗉嬥綎嗉嬥綎嘟戉酱嘟撪紜嘟擾嘟熰境嗉嬥綎嗉嬥綎嘟⑧緬嗑编綉嗉嬥綌_嘟熰境嗉嬥綎嗉嬥綉嘟傕酱嗉嬥綌_嘟熰境嗉嬥綎嗉嬥綎嘟呧酱嗉嬥綌_嘟熰境嗉嬥綎嗉嬥綎嘟呧酱嗉嬥絺嘟呧讲嘟傕紜嘟擾嘟熰境嗉嬥綎嗉嬥綎嘟呧酱嗉嬥絺嘟夃讲嘟︵紜嘟�".split("_"),
            monthsShort: "嘟熰境嗉嬥綎嗉嬥綉嘟勦紜嘟斷郊_嘟熰境嗉嬥綎嗉嬥絺嘟夃讲嘟︵紜嘟擾嘟熰境嗉嬥綎嗉嬥絺嘟︵酱嘟樴紜嘟擾嘟熰境嗉嬥綎嗉嬥綎嘟炧讲嗉嬥綌_嘟熰境嗉嬥綎嗉嬥剑嗑斷紜嘟擾嘟熰境嗉嬥綎嗉嬥綉嗑侧酱嘟傕紜嘟擾嘟熰境嗉嬥綎嗉嬥綎嘟戉酱嘟撪紜嘟擾嘟熰境嗉嬥綎嗉嬥綎嘟⑧緬嗑编綉嗉嬥綌_嘟熰境嗉嬥綎嗉嬥綉嘟傕酱嗉嬥綌_嘟熰境嗉嬥綎嗉嬥綎嘟呧酱嗉嬥綌_嘟熰境嗉嬥綎嗉嬥綎嘟呧酱嗉嬥絺嘟呧讲嘟傕紜嘟擾嘟熰境嗉嬥綎嗉嬥綎嘟呧酱嗉嬥絺嘟夃讲嘟︵紜嘟�".split("_"),
            weekdays: "嘟傕綗嘟犩紜嘟夃讲嗉嬥綐嗉媉嘟傕綗嘟犩紜嘟熰境嗉嬥綎嗉媉嘟傕綗嘟犩紜嘟樴讲嘟傕紜嘟戉綐嘟⑧紜_嘟傕綗嘟犩紜嘟｀痉嘟傕紜嘟斷紜_嘟傕綗嘟犩紜嘟曕酱嘟⑧紜嘟栢酱_嘟傕綗嘟犩紜嘟斷紜嘟︵絼嘟︵紜_嘟傕綗嘟犩紜嘟︵兢嘟亨綋嗉嬥綌嗉�".split("_"),
            weekdaysShort: "嘟夃讲嗉嬥綐嗉媉嘟熰境嗉嬥綎嗉媉嘟樴讲嘟傕紜嘟戉綐嘟⑧紜_嘟｀痉嘟傕紜嘟斷紜_嘟曕酱嘟⑧紜嘟栢酱_嘟斷紜嘟︵絼嘟︵紜_嘟︵兢嘟亨綋嗉嬥綌嗉�".split("_"),
            weekdaysMin: "嘟夃讲嗉嬥綐嗉媉嘟熰境嗉嬥綎嗉媉嘟樴讲嘟傕紜嘟戉綐嘟⑧紜_嘟｀痉嘟傕紜嘟斷紜_嘟曕酱嘟⑧紜嘟栢酱_嘟斷紜嘟︵絼嘟︵紜_嘟︵兢嘟亨綋嗉嬥綌嗉�".split("_"),
            longDateFormat: {
                LT: "A h:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, LT",
                LLLL: "dddd, D MMMM YYYY, LT"
            },
            calendar: {
                sameDay: "[嘟戉讲嗉嬥舰嘟侧絼] LT",
                nextDay: "[嘟︵絼嗉嬥綁嘟侧綋] LT",
                nextWeek: "[嘟栢綉嘟脆綋嗉嬥綍嗑侧絺嗉嬥舰嗑椸胶嘟︵紜嘟榏, LT",
                lastDay: "[嘟佮紜嘟︵絼] LT",
                lastWeek: "[嘟栢綉嘟脆綋嗉嬥綍嗑侧絺嗉嬥綐嘟愢綘嗉嬥綐] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s 嘟｀紜",
                past: "%s 嘟︵緮嘟撪紜嘟�",
                s: "嘟｀綐嗉嬥溅嘟�",
                m: "嘟︵緪嘟⑧紜嘟樴紜嘟傕絽嘟侧絺",
                mm: "%d 嘟︵緪嘟⑧紜嘟�",
                h: "嘟嗋酱嗉嬥綒嘟监綉嗉嬥絺嘟呧讲嘟�",
                hh: "%d 嘟嗋酱嗉嬥綒嘟监綉",
                d: "嘟夃讲嘟撪紜嘟傕絽嘟侧絺",
                dd: "%d 嘟夃讲嘟撪紜",
                M: "嘟熰境嗉嬥綎嗉嬥絺嘟呧讲嘟�",
                MM: "%d 嘟熰境嗉嬥綎",
                y: "嘟｀郊嗉嬥絺嘟呧讲嘟�",
                yy: "%d 嘟｀郊"
            },
            preparse: function(string) {
                return string.replace(/[嗉∴饥嗉｀激嗉ム鸡嗉о绩嗉┼紶]/g, function(match) {
                    return numberMap[match];
                });
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                });
            },
            meridiemParse: /嘟樴綒嘟撪紜嘟樴郊|嘟炧郊嘟傕溅嗉嬥絸嘟嘟夃讲嘟撪紜嘟傕酱嘟剕嘟戉絺嘟监絼嗉嬥綉嘟倈嘟樴綒嘟撪紜嘟樴郊/,
            isPM: function(input) {
                return /^(嘟夃讲嘟撪紜嘟傕酱嘟剕嘟戉絺嘟监絼嗉嬥綉嘟倈嘟樴綒嘟撪紜嘟樴郊)$/.test(input);
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "嘟樴綒嘟撪紜嘟樴郊";
                } else if (hour < 10) {
                    return "嘟炧郊嘟傕溅嗉嬥絸嘟�";
                } else if (hour < 17) {
                    return "嘟夃讲嘟撪紜嘟傕酱嘟�";
                } else if (hour < 20) {
                    return "嘟戉絺嘟监絼嗉嬥綉嘟�";
                } else {
                    return "嘟樴綒嘟撪紜嘟樴郊";
                }
            },
            week: {
                dow: 0,
                doy: 6
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function relativeTimeWithMutation(number, withoutSuffix, key) {
            var format = {
                mm: "munutenn",
                MM: "miz",
                dd: "devezh"
            };
            return number + " " + mutation(format[key], number);
        }
        function specialMutationForYears(number) {
            switch (lastNumber(number)) {
              case 1:
              case 3:
              case 4:
              case 5:
              case 9:
                return number + " bloaz";

              default:
                return number + " vloaz";
            }
        }
        function lastNumber(number) {
            if (number > 9) {
                return lastNumber(number % 10);
            }
            return number;
        }
        function mutation(text, number) {
            if (number === 2) {
                return softMutation(text);
            }
            return text;
        }
        function softMutation(text) {
            var mutationTable = {
                m: "v",
                b: "v",
                d: "z"
            };
            if (mutationTable[text.charAt(0)] === undefined) {
                return text;
            }
            return mutationTable[text.charAt(0)] + text.substring(1);
        }
        return moment.defineLocale("br", {
            months: "Genver_C'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),
            monthsShort: "Gen_C'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),
            weekdays: "Sul_Lun_Meurzh_Merc'her_Yaou_Gwener_Sadorn".split("_"),
            weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),
            weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),
            longDateFormat: {
                LT: "h[e]mm A",
                LTS: "h[e]mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D [a viz] MMMM YYYY",
                LLL: "D [a viz] MMMM YYYY LT",
                LLLL: "dddd, D [a viz] MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Hiziv da] LT",
                nextDay: "[Warc'hoazh da] LT",
                nextWeek: "dddd [da] LT",
                lastDay: "[Dec'h da] LT",
                lastWeek: "dddd [paset da] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "a-benn %s",
                past: "%s 'zo",
                s: "un nebeud segondenno霉",
                m: "ur vunutenn",
                mm: relativeTimeWithMutation,
                h: "un eur",
                hh: "%d eur",
                d: "un devezh",
                dd: relativeTimeWithMutation,
                M: "ur miz",
                MM: relativeTimeWithMutation,
                y: "ur bloaz",
                yy: specialMutationForYears
            },
            ordinalParse: /\d{1,2}(a帽|vet)/,
            ordinal: function(number) {
                var output = number === 1 ? "a帽" : "vet";
                return number + output;
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function translate(number, withoutSuffix, key) {
            var result = number + " ";
            switch (key) {
              case "m":
                return withoutSuffix ? "jedna minuta" : "jedne minute";

              case "mm":
                if (number === 1) {
                    result += "minuta";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "minute";
                } else {
                    result += "minuta";
                }
                return result;

              case "h":
                return withoutSuffix ? "jedan sat" : "jednog sata";

              case "hh":
                if (number === 1) {
                    result += "sat";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "sata";
                } else {
                    result += "sati";
                }
                return result;

              case "dd":
                if (number === 1) {
                    result += "dan";
                } else {
                    result += "dana";
                }
                return result;

              case "MM":
                if (number === 1) {
                    result += "mjesec";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "mjeseca";
                } else {
                    result += "mjeseci";
                }
                return result;

              case "yy":
                if (number === 1) {
                    result += "godina";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "godine";
                } else {
                    result += "godina";
                }
                return result;
            }
        }
        return moment.defineLocale("bs", {
            months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"),
            monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"),
            weekdays: "nedjelja_ponedjeljak_utorak_srijeda_膷etvrtak_petak_subota".split("_"),
            weekdaysShort: "ned._pon._uto._sri._膷et._pet._sub.".split("_"),
            weekdaysMin: "ne_po_ut_sr_膷e_pe_su".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD. MM. YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[danas u] LT",
                nextDay: "[sutra u] LT",
                nextWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[u] [nedjelju] [u] LT";

                      case 3:
                        return "[u] [srijedu] [u] LT";

                      case 6:
                        return "[u] [subotu] [u] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[u] dddd [u] LT";
                    }
                },
                lastDay: "[ju膷er u] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                      case 3:
                        return "[pro拧lu] dddd [u] LT";

                      case 6:
                        return "[pro拧le] [subote] [u] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[pro拧li] dddd [u] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "prije %s",
                s: "par sekundi",
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: "dan",
                dd: translate,
                M: "mjesec",
                MM: translate,
                y: "godinu",
                yy: translate
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("ca", {
            months: "gener_febrer_mar莽_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"),
            monthsShort: "gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.".split("_"),
            weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"),
            weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"),
            weekdaysMin: "Dg_Dl_Dt_Dc_Dj_Dv_Ds".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: function() {
                    return "[avui a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                },
                nextDay: function() {
                    return "[dem脿 a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                },
                nextWeek: function() {
                    return "dddd [a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                },
                lastDay: function() {
                    return "[ahir a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                },
                lastWeek: function() {
                    return "[el] dddd [passat a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "en %s",
                past: "fa %s",
                s: "uns segons",
                m: "un minut",
                mm: "%d minuts",
                h: "una hora",
                hh: "%d hores",
                d: "un dia",
                dd: "%d dies",
                M: "un mes",
                MM: "%d mesos",
                y: "un any",
                yy: "%d anys"
            },
            ordinalParse: /\d{1,2}(r|n|t|猫|a)/,
            ordinal: function(number, period) {
                var output = number === 1 ? "r" : number === 2 ? "n" : number === 3 ? "r" : number === 4 ? "t" : "猫";
                if (period === "w" || period === "W") {
                    output = "a";
                }
                return number + output;
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var months = "leden_煤nor_b艡ezen_duben_kv臎ten_膷erven_膷ervenec_srpen_z谩艡铆_艡铆jen_listopad_prosinec".split("_"), monthsShort = "led_煤no_b艡e_dub_kv臎_膷vn_膷vc_srp_z谩艡_艡铆j_lis_pro".split("_");
        function plural(n) {
            return n > 1 && n < 5 && ~~(n / 10) !== 1;
        }
        function translate(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            switch (key) {
              case "s":
                return withoutSuffix || isFuture ? "p谩r sekund" : "p谩r sekundami";

              case "m":
                return withoutSuffix ? "minuta" : isFuture ? "minutu" : "minutou";

              case "mm":
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "minuty" : "minut");
                } else {
                    return result + "minutami";
                }
                break;

              case "h":
                return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

              case "hh":
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "hodiny" : "hodin");
                } else {
                    return result + "hodinami";
                }
                break;

              case "d":
                return withoutSuffix || isFuture ? "den" : "dnem";

              case "dd":
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "dny" : "dn铆");
                } else {
                    return result + "dny";
                }
                break;

              case "M":
                return withoutSuffix || isFuture ? "m臎s铆c" : "m臎s铆cem";

              case "MM":
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "m臎s铆ce" : "m臎s铆c暖");
                } else {
                    return result + "m臎s铆ci";
                }
                break;

              case "y":
                return withoutSuffix || isFuture ? "rok" : "rokem";

              case "yy":
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "roky" : "let");
                } else {
                    return result + "lety";
                }
                break;
            }
        }
        return moment.defineLocale("cs", {
            months: months,
            monthsShort: monthsShort,
            monthsParse: function(months, monthsShort) {
                var i, _monthsParse = [];
                for (i = 0; i < 12; i++) {
                    _monthsParse[i] = new RegExp("^" + months[i] + "$|^" + monthsShort[i] + "$", "i");
                }
                return _monthsParse;
            }(months, monthsShort),
            weekdays: "ned臎le_pond臎l铆_煤ter媒_st艡eda_膷tvrtek_p谩tek_sobota".split("_"),
            weekdaysShort: "ne_po_煤t_st_膷t_p谩_so".split("_"),
            weekdaysMin: "ne_po_煤t_st_膷t_p谩_so".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[dnes v] LT",
                nextDay: "[z铆tra v] LT",
                nextWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[v ned臎li v] LT";

                      case 1:
                      case 2:
                        return "[v] dddd [v] LT";

                      case 3:
                        return "[ve st艡edu v] LT";

                      case 4:
                        return "[ve 膷tvrtek v] LT";

                      case 5:
                        return "[v p谩tek v] LT";

                      case 6:
                        return "[v sobotu v] LT";
                    }
                },
                lastDay: "[v膷era v] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[minulou ned臎li v] LT";

                      case 1:
                      case 2:
                        return "[minul茅] dddd [v] LT";

                      case 3:
                        return "[minulou st艡edu v] LT";

                      case 4:
                      case 5:
                        return "[minul媒] dddd [v] LT";

                      case 6:
                        return "[minulou sobotu v] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "p艡ed %s",
                s: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("cv", {
            months: "泻膬褉谢邪褔_薪邪褉膬褋_锌褍褕_邪泻邪_屑邪泄_莽臅褉褌屑械_褍褌膬_莽褍褉谢邪_邪胁膬薪_褞锌邪_褔映泻_褉邪褕褌邪胁".split("_"),
            monthsShort: "泻膬褉_薪邪褉_锌褍褕_邪泻邪_屑邪泄_莽臅褉_褍褌膬_莽褍褉_邪胁_褞锌邪_褔映泻_褉邪褕".split("_"),
            weekdays: "胁褘褉褋邪褉薪懈泻褍薪_褌褍薪褌懈泻褍薪_褘褌谢邪褉懈泻褍薪_褞薪泻褍薪_泻臅莽薪械褉薪懈泻褍薪_褝褉薪械泻褍薪_褕膬屑邪褌泻褍薪".split("_"),
            weekdaysShort: "胁褘褉_褌褍薪_褘褌谢_褞薪_泻臅莽_褝褉薪_褕膬屑".split("_"),
            weekdaysMin: "胁褉_褌薪_褘褌_褞薪_泻莽_褝褉_褕屑".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD-MM-YYYY",
                LL: "YYYY [莽褍谢褏懈] MMMM [褍泄膬褏臅薪] D[-屑臅褕臅]",
                LLL: "YYYY [莽褍谢褏懈] MMMM [褍泄膬褏臅薪] D[-屑臅褕臅], LT",
                LLLL: "dddd, YYYY [莽褍谢褏懈] MMMM [褍泄膬褏臅薪] D[-屑臅褕臅], LT"
            },
            calendar: {
                sameDay: "[袩邪褟薪] LT [褋械褏械褌褉械]",
                nextDay: "[蝎褉邪薪] LT [褋械褏械褌褉械]",
                lastDay: "[臄薪械褉] LT [褋械褏械褌褉械]",
                nextWeek: "[脟懈褌械褋] dddd LT [褋械褏械褌褉械]",
                lastWeek: "[袠褉褌薪臅] dddd LT [褋械褏械褌褉械]",
                sameElse: "L"
            },
            relativeTime: {
                future: function(output) {
                    var affix = /褋械褏械褌$/i.exec(output) ? "褉械薪" : /莽褍谢$/i.exec(output) ? "褌邪薪" : "褉邪薪";
                    return output + affix;
                },
                past: "%s 泻邪褟谢谢邪",
                s: "锌臅褉-懈泻 莽械泻泻褍薪褌",
                m: "锌臅褉 屑懈薪褍褌",
                mm: "%d 屑懈薪褍褌",
                h: "锌臅褉 褋械褏械褌",
                hh: "%d 褋械褏械褌",
                d: "锌臅褉 泻褍薪",
                dd: "%d 泻褍薪",
                M: "锌臅褉 褍泄膬褏",
                MM: "%d 褍泄膬褏",
                y: "锌臅褉 莽褍谢",
                yy: "%d 莽褍谢"
            },
            ordinalParse: /\d{1,2}-屑臅褕/,
            ordinal: "%d-屑臅褕",
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("cy", {
            months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),
            monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),
            weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),
            weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),
            weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Heddiw am] LT",
                nextDay: "[Yfory am] LT",
                nextWeek: "dddd [am] LT",
                lastDay: "[Ddoe am] LT",
                lastWeek: "dddd [diwethaf am] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "mewn %s",
                past: "%s yn 么l",
                s: "ychydig eiliadau",
                m: "munud",
                mm: "%d munud",
                h: "awr",
                hh: "%d awr",
                d: "diwrnod",
                dd: "%d diwrnod",
                M: "mis",
                MM: "%d mis",
                y: "blwyddyn",
                yy: "%d flynedd"
            },
            ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
            ordinal: function(number) {
                var b = number, output = "", lookup = [ "", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed" ];
                if (b > 20) {
                    if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                        output = "fed";
                    } else {
                        output = "ain";
                    }
                } else if (b > 0) {
                    output = lookup[b];
                }
                return number + output;
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("da", {
            months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),
            monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
            weekdays: "s酶ndag_mandag_tirsdag_onsdag_torsdag_fredag_l酶rdag".split("_"),
            weekdaysShort: "s酶n_man_tir_ons_tor_fre_l酶r".split("_"),
            weekdaysMin: "s酶_ma_ti_on_to_fr_l酶".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd [d.] D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[I dag kl.] LT",
                nextDay: "[I morgen kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[I g氓r kl.] LT",
                lastWeek: "[sidste] dddd [kl] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "%s siden",
                s: "f氓 sekunder",
                m: "et minut",
                mm: "%d minutter",
                h: "en time",
                hh: "%d timer",
                d: "en dag",
                dd: "%d dage",
                M: "en m氓ned",
                MM: "%d m氓neder",
                y: "et 氓r",
                yy: "%d 氓r"
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                m: [ "eine Minute", "einer Minute" ],
                h: [ "eine Stunde", "einer Stunde" ],
                d: [ "ein Tag", "einem Tag" ],
                dd: [ number + " Tage", number + " Tagen" ],
                M: [ "ein Monat", "einem Monat" ],
                MM: [ number + " Monate", number + " Monaten" ],
                y: [ "ein Jahr", "einem Jahr" ],
                yy: [ number + " Jahre", number + " Jahren" ]
            };
            return withoutSuffix ? format[key][0] : format[key][1];
        }
        return moment.defineLocale("de-at", {
            months: "J盲nner_Februar_M盲rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
            monthsShort: "J盲n._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
            weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
            weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
            weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Heute um] LT [Uhr]",
                sameElse: "L",
                nextDay: "[Morgen um] LT [Uhr]",
                nextWeek: "dddd [um] LT [Uhr]",
                lastDay: "[Gestern um] LT [Uhr]",
                lastWeek: "[letzten] dddd [um] LT [Uhr]"
            },
            relativeTime: {
                future: "in %s",
                past: "vor %s",
                s: "ein paar Sekunden",
                m: processRelativeTime,
                mm: "%d Minuten",
                h: processRelativeTime,
                hh: "%d Stunden",
                d: processRelativeTime,
                dd: processRelativeTime,
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                m: [ "eine Minute", "einer Minute" ],
                h: [ "eine Stunde", "einer Stunde" ],
                d: [ "ein Tag", "einem Tag" ],
                dd: [ number + " Tage", number + " Tagen" ],
                M: [ "ein Monat", "einem Monat" ],
                MM: [ number + " Monate", number + " Monaten" ],
                y: [ "ein Jahr", "einem Jahr" ],
                yy: [ number + " Jahre", number + " Jahren" ]
            };
            return withoutSuffix ? format[key][0] : format[key][1];
        }
        return moment.defineLocale("de", {
            months: "Januar_Februar_M盲rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
            monthsShort: "Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
            weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
            weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
            weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Heute um] LT [Uhr]",
                sameElse: "L",
                nextDay: "[Morgen um] LT [Uhr]",
                nextWeek: "dddd [um] LT [Uhr]",
                lastDay: "[Gestern um] LT [Uhr]",
                lastWeek: "[letzten] dddd [um] LT [Uhr]"
            },
            relativeTime: {
                future: "in %s",
                past: "vor %s",
                s: "ein paar Sekunden",
                m: processRelativeTime,
                mm: "%d Minuten",
                h: processRelativeTime,
                hh: "%d Stunden",
                d: processRelativeTime,
                dd: processRelativeTime,
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("el", {
            monthsNominativeEl: "螜伪谓慰蠀维蟻喂慰蟼_桅蔚尾蟻慰蠀维蟻喂慰蟼_螠维蟻蟿喂慰蟼_螒蟺蟻委位喂慰蟼_螠维喂慰蟼_螜慰蠉谓喂慰蟼_螜慰蠉位喂慰蟼_螒蠉纬慰蠀蟽蟿慰蟼_危蔚蟺蟿苇渭尾蟻喂慰蟼_螣魏蟿蠋尾蟻喂慰蟼_螡慰苇渭尾蟻喂慰蟼_螖蔚魏苇渭尾蟻喂慰蟼".split("_"),
            monthsGenitiveEl: "螜伪谓慰蠀伪蟻委慰蠀_桅蔚尾蟻慰蠀伪蟻委慰蠀_螠伪蟻蟿委慰蠀_螒蟺蟻喂位委慰蠀_螠伪螑慰蠀_螜慰蠀谓委慰蠀_螜慰蠀位委慰蠀_螒蠀纬慰蠉蟽蟿慰蠀_危蔚蟺蟿蔚渭尾蟻委慰蠀_螣魏蟿蠅尾蟻委慰蠀_螡慰蔚渭尾蟻委慰蠀_螖蔚魏蔚渭尾蟻委慰蠀".split("_"),
            months: function(momentToFormat, format) {
                if (/D/.test(format.substring(0, format.indexOf("MMMM")))) {
                    return this._monthsGenitiveEl[momentToFormat.month()];
                } else {
                    return this._monthsNominativeEl[momentToFormat.month()];
                }
            },
            monthsShort: "螜伪谓_桅蔚尾_螠伪蟻_螒蟺蟻_螠伪蠆_螜慰蠀谓_螜慰蠀位_螒蠀纬_危蔚蟺_螣魏蟿_螡慰蔚_螖蔚魏".split("_"),
            weekdays: "螝蠀蟻喂伪魏萎_螖蔚蠀蟿苇蟻伪_韦蟻委蟿畏_韦蔚蟿维蟻蟿畏_螤苇渭蟺蟿畏_螤伪蟻伪蟽魏蔚蠀萎_危维尾尾伪蟿慰".split("_"),
            weekdaysShort: "螝蠀蟻_螖蔚蠀_韦蟻喂_韦蔚蟿_螤蔚渭_螤伪蟻_危伪尾".split("_"),
            weekdaysMin: "螝蠀_螖蔚_韦蟻_韦蔚_螤蔚_螤伪_危伪".split("_"),
            meridiem: function(hours, minutes, isLower) {
                if (hours > 11) {
                    return isLower ? "渭渭" : "螠螠";
                } else {
                    return isLower ? "蟺渭" : "螤螠";
                }
            },
            isPM: function(input) {
                return (input + "").toLowerCase()[0] === "渭";
            },
            meridiemParse: /[螤螠]\.?螠?\.?/i,
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendarEl: {
                sameDay: "[危萎渭蔚蟻伪 {}] LT",
                nextDay: "[螒蠉蟻喂慰 {}] LT",
                nextWeek: "dddd [{}] LT",
                lastDay: "[围胃蔚蟼 {}] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 6:
                        return "[蟿慰 蟺蟻慰畏纬慰蠉渭蔚谓慰] dddd [{}] LT";

                      default:
                        return "[蟿畏谓 蟺蟻慰畏纬慰蠉渭蔚谓畏] dddd [{}] LT";
                    }
                },
                sameElse: "L"
            },
            calendar: function(key, mom) {
                var output = this._calendarEl[key], hours = mom && mom.hours();
                if (typeof output === "function") {
                    output = output.apply(mom);
                }
                return output.replace("{}", hours % 12 === 1 ? "蟽蟿畏" : "蟽蟿喂蟼");
            },
            relativeTime: {
                future: "蟽蔚 %s",
                past: "%s 蟺蟻喂谓",
                s: "位委纬伪 未蔚蠀蟿蔚蟻蠈位蔚蟺蟿伪",
                m: "苇谓伪 位蔚蟺蟿蠈",
                mm: "%d 位蔚蟺蟿维",
                h: "渭委伪 蠋蟻伪",
                hh: "%d 蠋蟻蔚蟼",
                d: "渭委伪 渭苇蟻伪",
                dd: "%d 渭苇蟻蔚蟼",
                M: "苇谓伪蟼 渭萎谓伪蟼",
                MM: "%d 渭萎谓蔚蟼",
                y: "苇谓伪蟼 蠂蟻蠈谓慰蟼",
                yy: "%d 蠂蟻蠈谓喂伪"
            },
            ordinalParse: /\d{1,2}畏/,
            ordinal: "%d畏",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("en-au", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            ordinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function(number) {
                var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                return number + output;
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("en-ca", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "YYYY-MM-DD",
                LL: "D MMMM, YYYY",
                LLL: "D MMMM, YYYY LT",
                LLLL: "dddd, D MMMM, YYYY LT"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            ordinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function(number) {
                var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                return number + output;
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("en-gb", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            ordinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function(number) {
                var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                return number + output;
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("eo", {
            months: "januaro_februaro_marto_aprilo_majo_junio_julio_a怒gusto_septembro_oktobro_novembro_decembro".split("_"),
            monthsShort: "jan_feb_mar_apr_maj_jun_jul_a怒g_sep_okt_nov_dec".split("_"),
            weekdays: "Diman膲o_Lundo_Mardo_Merkredo_拇a怒do_Vendredo_Sabato".split("_"),
            weekdaysShort: "Dim_Lun_Mard_Merk_拇a怒_Ven_Sab".split("_"),
            weekdaysMin: "Di_Lu_Ma_Me_拇a_Ve_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "YYYY-MM-DD",
                LL: "D[-an de] MMMM, YYYY",
                LLL: "D[-an de] MMMM, YYYY LT",
                LLLL: "dddd, [la] D[-an de] MMMM, YYYY LT"
            },
            meridiemParse: /[ap]\.t\.m/i,
            isPM: function(input) {
                return input.charAt(0).toLowerCase() === "p";
            },
            meridiem: function(hours, minutes, isLower) {
                if (hours > 11) {
                    return isLower ? "p.t.m." : "P.T.M.";
                } else {
                    return isLower ? "a.t.m." : "A.T.M.";
                }
            },
            calendar: {
                sameDay: "[Hodia怒 je] LT",
                nextDay: "[Morga怒 je] LT",
                nextWeek: "dddd [je] LT",
                lastDay: "[Hiera怒 je] LT",
                lastWeek: "[pasinta] dddd [je] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "je %s",
                past: "anta怒 %s",
                s: "sekundoj",
                m: "minuto",
                mm: "%d minutoj",
                h: "horo",
                hh: "%d horoj",
                d: "tago",
                dd: "%d tagoj",
                M: "monato",
                MM: "%d monatoj",
                y: "jaro",
                yy: "%d jaroj"
            },
            ordinalParse: /\d{1,2}a/,
            ordinal: "%da",
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_");
        return moment.defineLocale("es", {
            months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
            monthsShort: function(m, format) {
                if (/-MMM-/.test(format)) {
                    return monthsShort[m.month()];
                } else {
                    return monthsShortDot[m.month()];
                }
            },
            weekdays: "domingo_lunes_martes_mi茅rcoles_jueves_viernes_s谩bado".split("_"),
            weekdaysShort: "dom._lun._mar._mi茅._jue._vie._s谩b.".split("_"),
            weekdaysMin: "Do_Lu_Ma_Mi_Ju_Vi_S谩".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY LT",
                LLLL: "dddd, D [de] MMMM [de] YYYY LT"
            },
            calendar: {
                sameDay: function() {
                    return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                },
                nextDay: function() {
                    return "[ma帽ana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                },
                nextWeek: function() {
                    return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                },
                lastDay: function() {
                    return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                },
                lastWeek: function() {
                    return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "en %s",
                past: "hace %s",
                s: "unos segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "una hora",
                hh: "%d horas",
                d: "un d铆a",
                dd: "%d d铆as",
                M: "un mes",
                MM: "%d meses",
                y: "un a帽o",
                yy: "%d a帽os"
            },
            ordinalParse: /\d{1,2}潞/,
            ordinal: "%d潞",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                s: [ "m玫ne sekundi", "m玫ni sekund", "paar sekundit" ],
                m: [ "眉he minuti", "眉ks minut" ],
                mm: [ number + " minuti", number + " minutit" ],
                h: [ "眉he tunni", "tund aega", "眉ks tund" ],
                hh: [ number + " tunni", number + " tundi" ],
                d: [ "眉he p盲eva", "眉ks p盲ev" ],
                M: [ "kuu aja", "kuu aega", "眉ks kuu" ],
                MM: [ number + " kuu", number + " kuud" ],
                y: [ "眉he aasta", "aasta", "眉ks aasta" ],
                yy: [ number + " aasta", number + " aastat" ]
            };
            if (withoutSuffix) {
                return format[key][2] ? format[key][2] : format[key][1];
            }
            return isFuture ? format[key][0] : format[key][1];
        }
        return moment.defineLocale("et", {
            months: "jaanuar_veebruar_m盲rts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),
            monthsShort: "jaan_veebr_m盲rts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),
            weekdays: "p眉hap盲ev_esmasp盲ev_teisip盲ev_kolmap盲ev_neljap盲ev_reede_laup盲ev".split("_"),
            weekdaysShort: "P_E_T_K_N_R_L".split("_"),
            weekdaysMin: "P_E_T_K_N_R_L".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[T盲na,] LT",
                nextDay: "[Homme,] LT",
                nextWeek: "[J盲rgmine] dddd LT",
                lastDay: "[Eile,] LT",
                lastWeek: "[Eelmine] dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s p盲rast",
                past: "%s tagasi",
                s: processRelativeTime,
                m: processRelativeTime,
                mm: processRelativeTime,
                h: processRelativeTime,
                hh: processRelativeTime,
                d: processRelativeTime,
                dd: "%d p盲eva",
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("eu", {
            months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),
            monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),
            weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),
            weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"),
            weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "YYYY-MM-DD",
                LL: "YYYY[ko] MMMM[ren] D[a]",
                LLL: "YYYY[ko] MMMM[ren] D[a] LT",
                LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] LT",
                l: "YYYY-M-D",
                ll: "YYYY[ko] MMM D[a]",
                lll: "YYYY[ko] MMM D[a] LT",
                llll: "ddd, YYYY[ko] MMM D[a] LT"
            },
            calendar: {
                sameDay: "[gaur] LT[etan]",
                nextDay: "[bihar] LT[etan]",
                nextWeek: "dddd LT[etan]",
                lastDay: "[atzo] LT[etan]",
                lastWeek: "[aurreko] dddd LT[etan]",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s barru",
                past: "duela %s",
                s: "segundo batzuk",
                m: "minutu bat",
                mm: "%d minutu",
                h: "ordu bat",
                hh: "%d ordu",
                d: "egun bat",
                dd: "%d egun",
                M: "hilabete bat",
                MM: "%d hilabete",
                y: "urte bat",
                yy: "%d urte"
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "郾",
            "2": "鄄",
            "3": "鄢",
            "4": "鄞",
            "5": "鄣",
            "6": "鄱",
            "7": "鄯",
            "8": "鄹",
            "9": "酃",
            "0": "郯"
        }, numberMap = {
            "郾": "1",
            "鄄": "2",
            "鄢": "3",
            "鄞": "4",
            "鄣": "5",
            "鄱": "6",
            "鄯": "7",
            "鄹": "8",
            "酃": "9",
            "郯": "0"
        };
        return moment.defineLocale("fa", {
            months: "跇丕賳賵蹖賴_賮賵乇蹖賴_賲丕乇爻_丌賵乇蹖賱_賲賴_跇賵卅賳_跇賵卅蹖賴_丕賵鬲_爻倬鬲丕賲亘乇_丕讴鬲亘乇_賳賵丕賲亘乇_丿爻丕賲亘乇".split("_"),
            monthsShort: "跇丕賳賵蹖賴_賮賵乇蹖賴_賲丕乇爻_丌賵乇蹖賱_賲賴_跇賵卅賳_跇賵卅蹖賴_丕賵鬲_爻倬鬲丕賲亘乇_丕讴鬲亘乇_賳賵丕賲亘乇_丿爻丕賲亘乇".split("_"),
            weekdays: "蹖讴鈥屫促嗀ㄙ嘷丿賵卮賳亘賴_爻賴鈥屫促嗀ㄙ嘷趩賴丕乇卮賳亘賴_倬賳噩鈥屫促嗀ㄙ嘷噩賲毓賴_卮賳亘賴".split("_"),
            weekdaysShort: "蹖讴鈥屫促嗀ㄙ嘷丿賵卮賳亘賴_爻賴鈥屫促嗀ㄙ嘷趩賴丕乇卮賳亘賴_倬賳噩鈥屫促嗀ㄙ嘷噩賲毓賴_卮賳亘賴".split("_"),
            weekdaysMin: "蹖_丿_爻_趩_倬_噩_卮".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            meridiemParse: /賯亘賱 丕夭 馗賴乇|亘毓丿 丕夭 馗賴乇/,
            isPM: function(input) {
                return /亘毓丿 丕夭 馗賴乇/.test(input);
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 12) {
                    return "賯亘賱 丕夭 馗賴乇";
                } else {
                    return "亘毓丿 丕夭 馗賴乇";
                }
            },
            calendar: {
                sameDay: "[丕賲乇賵夭 爻丕毓鬲] LT",
                nextDay: "[賮乇丿丕 爻丕毓鬲] LT",
                nextWeek: "dddd [爻丕毓鬲] LT",
                lastDay: "[丿蹖乇賵夭 爻丕毓鬲] LT",
                lastWeek: "dddd [倬蹖卮] [爻丕毓鬲] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "丿乇 %s",
                past: "%s 倬蹖卮",
                s: "趩賳丿蹖賳 孬丕賳蹖賴",
                m: "蹖讴 丿賯蹖賯賴",
                mm: "%d 丿賯蹖賯賴",
                h: "蹖讴 爻丕毓鬲",
                hh: "%d 爻丕毓鬲",
                d: "蹖讴 乇賵夭",
                dd: "%d 乇賵夭",
                M: "蹖讴 賲丕賴",
                MM: "%d 賲丕賴",
                y: "蹖讴 爻丕賱",
                yy: "%d 爻丕賱"
            },
            preparse: function(string) {
                return string.replace(/[郯-酃]/g, function(match) {
                    return numberMap[match];
                }).replace(/貙/g, ",");
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                }).replace(/,/g, "貙");
            },
            ordinalParse: /\d{1,2}賲/,
            ordinal: "%d賲",
            week: {
                dow: 6,
                doy: 12
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var numbersPast = "nolla yksi kaksi kolme nelj盲 viisi kuusi seitsem盲n kahdeksan yhdeks盲n".split(" "), numbersFuture = [ "nolla", "yhden", "kahden", "kolmen", "nelj盲n", "viiden", "kuuden", numbersPast[7], numbersPast[8], numbersPast[9] ];
        function translate(number, withoutSuffix, key, isFuture) {
            var result = "";
            switch (key) {
              case "s":
                return isFuture ? "muutaman sekunnin" : "muutama sekunti";

              case "m":
                return isFuture ? "minuutin" : "minuutti";

              case "mm":
                result = isFuture ? "minuutin" : "minuuttia";
                break;

              case "h":
                return isFuture ? "tunnin" : "tunti";

              case "hh":
                result = isFuture ? "tunnin" : "tuntia";
                break;

              case "d":
                return isFuture ? "p盲iv盲n" : "p盲iv盲";

              case "dd":
                result = isFuture ? "p盲iv盲n" : "p盲iv盲盲";
                break;

              case "M":
                return isFuture ? "kuukauden" : "kuukausi";

              case "MM":
                result = isFuture ? "kuukauden" : "kuukautta";
                break;

              case "y":
                return isFuture ? "vuoden" : "vuosi";

              case "yy":
                result = isFuture ? "vuoden" : "vuotta";
                break;
            }
            result = verbalNumber(number, isFuture) + " " + result;
            return result;
        }
        function verbalNumber(number, isFuture) {
            return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
        }
        return moment.defineLocale("fi", {
            months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kes盲kuu_hein盲kuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),
            monthsShort: "tammi_helmi_maalis_huhti_touko_kes盲_hein盲_elo_syys_loka_marras_joulu".split("_"),
            weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),
            weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"),
            weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD.MM.YYYY",
                LL: "Do MMMM[ta] YYYY",
                LLL: "Do MMMM[ta] YYYY, [klo] LT",
                LLLL: "dddd, Do MMMM[ta] YYYY, [klo] LT",
                l: "D.M.YYYY",
                ll: "Do MMM YYYY",
                lll: "Do MMM YYYY, [klo] LT",
                llll: "ddd, Do MMM YYYY, [klo] LT"
            },
            calendar: {
                sameDay: "[t盲n盲盲n] [klo] LT",
                nextDay: "[huomenna] [klo] LT",
                nextWeek: "dddd [klo] LT",
                lastDay: "[eilen] [klo] LT",
                lastWeek: "[viime] dddd[na] [klo] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s p盲盲st盲",
                past: "%s sitten",
                s: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("fo", {
            months: "januar_februar_mars_apr铆l_mai_juni_juli_august_september_oktober_november_desember".split("_"),
            monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
            weekdays: "sunnudagur_m谩nadagur_t媒sdagur_mikudagur_h贸sdagur_fr铆ggjadagur_leygardagur".split("_"),
            weekdaysShort: "sun_m谩n_t媒s_mik_h贸s_fr铆_ley".split("_"),
            weekdaysMin: "su_m谩_t媒_mi_h贸_fr_le".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D. MMMM, YYYY LT"
            },
            calendar: {
                sameDay: "[脥 dag kl.] LT",
                nextDay: "[脥 morgin kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[脥 gj谩r kl.] LT",
                lastWeek: "[s铆冒stu] dddd [kl] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "um %s",
                past: "%s s铆冒ani",
                s: "f谩 sekund",
                m: "ein minutt",
                mm: "%d minuttir",
                h: "ein t铆mi",
                hh: "%d t铆mar",
                d: "ein dagur",
                dd: "%d dagar",
                M: "ein m谩na冒i",
                MM: "%d m谩na冒ir",
                y: "eitt 谩r",
                yy: "%d 谩r"
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("fr-ca", {
            months: "janvier_f茅vrier_mars_avril_mai_juin_juillet_ao没t_septembre_octobre_novembre_d茅cembre".split("_"),
            monthsShort: "janv._f茅vr._mars_avr._mai_juin_juil._ao没t_sept._oct._nov._d茅c.".split("_"),
            weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
            weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
            weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "YYYY-MM-DD",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Aujourd'hui 脿] LT",
                nextDay: "[Demain 脿] LT",
                nextWeek: "dddd [脿] LT",
                lastDay: "[Hier 脿] LT",
                lastWeek: "dddd [dernier 脿] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dans %s",
                past: "il y a %s",
                s: "quelques secondes",
                m: "une minute",
                mm: "%d minutes",
                h: "une heure",
                hh: "%d heures",
                d: "un jour",
                dd: "%d jours",
                M: "un mois",
                MM: "%d mois",
                y: "un an",
                yy: "%d ans"
            },
            ordinalParse: /\d{1,2}(er|)/,
            ordinal: function(number) {
                return number + (number === 1 ? "er" : "");
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("fr", {
            months: "janvier_f茅vrier_mars_avril_mai_juin_juillet_ao没t_septembre_octobre_novembre_d茅cembre".split("_"),
            monthsShort: "janv._f茅vr._mars_avr._mai_juin_juil._ao没t_sept._oct._nov._d茅c.".split("_"),
            weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
            weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
            weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Aujourd'hui 脿] LT",
                nextDay: "[Demain 脿] LT",
                nextWeek: "dddd [脿] LT",
                lastDay: "[Hier 脿] LT",
                lastWeek: "dddd [dernier 脿] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dans %s",
                past: "il y a %s",
                s: "quelques secondes",
                m: "une minute",
                mm: "%d minutes",
                h: "une heure",
                hh: "%d heures",
                d: "un jour",
                dd: "%d jours",
                M: "un mois",
                MM: "%d mois",
                y: "un an",
                yy: "%d ans"
            },
            ordinalParse: /\d{1,2}(er|)/,
            ordinal: function(number) {
                return number + (number === 1 ? "er" : "");
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var monthsShortWithDots = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
        return moment.defineLocale("fy", {
            months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"),
            monthsShort: function(m, format) {
                if (/-MMM-/.test(format)) {
                    return monthsShortWithoutDots[m.month()];
                } else {
                    return monthsShortWithDots[m.month()];
                }
            },
            weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"),
            weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"),
            weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD-MM-YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[hjoed om] LT",
                nextDay: "[moarn om] LT",
                nextWeek: "dddd [om] LT",
                lastDay: "[juster om] LT",
                lastWeek: "[么fr没ne] dddd [om] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "oer %s",
                past: "%s lyn",
                s: "in pear sekonden",
                m: "ien min煤t",
                mm: "%d minuten",
                h: "ien oere",
                hh: "%d oeren",
                d: "ien dei",
                dd: "%d dagen",
                M: "ien moanne",
                MM: "%d moannen",
                y: "ien jier",
                yy: "%d jierren"
            },
            ordinalParse: /\d{1,2}(ste|de)/,
            ordinal: function(number) {
                return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("gl", {
            months: "Xaneiro_Febreiro_Marzo_Abril_Maio_Xu帽o_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro".split("_"),
            monthsShort: "Xan._Feb._Mar._Abr._Mai._Xu帽._Xul._Ago._Set._Out._Nov._Dec.".split("_"),
            weekdays: "Domingo_Luns_Martes_M茅rcores_Xoves_Venres_S谩bado".split("_"),
            weekdaysShort: "Dom._Lun._Mar._M茅r._Xov._Ven._S谩b.".split("_"),
            weekdaysMin: "Do_Lu_Ma_M茅_Xo_Ve_S谩".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: function() {
                    return "[hoxe " + (this.hours() !== 1 ? "谩s" : "谩") + "] LT";
                },
                nextDay: function() {
                    return "[ma帽谩 " + (this.hours() !== 1 ? "谩s" : "谩") + "] LT";
                },
                nextWeek: function() {
                    return "dddd [" + (this.hours() !== 1 ? "谩s" : "a") + "] LT";
                },
                lastDay: function() {
                    return "[onte " + (this.hours() !== 1 ? "谩" : "a") + "] LT";
                },
                lastWeek: function() {
                    return "[o] dddd [pasado " + (this.hours() !== 1 ? "谩s" : "a") + "] LT";
                },
                sameElse: "L"
            },
            relativeTime: {
                future: function(str) {
                    if (str === "uns segundos") {
                        return "nuns segundos";
                    }
                    return "en " + str;
                },
                past: "hai %s",
                s: "uns segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "unha hora",
                hh: "%d horas",
                d: "un d铆a",
                dd: "%d d铆as",
                M: "un mes",
                MM: "%d meses",
                y: "un ano",
                yy: "%d anos"
            },
            ordinalParse: /\d{1,2}潞/,
            ordinal: "%d潞",
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("he", {
            months: "讬谞讜讗专_驻讘专讜讗专_诪专抓_讗驻专讬诇_诪讗讬_讬讜谞讬_讬讜诇讬_讗讜讙讜住讟_住驻讟诪讘专_讗讜拽讟讜讘专_谞讜讘诪讘专_讚爪诪讘专".split("_"),
            monthsShort: "讬谞讜壮_驻讘专壮_诪专抓_讗驻专壮_诪讗讬_讬讜谞讬_讬讜诇讬_讗讜讙壮_住驻讟壮_讗讜拽壮_谞讜讘壮_讚爪诪壮".split("_"),
            weekdays: "专讗砖讜谉_砖谞讬_砖诇讬砖讬_专讘讬注讬_讞诪讬砖讬_砖讬砖讬_砖讘转".split("_"),
            weekdaysShort: "讗壮_讘壮_讙壮_讚壮_讛壮_讜壮_砖壮".split("_"),
            weekdaysMin: "讗_讘_讙_讚_讛_讜_砖".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D [讘]MMMM YYYY",
                LLL: "D [讘]MMMM YYYY LT",
                LLLL: "dddd, D [讘]MMMM YYYY LT",
                l: "D/M/YYYY",
                ll: "D MMM YYYY",
                lll: "D MMM YYYY LT",
                llll: "ddd, D MMM YYYY LT"
            },
            calendar: {
                sameDay: "[讛讬讜诐 讘志]LT",
                nextDay: "[诪讞专 讘志]LT",
                nextWeek: "dddd [讘砖注讛] LT",
                lastDay: "[讗转诪讜诇 讘志]LT",
                lastWeek: "[讘讬讜诐] dddd [讛讗讞专讜谉 讘砖注讛] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "讘注讜讚 %s",
                past: "诇驻谞讬 %s",
                s: "诪住驻专 砖谞讬讜转",
                m: "讚拽讛",
                mm: "%d 讚拽讜转",
                h: "砖注讛",
                hh: function(number) {
                    if (number === 2) {
                        return "砖注转讬讬诐";
                    }
                    return number + " 砖注讜转";
                },
                d: "讬讜诐",
                dd: function(number) {
                    if (number === 2) {
                        return "讬讜诪讬讬诐";
                    }
                    return number + " 讬诪讬诐";
                },
                M: "讞讜讚砖",
                MM: function(number) {
                    if (number === 2) {
                        return "讞讜讚砖讬讬诐";
                    }
                    return number + " 讞讜讚砖讬诐";
                },
                y: "砖谞讛",
                yy: function(number) {
                    if (number === 2) {
                        return "砖谞转讬讬诐";
                    } else if (number % 10 === 0 && number !== 10) {
                        return number + " 砖谞讛";
                    }
                    return number + " 砖谞讬诐";
                }
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "啷�",
            "2": "啷�",
            "3": "啷�",
            "4": "啷�",
            "5": "啷�",
            "6": "啷�",
            "7": "啷�",
            "8": "啷�",
            "9": "啷�",
            "0": "啷�"
        }, numberMap = {
            "啷�": "1",
            "啷�": "2",
            "啷�": "3",
            "啷�": "4",
            "啷�": "5",
            "啷�": "6",
            "啷�": "7",
            "啷�": "8",
            "啷�": "9",
            "啷�": "0"
        };
        return moment.defineLocale("hi", {
            months: "啶溹え啶掂ぐ啷€_啶ぜ啶班さ啶班_啶ぞ啶班啶歘啶呧お啷嵿ぐ啷堗げ_啶_啶溹啶╛啶溹啶侧ぞ啶坃啶呧啶膏啶啶膏た啶むぎ啷嵿が啶癬啶呧啷嵿啷傕が啶癬啶ㄠさ啶啶ぐ_啶︵た啶膏ぎ啷嵿が啶�".split("_"),
            monthsShort: "啶溹え._啶ぜ啶�._啶ぞ啶班啶歘啶呧お啷嵿ぐ啷�._啶_啶溹啶╛啶溹啶�._啶呧._啶膏た啶�._啶呧啷嵿啷�._啶ㄠさ._啶︵た啶�.".split("_"),
            weekdays: "啶班さ啶苦さ啶距ぐ_啶膏啶さ啶距ぐ_啶啶椸げ啶掂ぞ啶癬啶啶оさ啶距ぐ_啶椸啶班啶掂ぞ啶癬啶多啶曕啶班さ啶距ぐ_啶多え啶苦さ啶距ぐ".split("_"),
            weekdaysShort: "啶班さ啶縚啶膏啶甠啶啶椸げ_啶啶啶椸啶班_啶多啶曕啶癬啶多え啶�".split("_"),
            weekdaysMin: "啶癬啶膏_啶_啶_啶椸_啶多_啶�".split("_"),
            longDateFormat: {
                LT: "A h:mm 啶啷�",
                LTS: "A h:mm:ss 啶啷�",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, LT",
                LLLL: "dddd, D MMMM YYYY, LT"
            },
            calendar: {
                sameDay: "[啶嗋] LT",
                nextDay: "[啶曕げ] LT",
                nextWeek: "dddd, LT",
                lastDay: "[啶曕げ] LT",
                lastWeek: "[啶た啶涏げ啷嘳 dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s 啶啶�",
                past: "%s 啶す啶侧",
                s: "啶曕啶� 啶灌 啶曕啶粪ぃ",
                m: "啶忇 啶た啶ㄠ",
                mm: "%d 啶た啶ㄠ",
                h: "啶忇 啶樴啶熰ぞ",
                hh: "%d 啶樴啶熰",
                d: "啶忇 啶︵た啶�",
                dd: "%d 啶︵た啶�",
                M: "啶忇 啶す啷€啶ㄠ",
                MM: "%d 啶す啷€啶ㄠ",
                y: "啶忇 啶掂ぐ啷嵿し",
                yy: "%d 啶掂ぐ啷嵿し"
            },
            preparse: function(string) {
                return string.replace(/[啷оエ啷┼オ啷ガ啷ギ啷ウ]/g, function(match) {
                    return numberMap[match];
                });
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                });
            },
            meridiemParse: /啶班ぞ啶啶膏啶す|啶︵啶す啶皘啶多ぞ啶�/,
            meridiemHour: function(hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === "啶班ぞ啶�") {
                    return hour < 4 ? hour : hour + 12;
                } else if (meridiem === "啶膏啶す") {
                    return hour;
                } else if (meridiem === "啶︵啶す啶�") {
                    return hour >= 10 ? hour : hour + 12;
                } else if (meridiem === "啶多ぞ啶�") {
                    return hour + 12;
                }
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "啶班ぞ啶�";
                } else if (hour < 10) {
                    return "啶膏啶す";
                } else if (hour < 17) {
                    return "啶︵啶す啶�";
                } else if (hour < 20) {
                    return "啶多ぞ啶�";
                } else {
                    return "啶班ぞ啶�";
                }
            },
            week: {
                dow: 0,
                doy: 6
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function translate(number, withoutSuffix, key) {
            var result = number + " ";
            switch (key) {
              case "m":
                return withoutSuffix ? "jedna minuta" : "jedne minute";

              case "mm":
                if (number === 1) {
                    result += "minuta";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "minute";
                } else {
                    result += "minuta";
                }
                return result;

              case "h":
                return withoutSuffix ? "jedan sat" : "jednog sata";

              case "hh":
                if (number === 1) {
                    result += "sat";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "sata";
                } else {
                    result += "sati";
                }
                return result;

              case "dd":
                if (number === 1) {
                    result += "dan";
                } else {
                    result += "dana";
                }
                return result;

              case "MM":
                if (number === 1) {
                    result += "mjesec";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "mjeseca";
                } else {
                    result += "mjeseci";
                }
                return result;

              case "yy":
                if (number === 1) {
                    result += "godina";
                } else if (number === 2 || number === 3 || number === 4) {
                    result += "godine";
                } else {
                    result += "godina";
                }
                return result;
            }
        }
        return moment.defineLocale("hr", {
            months: "sje膷anj_velja膷a_o啪ujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_"),
            monthsShort: "sje._vel._o啪u._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),
            weekdays: "nedjelja_ponedjeljak_utorak_srijeda_膷etvrtak_petak_subota".split("_"),
            weekdaysShort: "ned._pon._uto._sri._膷et._pet._sub.".split("_"),
            weekdaysMin: "ne_po_ut_sr_膷e_pe_su".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD. MM. YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[danas u] LT",
                nextDay: "[sutra u] LT",
                nextWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[u] [nedjelju] [u] LT";

                      case 3:
                        return "[u] [srijedu] [u] LT";

                      case 6:
                        return "[u] [subotu] [u] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[u] dddd [u] LT";
                    }
                },
                lastDay: "[ju膷er u] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                      case 3:
                        return "[pro拧lu] dddd [u] LT";

                      case 6:
                        return "[pro拧le] [subote] [u] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[pro拧li] dddd [u] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "prije %s",
                s: "par sekundi",
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: "dan",
                dd: translate,
                M: "mjesec",
                MM: translate,
                y: "godinu",
                yy: translate
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var weekEndings = "vas谩rnap h茅tf艖n kedden szerd谩n cs眉t枚rt枚k枚n p茅nteken szombaton".split(" ");
        function translate(number, withoutSuffix, key, isFuture) {
            var num = number, suffix;
            switch (key) {
              case "s":
                return isFuture || withoutSuffix ? "n茅h谩ny m谩sodperc" : "n茅h谩ny m谩sodperce";

              case "m":
                return "egy" + (isFuture || withoutSuffix ? " perc" : " perce");

              case "mm":
                return num + (isFuture || withoutSuffix ? " perc" : " perce");

              case "h":
                return "egy" + (isFuture || withoutSuffix ? " 贸ra" : " 贸r谩ja");

              case "hh":
                return num + (isFuture || withoutSuffix ? " 贸ra" : " 贸r谩ja");

              case "d":
                return "egy" + (isFuture || withoutSuffix ? " nap" : " napja");

              case "dd":
                return num + (isFuture || withoutSuffix ? " nap" : " napja");

              case "M":
                return "egy" + (isFuture || withoutSuffix ? " h贸nap" : " h贸napja");

              case "MM":
                return num + (isFuture || withoutSuffix ? " h贸nap" : " h贸napja");

              case "y":
                return "egy" + (isFuture || withoutSuffix ? " 茅v" : " 茅ve");

              case "yy":
                return num + (isFuture || withoutSuffix ? " 茅v" : " 茅ve");
            }
            return "";
        }
        function week(isFuture) {
            return (isFuture ? "" : "[m煤lt] ") + "[" + weekEndings[this.day()] + "] LT[-kor]";
        }
        return moment.defineLocale("hu", {
            months: "janu谩r_febru谩r_m谩rcius_谩prilis_m谩jus_j煤nius_j煤lius_augusztus_szeptember_okt贸ber_november_december".split("_"),
            monthsShort: "jan_feb_m谩rc_谩pr_m谩j_j煤n_j煤l_aug_szept_okt_nov_dec".split("_"),
            weekdays: "vas谩rnap_h茅tf艖_kedd_szerda_cs眉t枚rt枚k_p茅ntek_szombat".split("_"),
            weekdaysShort: "vas_h茅t_kedd_sze_cs眉t_p茅n_szo".split("_"),
            weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "YYYY.MM.DD.",
                LL: "YYYY. MMMM D.",
                LLL: "YYYY. MMMM D., LT",
                LLLL: "YYYY. MMMM D., dddd LT"
            },
            meridiemParse: /de|du/i,
            isPM: function(input) {
                return input.charAt(1).toLowerCase() === "u";
            },
            meridiem: function(hours, minutes, isLower) {
                if (hours < 12) {
                    return isLower === true ? "de" : "DE";
                } else {
                    return isLower === true ? "du" : "DU";
                }
            },
            calendar: {
                sameDay: "[ma] LT[-kor]",
                nextDay: "[holnap] LT[-kor]",
                nextWeek: function() {
                    return week.call(this, true);
                },
                lastDay: "[tegnap] LT[-kor]",
                lastWeek: function() {
                    return week.call(this, false);
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "%s m煤lva",
                past: "%s",
                s: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function monthsCaseReplace(m, format) {
            var months = {
                nominative: "瞻崭謧斩站铡謤_謨榨湛謤站铡謤_沾铡謤湛_铡蘸謤斋宅_沾铡盏斋战_瞻崭謧斩斋战_瞻崭謧宅斋战_謪眨崭战湛崭战_战榨蘸湛榨沾闸榨謤_瞻崭寨湛榨沾闸榨謤_斩崭盏榨沾闸榨謤_栅榨寨湛榨沾闸榨謤".split("_"),
                accusative: "瞻崭謧斩站铡謤斋_謨榨湛謤站铡謤斋_沾铡謤湛斋_铡蘸謤斋宅斋_沾铡盏斋战斋_瞻崭謧斩斋战斋_瞻崭謧宅斋战斋_謪眨崭战湛崭战斋_战榨蘸湛榨沾闸榨謤斋_瞻崭寨湛榨沾闸榨謤斋_斩崭盏榨沾闸榨謤斋_栅榨寨湛榨沾闸榨謤斋".split("_")
            }, nounCase = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(format) ? "accusative" : "nominative";
            return months[nounCase][m.month()];
        }
        function monthsShortCaseReplace(m, format) {
            var monthsShort = "瞻斩站_謨湛謤_沾謤湛_铡蘸謤_沾盏战_瞻斩战_瞻宅战_謪眨战_战蘸湛_瞻寨湛_斩沾闸_栅寨湛".split("_");
            return monthsShort[m.month()];
        }
        function weekdaysCaseReplace(m, format) {
            var weekdays = "寨斋謤铡寨斋_榨謤寨崭謧辗铡闸诈斋_榨謤榨謩辗铡闸诈斋_展崭謤榨謩辗铡闸诈斋_瞻斋斩眨辗铡闸诈斋_崭謧謤闸铡诈_辗铡闸铡诈".split("_");
            return weekdays[m.day()];
        }
        return moment.defineLocale("hy-am", {
            months: monthsCaseReplace,
            monthsShort: monthsShortCaseReplace,
            weekdays: weekdaysCaseReplace,
            weekdaysShort: "寨謤寨_榨謤寨_榨謤謩_展謤謩_瞻斩眨_崭謧謤闸_辗闸诈".split("_"),
            weekdaysMin: "寨謤寨_榨謤寨_榨謤謩_展謤謩_瞻斩眨_崭謧謤闸_辗闸诈".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY 诈.",
                LLL: "D MMMM YYYY 诈., LT",
                LLLL: "dddd, D MMMM YYYY 诈., LT"
            },
            calendar: {
                sameDay: "[铡盏战謪謤] LT",
                nextDay: "[站铡詹炸] LT",
                lastDay: "[榨謤榨寨] LT",
                nextWeek: function() {
                    return "dddd [謪謤炸 摘铡沾炸] LT";
                },
                lastWeek: function() {
                    return "[铡斩謥铡债] dddd [謪謤炸 摘铡沾炸] LT";
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "%s 瞻榨湛崭",
                past: "%s 铡占铡栈",
                s: "沾斋 謩铡斩斋 站铡盏謤寨盏铡斩",
                m: "謤崭蘸榨",
                mm: "%d 謤崭蘸榨",
                h: "摘铡沾",
                hh: "%d 摘铡沾",
                d: "謪謤",
                dd: "%d 謪謤",
                M: "铡沾斋战",
                MM: "%d 铡沾斋战",
                y: "湛铡謤斋",
                yy: "%d 湛铡謤斋"
            },
            meridiemParse: /眨斋辗榨謤站铡|铡占铡站崭湛站铡|謥榨謤榨寨站铡|榨謤榨寨崭盏铡斩/,
            isPM: function(input) {
                return /^(謥榨謤榨寨站铡|榨謤榨寨崭盏铡斩)$/.test(input);
            },
            meridiem: function(hour) {
                if (hour < 4) {
                    return "眨斋辗榨謤站铡";
                } else if (hour < 12) {
                    return "铡占铡站崭湛站铡";
                } else if (hour < 17) {
                    return "謥榨謤榨寨站铡";
                } else {
                    return "榨謤榨寨崭盏铡斩";
                }
            },
            ordinalParse: /\d{1,2}|\d{1,2}-(斋斩|謤栅)/,
            ordinal: function(number, period) {
                switch (period) {
                  case "DDD":
                  case "w":
                  case "W":
                  case "DDDo":
                    if (number === 1) {
                        return number + "-斋斩";
                    }
                    return number + "-謤栅";

                  default:
                    return number;
                }
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("id", {
            months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des".split("_"),
            weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
            weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
            weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "LT.ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [pukul] LT",
                LLLL: "dddd, D MMMM YYYY [pukul] LT"
            },
            meridiemParse: /pagi|siang|sore|malam/,
            meridiemHour: function(hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === "pagi") {
                    return hour;
                } else if (meridiem === "siang") {
                    return hour >= 11 ? hour : hour + 12;
                } else if (meridiem === "sore" || meridiem === "malam") {
                    return hour + 12;
                }
            },
            meridiem: function(hours, minutes, isLower) {
                if (hours < 11) {
                    return "pagi";
                } else if (hours < 15) {
                    return "siang";
                } else if (hours < 19) {
                    return "sore";
                } else {
                    return "malam";
                }
            },
            calendar: {
                sameDay: "[Hari ini pukul] LT",
                nextDay: "[Besok pukul] LT",
                nextWeek: "dddd [pukul] LT",
                lastDay: "[Kemarin pukul] LT",
                lastWeek: "dddd [lalu pukul] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dalam %s",
                past: "%s yang lalu",
                s: "beberapa detik",
                m: "semenit",
                mm: "%d menit",
                h: "sejam",
                hh: "%d jam",
                d: "sehari",
                dd: "%d hari",
                M: "sebulan",
                MM: "%d bulan",
                y: "setahun",
                yy: "%d tahun"
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function plural(n) {
            if (n % 100 === 11) {
                return true;
            } else if (n % 10 === 1) {
                return false;
            }
            return true;
        }
        function translate(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            switch (key) {
              case "s":
                return withoutSuffix || isFuture ? "nokkrar sek煤ndur" : "nokkrum sek煤ndum";

              case "m":
                return withoutSuffix ? "m铆n煤ta" : "m铆n煤tu";

              case "mm":
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? "m铆n煤tur" : "m铆n煤tum");
                } else if (withoutSuffix) {
                    return result + "m铆n煤ta";
                }
                return result + "m铆n煤tu";

              case "hh":
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? "klukkustundir" : "klukkustundum");
                }
                return result + "klukkustund";

              case "d":
                if (withoutSuffix) {
                    return "dagur";
                }
                return isFuture ? "dag" : "degi";

              case "dd":
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + "dagar";
                    }
                    return result + (isFuture ? "daga" : "d枚gum");
                } else if (withoutSuffix) {
                    return result + "dagur";
                }
                return result + (isFuture ? "dag" : "degi");

              case "M":
                if (withoutSuffix) {
                    return "m谩nu冒ur";
                }
                return isFuture ? "m谩nu冒" : "m谩nu冒i";

              case "MM":
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + "m谩nu冒ir";
                    }
                    return result + (isFuture ? "m谩nu冒i" : "m谩nu冒um");
                } else if (withoutSuffix) {
                    return result + "m谩nu冒ur";
                }
                return result + (isFuture ? "m谩nu冒" : "m谩nu冒i");

              case "y":
                return withoutSuffix || isFuture ? "谩r" : "谩ri";

              case "yy":
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? "谩r" : "谩rum");
                }
                return result + (withoutSuffix || isFuture ? "谩r" : "谩ri");
            }
        }
        return moment.defineLocale("is", {
            months: "jan煤ar_febr煤ar_mars_apr铆l_ma铆_j煤n铆_j煤l铆_谩g煤st_september_okt贸ber_n贸vember_desember".split("_"),
            monthsShort: "jan_feb_mar_apr_ma铆_j煤n_j煤l_谩g煤_sep_okt_n贸v_des".split("_"),
            weekdays: "sunnudagur_m谩nudagur_镁ri冒judagur_mi冒vikudagur_fimmtudagur_f枚studagur_laugardagur".split("_"),
            weekdaysShort: "sun_m谩n_镁ri_mi冒_fim_f枚s_lau".split("_"),
            weekdaysMin: "Su_M谩_脼r_Mi_Fi_F枚_La".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY [kl.] LT",
                LLLL: "dddd, D. MMMM YYYY [kl.] LT"
            },
            calendar: {
                sameDay: "[铆 dag kl.] LT",
                nextDay: "[谩 morgun kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[铆 g忙r kl.] LT",
                lastWeek: "[s铆冒asta] dddd [kl.] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "eftir %s",
                past: "fyrir %s s铆冒an",
                s: translate,
                m: translate,
                mm: translate,
                h: "klukkustund",
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("it", {
            months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
            monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
            weekdays: "Domenica_Luned矛_Marted矛_Mercoled矛_Gioved矛_Venerd矛_Sabato".split("_"),
            weekdaysShort: "Dom_Lun_Mar_Mer_Gio_Ven_Sab".split("_"),
            weekdaysMin: "D_L_Ma_Me_G_V_S".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Oggi alle] LT",
                nextDay: "[Domani alle] LT",
                nextWeek: "dddd [alle] LT",
                lastDay: "[Ieri alle] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[la scorsa] dddd [alle] LT";

                      default:
                        return "[lo scorso] dddd [alle] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: function(s) {
                    return (/^[0-9].+$/.test(s) ? "tra" : "in") + " " + s;
                },
                past: "%s fa",
                s: "alcuni secondi",
                m: "un minuto",
                mm: "%d minuti",
                h: "un'ora",
                hh: "%d ore",
                d: "un giorno",
                dd: "%d giorni",
                M: "un mese",
                MM: "%d mesi",
                y: "un anno",
                yy: "%d anni"
            },
            ordinalParse: /\d{1,2}潞/,
            ordinal: "%d潞",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("ja", {
            months: "1鏈坃2鏈坃3鏈坃4鏈坃5鏈坃6鏈坃7鏈坃8鏈坃9鏈坃10鏈坃11鏈坃12鏈�".split("_"),
            monthsShort: "1鏈坃2鏈坃3鏈坃4鏈坃5鏈坃6鏈坃7鏈坃8鏈坃9鏈坃10鏈坃11鏈坃12鏈�".split("_"),
            weekdays: "鏃ユ洔鏃鏈堟洔鏃鐏洔鏃姘存洔鏃鏈ㄦ洔鏃閲戞洔鏃鍦熸洔鏃�".split("_"),
            weekdaysShort: "鏃鏈坃鐏玙姘確鏈╛閲慱鍦�".split("_"),
            weekdaysMin: "鏃鏈坃鐏玙姘確鏈╛閲慱鍦�".split("_"),
            longDateFormat: {
                LT: "Ah鏅俶鍒�",
                LTS: "LTs绉�",
                L: "YYYY/MM/DD",
                LL: "YYYY骞碝鏈圖鏃�",
                LLL: "YYYY骞碝鏈圖鏃T",
                LLLL: "YYYY骞碝鏈圖鏃T dddd"
            },
            meridiemParse: /鍗堝墠|鍗堝緦/i,
            isPM: function(input) {
                return input === "鍗堝緦";
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 12) {
                    return "鍗堝墠";
                } else {
                    return "鍗堝緦";
                }
            },
            calendar: {
                sameDay: "[浠婃棩] LT",
                nextDay: "[鏄庢棩] LT",
                nextWeek: "[鏉ラ€盷dddd LT",
                lastDay: "[鏄ㄦ棩] LT",
                lastWeek: "[鍓嶉€盷dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s寰�",
                past: "%s鍓�",
                s: "鏁扮",
                m: "1鍒�",
                mm: "%d鍒�",
                h: "1鏅傞枔",
                hh: "%d鏅傞枔",
                d: "1鏃�",
                dd: "%d鏃�",
                M: "1銉舵湀",
                MM: "%d銉舵湀",
                y: "1骞�",
                yy: "%d骞�"
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function monthsCaseReplace(m, format) {
            var months = {
                nominative: "醿樶儛醿溼儠醿愥儬醿榑醿椺償醿戓償醿犪儠醿愥儦醿榑醿涐儛醿犪儮醿榑醿愥優醿犪儤醿氠儤_醿涐儛醿樶儭醿榑醿樶儠醿溼儤醿♂儤_醿樶儠醿氠儤醿♂儤_醿愥儝醿曖儤醿♂儮醿漘醿♂償醿メ儮醿斸儧醿戓償醿犪儤_醿濁儱醿⑨儩醿涐儜醿斸儬醿榑醿溼儩醿斸儧醿戓償醿犪儤_醿撫償醿欋償醿涐儜醿斸儬醿�".split("_"),
                accusative: "醿樶儛醿溼儠醿愥儬醿醿椺償醿戓償醿犪儠醿愥儦醿醿涐儛醿犪儮醿醿愥優醿犪儤醿氠儤醿醿涐儛醿樶儭醿醿樶儠醿溼儤醿♂儭_醿樶儠醿氠儤醿♂儭_醿愥儝醿曖儤醿♂儮醿醿♂償醿メ儮醿斸儧醿戓償醿犪儭_醿濁儱醿⑨儩醿涐儜醿斸儬醿醿溼儩醿斸儧醿戓償醿犪儭_醿撫償醿欋償醿涐儜醿斸儬醿�".split("_")
            }, nounCase = /D[oD] *MMMM?/.test(format) ? "accusative" : "nominative";
            return months[nounCase][m.month()];
        }
        function weekdaysCaseReplace(m, format) {
            var weekdays = {
                nominative: "醿欋儠醿樶儬醿恄醿濁儬醿ㄡ儛醿戓儛醿椺儤_醿♂儛醿涐儴醿愥儜醿愥儣醿榑醿濁儣醿儴醿愥儜醿愥儣醿榑醿儯醿椺儴醿愥儜醿愥儣醿榑醿炨儛醿犪儛醿♂儥醿斸儠醿榑醿ㄡ儛醿戓儛醿椺儤".split("_"),
                accusative: "醿欋儠醿樶儬醿愥儭_醿濁儬醿ㄡ儛醿戓儛醿椺儭_醿♂儛醿涐儴醿愥儜醿愥儣醿醿濁儣醿儴醿愥儜醿愥儣醿醿儯醿椺儴醿愥儜醿愥儣醿醿炨儛醿犪儛醿♂儥醿斸儠醿醿ㄡ儛醿戓儛醿椺儭".split("_")
            }, nounCase = /(醿儤醿溼儛|醿ㄡ償醿涐儞醿斸儝)/.test(format) ? "accusative" : "nominative";
            return weekdays[nounCase][m.day()];
        }
        return moment.defineLocale("ka", {
            months: monthsCaseReplace,
            monthsShort: "醿樶儛醿淿醿椺償醿慱醿涐儛醿燺醿愥優醿燺醿涐儛醿榑醿樶儠醿淿醿樶儠醿歘醿愥儝醿昣醿♂償醿醿濁儱醿醿溼儩醿擾醿撫償醿�".split("_"),
            weekdays: weekdaysCaseReplace,
            weekdaysShort: "醿欋儠醿榑醿濁儬醿╛醿♂儛醿沖醿濁儣醿甠醿儯醿梍醿炨儛醿燺醿ㄡ儛醿�".split("_"),
            weekdaysMin: "醿欋儠_醿濁儬_醿♂儛_醿濁儣_醿儯_醿炨儛_醿ㄡ儛".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[醿撫儲醿斸儭] LT[-醿栣償]",
                nextDay: "[醿儠醿愥儦] LT[-醿栣償]",
                lastDay: "[醿掅儯醿ㄡ儤醿淽 LT[-醿栣償]",
                nextWeek: "[醿ㄡ償醿涐儞醿斸儝] dddd LT[-醿栣償]",
                lastWeek: "[醿儤醿溼儛] dddd LT-醿栣償",
                sameElse: "L"
            },
            relativeTime: {
                future: function(s) {
                    return /(醿儛醿涐儤|醿儯醿椺儤|醿♂儛醿愥儣醿榺醿償醿氠儤)/.test(s) ? s.replace(/醿�$/, "醿ㄡ儤") : s + "醿ㄡ儤";
                },
                past: function(s) {
                    if (/(醿儛醿涐儤|醿儯醿椺儤|醿♂儛醿愥儣醿榺醿撫儲醿攟醿椺儠醿�)/.test(s)) {
                        return s.replace(/(醿榺醿�)$/, "醿樶儭 醿儤醿�");
                    }
                    if (/醿償醿氠儤/.test(s)) {
                        return s.replace(/醿償醿氠儤$/, "醿儦醿樶儭 醿儤醿�");
                    }
                },
                s: "醿犪儛醿涐儞醿斸儨醿樶儧醿� 醿儛醿涐儤",
                m: "醿儯醿椺儤",
                mm: "%d 醿儯醿椺儤",
                h: "醿♂儛醿愥儣醿�",
                hh: "%d 醿♂儛醿愥儣醿�",
                d: "醿撫儲醿�",
                dd: "%d 醿撫儲醿�",
                M: "醿椺儠醿�",
                MM: "%d 醿椺儠醿�",
                y: "醿償醿氠儤",
                yy: "%d 醿償醿氠儤"
            },
            ordinalParse: /0|1-醿氠儤|醿涐償-\d{1,2}|\d{1,2}-醿�/,
            ordinal: function(number) {
                if (number === 0) {
                    return number;
                }
                if (number === 1) {
                    return number + "-醿氠儤";
                }
                if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) {
                    return "醿涐償-" + number;
                }
                return number + "-醿�";
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("km", {
            months: "釣樶瀫釣氠灦_釣€釣会灅釤掅灄釤坃釣樶灧釣撫灦_釣樶焷釣熱灦_釣п灍釣椺灦_釣樶灧釣愥灮釣撫灦_釣€釣€釤掅瀫釣娽灦_釣熱灨釣犪灦_釣€釣夅煉釣夅灦_釣忈灮釣涐灦_釣溼灧釣呩煉釣嗎灧釣€釣禵釣掅煉釣撫灱".split("_"),
            monthsShort: "釣樶瀫釣氠灦_釣€釣会灅釤掅灄釤坃釣樶灧釣撫灦_釣樶焷釣熱灦_釣п灍釣椺灦_釣樶灧釣愥灮釣撫灦_釣€釣€釤掅瀫釣娽灦_釣熱灨釣犪灦_釣€釣夅煉釣夅灦_釣忈灮釣涐灦_釣溼灧釣呩煉釣嗎灧釣€釣禵釣掅煉釣撫灱".split("_"),
            weekdays: "釣⑨灦釣戓灧釣忈煉釣檁釣呩煇釣撫煉釣慱釣⑨瀯釤掅瀭釣夺灇_釣栣灮釣抇釣栣煉釣氠灎釣熱煉釣斸瀼釣丰煃_釣熱灮釣€釤掅灇_釣熱焻釣氠煃".split("_"),
            weekdaysShort: "釣⑨灦釣戓灧釣忈煉釣檁釣呩煇釣撫煉釣慱釣⑨瀯釤掅瀭釣夺灇_釣栣灮釣抇釣栣煉釣氠灎釣熱煉釣斸瀼釣丰煃_釣熱灮釣€釤掅灇_釣熱焻釣氠煃".split("_"),
            weekdaysMin: "釣⑨灦釣戓灧釣忈煉釣檁釣呩煇釣撫煉釣慱釣⑨瀯釤掅瀭釣夺灇_釣栣灮釣抇釣栣煉釣氠灎釣熱煉釣斸瀼釣丰煃_釣熱灮釣€釤掅灇_釣熱焻釣氠煃".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[釣愥煉釣勧焹釣撫焾 釣樶焿釤勧瀯] LT",
                nextDay: "[釣熱煉釣⑨焸釣€ 釣樶焿釤勧瀯] LT",
                nextWeek: "dddd [釣樶焿釤勧瀯] LT",
                lastDay: "[釣樶煉釣熱灧釣涐灅釣丰瀴 釣樶焿釤勧瀯] LT",
                lastWeek: "dddd [釣熱灁釤掅瀼釣夺灎釤嶀灅釣会灀] [釣樶焿釤勧瀯] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s釣戓焵釣�",
                past: "%s釣樶灮釣�",
                s: "釣斸焿釣会灀釤掅灅釣夺灀釣溼灧釣撫灦釣戓灨",
                m: "釣樶灲釣欋灀釣夺瀾釣�",
                mm: "%d 釣撫灦釣戓灨",
                h: "釣樶灲釣欋灅釤夅焺釣�",
                hh: "%d 釣樶焿釤勧瀯",
                d: "釣樶灲釣欋瀽釤掅瀯釤�",
                dd: "%d 釣愥煉釣勧焹",
                M: "釣樶灲釣欋瀬釤�",
                MM: "%d 釣佱焸",
                y: "釣樶灲釣欋瀱釤掅灀釣夺焼",
                yy: "%d 釣嗎煉釣撫灦釤�"
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("ko", {
            months: "1鞗擾2鞗擾3鞗擾4鞗擾5鞗擾6鞗擾7鞗擾8鞗擾9鞗擾10鞗擾11鞗擾12鞗�".split("_"),
            monthsShort: "1鞗擾2鞗擾3鞗擾4鞗擾5鞗擾6鞗擾7鞗擾8鞗擾9鞗擾10鞗擾11鞗擾12鞗�".split("_"),
            weekdays: "鞚检殧鞚糭鞗旍殧鞚糭頇旍殧鞚糭靾橃殧鞚糭氇╈殧鞚糭旮堨殧鞚糭韱犾殧鞚�".split("_"),
            weekdaysShort: "鞚糭鞗擾頇擾靾榑氇旮坃韱�".split("_"),
            weekdaysMin: "鞚糭鞗擾頇擾靾榑氇旮坃韱�".split("_"),
            longDateFormat: {
                LT: "A h鞁� m攵�",
                LTS: "A h鞁� m攵� s齑�",
                L: "YYYY.MM.DD",
                LL: "YYYY雲� MMMM D鞚�",
                LLL: "YYYY雲� MMMM D鞚� LT",
                LLLL: "YYYY雲� MMMM D鞚� dddd LT"
            },
            calendar: {
                sameDay: "鞓る姌 LT",
                nextDay: "雮挫澕 LT",
                nextWeek: "dddd LT",
                lastDay: "鞏挫牅 LT",
                lastWeek: "歆€雮滌＜ dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s 頉�",
                past: "%s 鞝�",
                s: "氇囲磮",
                ss: "%d齑�",
                m: "鞚茧秳",
                mm: "%d攵�",
                h: "頃滌嫓臧�",
                hh: "%d鞁滉皠",
                d: "頃橂（",
                dd: "%d鞚�",
                M: "頃滊嫭",
                MM: "%d雼�",
                y: "鞚茧厔",
                yy: "%d雲�"
            },
            ordinalParse: /\d{1,2}鞚�/,
            ordinal: "%d鞚�",
            meridiemParse: /鞓れ爠|鞓ろ泟/,
            isPM: function(token) {
                return token === "鞓ろ泟";
            },
            meridiem: function(hour, minute, isUpper) {
                return hour < 12 ? "鞓れ爠" : "鞓ろ泟";
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                m: [ "eng Minutt", "enger Minutt" ],
                h: [ "eng Stonn", "enger Stonn" ],
                d: [ "een Dag", "engem Dag" ],
                M: [ "ee Mount", "engem Mount" ],
                y: [ "ee Joer", "engem Joer" ]
            };
            return withoutSuffix ? format[key][0] : format[key][1];
        }
        function processFutureTime(string) {
            var number = string.substr(0, string.indexOf(" "));
            if (eifelerRegelAppliesToNumber(number)) {
                return "a " + string;
            }
            return "an " + string;
        }
        function processPastTime(string) {
            var number = string.substr(0, string.indexOf(" "));
            if (eifelerRegelAppliesToNumber(number)) {
                return "viru " + string;
            }
            return "virun " + string;
        }
        function eifelerRegelAppliesToNumber(number) {
            number = parseInt(number, 10);
            if (isNaN(number)) {
                return false;
            }
            if (number < 0) {
                return true;
            } else if (number < 10) {
                if (4 <= number && number <= 7) {
                    return true;
                }
                return false;
            } else if (number < 100) {
                var lastDigit = number % 10, firstDigit = number / 10;
                if (lastDigit === 0) {
                    return eifelerRegelAppliesToNumber(firstDigit);
                }
                return eifelerRegelAppliesToNumber(lastDigit);
            } else if (number < 1e4) {
                while (number >= 10) {
                    number = number / 10;
                }
                return eifelerRegelAppliesToNumber(number);
            } else {
                number = number / 1e3;
                return eifelerRegelAppliesToNumber(number);
            }
        }
        return moment.defineLocale("lb", {
            months: "Januar_Februar_M盲erz_Abr毛ll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
            monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
            weekdays: "Sonndeg_M茅indeg_D毛nschdeg_M毛ttwoch_Donneschdeg_Freideg_Samschdeg".split("_"),
            weekdaysShort: "So._M茅._D毛._M毛._Do._Fr._Sa.".split("_"),
            weekdaysMin: "So_M茅_D毛_M毛_Do_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "H:mm [Auer]",
                LTS: "H:mm:ss [Auer]",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Haut um] LT",
                sameElse: "L",
                nextDay: "[Muer um] LT",
                nextWeek: "dddd [um] LT",
                lastDay: "[G毛schter um] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 2:
                      case 4:
                        return "[Leschten] dddd [um] LT";

                      default:
                        return "[Leschte] dddd [um] LT";
                    }
                }
            },
            relativeTime: {
                future: processFutureTime,
                past: processPastTime,
                s: "e puer Sekonnen",
                m: processRelativeTime,
                mm: "%d Minutten",
                h: processRelativeTime,
                hh: "%d Stonnen",
                d: processRelativeTime,
                dd: "%d Deeg",
                M: processRelativeTime,
                MM: "%d M茅int",
                y: processRelativeTime,
                yy: "%d Joer"
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var units = {
            m: "minut臈_minut臈s_minut臋",
            mm: "minut臈s_minu膷i懦_minutes",
            h: "valanda_valandos_valand膮",
            hh: "valandos_valand懦_valandas",
            d: "diena_dienos_dien膮",
            dd: "dienos_dien懦_dienas",
            M: "m臈nuo_m臈nesio_m臈nes寞",
            MM: "m臈nesiai_m臈nesi懦_m臈nesius",
            y: "metai_met懦_metus",
            yy: "metai_met懦_metus"
        }, weekDays = "sekmadienis_pirmadienis_antradienis_tre膷iadienis_ketvirtadienis_penktadienis_拧e拧tadienis".split("_");
        function translateSeconds(number, withoutSuffix, key, isFuture) {
            if (withoutSuffix) {
                return "kelios sekund臈s";
            } else {
                return isFuture ? "keli懦 sekund啪i懦" : "kelias sekundes";
            }
        }
        function translateSingular(number, withoutSuffix, key, isFuture) {
            return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
        }
        function special(number) {
            return number % 10 === 0 || number > 10 && number < 20;
        }
        function forms(key) {
            return units[key].split("_");
        }
        function translate(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            if (number === 1) {
                return result + translateSingular(number, withoutSuffix, key[0], isFuture);
            } else if (withoutSuffix) {
                return result + (special(number) ? forms(key)[1] : forms(key)[0]);
            } else {
                if (isFuture) {
                    return result + forms(key)[1];
                } else {
                    return result + (special(number) ? forms(key)[1] : forms(key)[2]);
                }
            }
        }
        function relativeWeekDay(moment, format) {
            var nominative = format.indexOf("dddd HH:mm") === -1, weekDay = weekDays[moment.day()];
            return nominative ? weekDay : weekDay.substring(0, weekDay.length - 2) + "寞";
        }
        return moment.defineLocale("lt", {
            months: "sausio_vasario_kovo_baland啪io_gegu啪臈s_bir啪elio_liepos_rugpj奴膷io_rugs臈jo_spalio_lapkri膷io_gruod啪io".split("_"),
            monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),
            weekdays: relativeWeekDay,
            weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_艩e拧".split("_"),
            weekdaysMin: "S_P_A_T_K_Pn_艩".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "YYYY-MM-DD",
                LL: "YYYY [m.] MMMM D [d.]",
                LLL: "YYYY [m.] MMMM D [d.], LT [val.]",
                LLLL: "YYYY [m.] MMMM D [d.], dddd, LT [val.]",
                l: "YYYY-MM-DD",
                ll: "YYYY [m.] MMMM D [d.]",
                lll: "YYYY [m.] MMMM D [d.], LT [val.]",
                llll: "YYYY [m.] MMMM D [d.], ddd, LT [val.]"
            },
            calendar: {
                sameDay: "[艩iandien] LT",
                nextDay: "[Rytoj] LT",
                nextWeek: "dddd LT",
                lastDay: "[Vakar] LT",
                lastWeek: "[Pra臈jus寞] dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "po %s",
                past: "prie拧 %s",
                s: translateSeconds,
                m: translateSingular,
                mm: translate,
                h: translateSingular,
                hh: translate,
                d: translateSingular,
                dd: translate,
                M: translateSingular,
                MM: translate,
                y: translateSingular,
                yy: translate
            },
            ordinalParse: /\d{1,2}-oji/,
            ordinal: function(number) {
                return number + "-oji";
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var units = {
            mm: "min奴ti_min奴tes_min奴te_min奴tes",
            hh: "stundu_stundas_stunda_stundas",
            dd: "dienu_dienas_diena_dienas",
            MM: "m膿nesi_m膿ne拧us_m膿nesis_m膿ne拧i",
            yy: "gadu_gadus_gads_gadi"
        };
        function format(word, number, withoutSuffix) {
            var forms = word.split("_");
            if (withoutSuffix) {
                return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
            } else {
                return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
            }
        }
        function relativeTimeWithPlural(number, withoutSuffix, key) {
            return number + " " + format(units[key], number, withoutSuffix);
        }
        return moment.defineLocale("lv", {
            months: "janv膩ris_febru膩ris_marts_apr墨lis_maijs_j奴nijs_j奴lijs_augusts_septembris_oktobris_novembris_decembris".split("_"),
            monthsShort: "jan_feb_mar_apr_mai_j奴n_j奴l_aug_sep_okt_nov_dec".split("_"),
            weekdays: "sv膿tdiena_pirmdiena_otrdiena_tre拧diena_ceturtdiena_piektdiena_sestdiena".split("_"),
            weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"),
            weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "YYYY. [gada] D. MMMM",
                LLL: "YYYY. [gada] D. MMMM, LT",
                LLLL: "YYYY. [gada] D. MMMM, dddd, LT"
            },
            calendar: {
                sameDay: "[艩odien pulksten] LT",
                nextDay: "[R墨t pulksten] LT",
                nextWeek: "dddd [pulksten] LT",
                lastDay: "[Vakar pulksten] LT",
                lastWeek: "[Pag膩ju拧膩] dddd [pulksten] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s v膿l膩k",
                past: "%s agr膩k",
                s: "da啪as sekundes",
                m: "min奴ti",
                mm: relativeTimeWithPlural,
                h: "stundu",
                hh: relativeTimeWithPlural,
                d: "dienu",
                dd: relativeTimeWithPlural,
                M: "m膿nesi",
                MM: relativeTimeWithPlural,
                y: "gadu",
                yy: relativeTimeWithPlural
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("mk", {
            months: "褬邪薪褍邪褉懈_褎械胁褉褍邪褉懈_屑邪褉褌_邪锌褉懈谢_屑邪褬_褬褍薪懈_褬褍谢懈_邪胁谐褍褋褌_褋械锌褌械屑胁褉懈_芯泻褌芯屑胁褉懈_薪芯械屑胁褉懈_写械泻械屑胁褉懈".split("_"),
            monthsShort: "褬邪薪_褎械胁_屑邪褉_邪锌褉_屑邪褬_褬褍薪_褬褍谢_邪胁谐_褋械锌_芯泻褌_薪芯械_写械泻".split("_"),
            weekdays: "薪械写械谢邪_锌芯薪械写械谢薪懈泻_胁褌芯褉薪懈泻_褋褉械写邪_褔械褌胁褉褌芯泻_锌械褌芯泻_褋邪斜芯褌邪".split("_"),
            weekdaysShort: "薪械写_锌芯薪_胁褌芯_褋褉械_褔械褌_锌械褌_褋邪斜".split("_"),
            weekdaysMin: "薪e_锌o_胁褌_褋褉_褔械_锌械_褋a".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "D.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[袛械薪械褋 胁芯] LT",
                nextDay: "[校褌褉械 胁芯] LT",
                nextWeek: "dddd [胁芯] LT",
                lastDay: "[袙褔械褉邪 胁芯] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                      case 3:
                      case 6:
                        return "[袙芯 懈蟹屑懈薪邪褌邪褌邪] dddd [胁芯] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[袙芯 懈蟹屑懈薪邪褌懈芯褌] dddd [胁芯] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "锌芯褋谢械 %s",
                past: "锌褉械写 %s",
                s: "薪械泻芯谢泻褍 褋械泻褍薪写懈",
                m: "屑懈薪褍褌邪",
                mm: "%d 屑懈薪褍褌懈",
                h: "褔邪褋",
                hh: "%d 褔邪褋邪",
                d: "写械薪",
                dd: "%d 写械薪邪",
                M: "屑械褋械褑",
                MM: "%d 屑械褋械褑懈",
                y: "谐芯写懈薪邪",
                yy: "%d 谐芯写懈薪懈"
            },
            ordinalParse: /\d{1,2}-(械胁|械薪|褌懈|胁懈|褉懈|屑懈)/,
            ordinal: function(number) {
                var lastDigit = number % 10, last2Digits = number % 100;
                if (number === 0) {
                    return number + "-械胁";
                } else if (last2Digits === 0) {
                    return number + "-械薪";
                } else if (last2Digits > 10 && last2Digits < 20) {
                    return number + "-褌懈";
                } else if (lastDigit === 1) {
                    return number + "-胁懈";
                } else if (lastDigit === 2) {
                    return number + "-褉懈";
                } else if (lastDigit === 7 || lastDigit === 8) {
                    return number + "-屑懈";
                } else {
                    return number + "-褌懈";
                }
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("ml", {
            months: "啻溹川嗟佮吹啻班纯_啻祮啻祶啻班祦啻掂窗啻縚啻淳嗟监礆嗟嵿礆嗟峗啻忇椽嗟嵿窗啻苦到_啻祰啻祶_啻溹祩嗟篲啻溹祩啻侧祱_啻撪礂啻膏祶啻编祶啻编祶_啻膏祮啻祶啻编祶啻编磦啻导_啻掄磿嗟嵿礋嗟嬥船嗟糭啻ㄠ吹啻傕船嗟糭啻∴纯啻膏磦啻导".split("_"),
            monthsShort: "啻溹川嗟�._啻祮啻祶啻班祦._啻淳嗟�._啻忇椽嗟嵿窗啻�._啻祰啻祶_啻溹祩嗟篲啻溹祩啻侧祱._啻撪礂._啻膏祮啻祶啻编祶啻�._啻掄磿嗟嵿礋嗟�._啻ㄠ吹啻�._啻∴纯啻膏磦.".split("_"),
            weekdays: "啻炧淳啻幢啻距创嗟嵿礆_啻む纯啻權祶啻曕闯啻距创嗟嵿礆_啻氞祳啻掂祶啻掂淳啻脆祶啻歘啻祦啻о川啻距创嗟嵿礆_啻掂祶啻淳啻脆淳啻脆祶啻歘啻掂祮啻赤祶啻赤纯啻淳啻脆祶啻歘啻多川啻苦疮啻距创嗟嵿礆".split("_"),
            weekdaysShort: "啻炧淳啻导_啻む纯啻權祶啻曕稻_啻氞祳啻掂祶啻礯啻祦啻о祷_啻掂祶啻淳啻脆磦_啻掂祮啻赤祶啻赤纯_啻多川啻�".split("_"),
            weekdaysMin: "啻炧淳_啻む纯_啻氞祳_啻祦_啻掂祶啻淳_啻掂祮_啻�".split("_"),
            longDateFormat: {
                LT: "A h:mm -啻ㄠ祦",
                LTS: "A h:mm:ss -啻ㄠ祦",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, LT",
                LLLL: "dddd, D MMMM YYYY, LT"
            },
            calendar: {
                sameDay: "[啻囙川嗟嵿川嗟峕 LT",
                nextDay: "[啻ㄠ淳啻赤祮] LT",
                nextWeek: "dddd, LT",
                lastDay: "[啻囙川嗟嵿川啻侧祮] LT",
                lastWeek: "[啻曕创啻苦礊嗟嵿礊] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s 啻曕创啻苦礊嗟嵿礊嗟�",
                past: "%s 啻祦嗟秽椽嗟�",
                s: "啻呧到啻� 啻ㄠ纯啻纯啻粪礄嗟嵿礄嗟�",
                m: "啻掄窗嗟� 啻纯啻ㄠ纯啻编祶啻编祶",
                mm: "%d 啻纯啻ㄠ纯啻编祶啻编祶",
                h: "啻掄窗嗟� 啻矗啻苦磿嗟嵿磿嗟傕导",
                hh: "%d 啻矗啻苦磿嗟嵿磿嗟傕导",
                d: "啻掄窗嗟� 啻︵纯啻掂锤啻�",
                dd: "%d 啻︵纯啻掂锤啻�",
                M: "啻掄窗嗟� 啻淳啻膏磦",
                MM: "%d 啻淳啻膏磦",
                y: "啻掄窗嗟� 啻掂导啻粪磦",
                yy: "%d 啻掂导啻粪磦"
            },
            meridiemParse: /啻班淳啻む祶啻班纯|啻班淳啻掂纯啻侧祮|啻夃礆嗟嵿礆 啻曕创啻苦礊嗟嵿礊嗟峾啻掂祱啻曕祦啻ㄠ祶啻ㄠ祰啻班磦|啻班淳啻む祶啻班纯/i,
            isPM: function(input) {
                return /^(啻夃礆嗟嵿礆 啻曕创啻苦礊嗟嵿礊嗟峾啻掂祱啻曕祦啻ㄠ祶啻ㄠ祰啻班磦|啻班淳啻む祶啻班纯)$/.test(input);
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "啻班淳啻む祶啻班纯";
                } else if (hour < 12) {
                    return "啻班淳啻掂纯啻侧祮";
                } else if (hour < 17) {
                    return "啻夃礆嗟嵿礆 啻曕创啻苦礊嗟嵿礊嗟�";
                } else if (hour < 20) {
                    return "啻掂祱啻曕祦啻ㄠ祶啻ㄠ祰啻班磦";
                } else {
                    return "啻班淳啻む祶啻班纯";
                }
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "啷�",
            "2": "啷�",
            "3": "啷�",
            "4": "啷�",
            "5": "啷�",
            "6": "啷�",
            "7": "啷�",
            "8": "啷�",
            "9": "啷�",
            "0": "啷�"
        }, numberMap = {
            "啷�": "1",
            "啷�": "2",
            "啷�": "3",
            "啷�": "4",
            "啷�": "5",
            "啷�": "6",
            "啷�": "7",
            "啷�": "8",
            "啷�": "9",
            "啷�": "0"
        };
        return moment.defineLocale("mr", {
            months: "啶溹ぞ啶ㄠ啶掂ぞ啶班_啶啶啶班啶掂ぞ啶班_啶ぞ啶班啶歘啶忇お啷嵿ぐ啶苦げ_啶_啶溹啶╛啶溹啶侧_啶戉啶膏啶焈啶膏お啷嵿啷囙啶ぐ_啶戉啷嵿啷嬥が啶癬啶ㄠ啶掂啶灌啶傕が啶癬啶∴た啶膏啶傕が啶�".split("_"),
            monthsShort: "啶溹ぞ啶ㄠ._啶啶啶班._啶ぞ啶班啶�._啶忇お啷嵿ぐ啶�._啶._啶溹啶�._啶溹啶侧._啶戉._啶膏お啷嵿啷囙._啶戉啷嵿啷�._啶ㄠ啶掂啶灌啶�._啶∴た啶膏啶�.".split("_"),
            weekdays: "啶班さ啶苦さ啶距ぐ_啶膏啶さ啶距ぐ_啶啶椸こ啶掂ぞ啶癬啶啶оさ啶距ぐ_啶椸啶班啶掂ぞ啶癬啶多啶曕啶班さ啶距ぐ_啶多え啶苦さ啶距ぐ".split("_"),
            weekdaysShort: "啶班さ啶縚啶膏啶甠啶啶椸こ_啶啶啶椸啶班_啶多啶曕啶癬啶多え啶�".split("_"),
            weekdaysMin: "啶癬啶膏_啶_啶_啶椸_啶多_啶�".split("_"),
            longDateFormat: {
                LT: "A h:mm 啶掂ぞ啶溹い啶�",
                LTS: "A h:mm:ss 啶掂ぞ啶溹い啶�",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, LT",
                LLLL: "dddd, D MMMM YYYY, LT"
            },
            calendar: {
                sameDay: "[啶嗋] LT",
                nextDay: "[啶夃う啷嵿く啶綸 LT",
                nextWeek: "dddd, LT",
                lastDay: "[啶曕ぞ啶瞉 LT",
                lastWeek: "[啶ぞ啶椸啶瞉 dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s 啶ㄠ啶むぐ",
                past: "%s 啶啶班啶掂",
                s: "啶膏啶曕啶�",
                m: "啶忇 啶た啶ㄠた啶�",
                mm: "%d 啶た啶ㄠた啶熰",
                h: "啶忇 啶むぞ啶�",
                hh: "%d 啶むぞ啶�",
                d: "啶忇 啶︵た啶掂じ",
                dd: "%d 啶︵た啶掂じ",
                M: "啶忇 啶す啶苦え啶�",
                MM: "%d 啶す啶苦え啷�",
                y: "啶忇 啶掂ぐ啷嵿し",
                yy: "%d 啶掂ぐ啷嵿し啷�"
            },
            preparse: function(string) {
                return string.replace(/[啷оエ啷┼オ啷ガ啷ギ啷ウ]/g, function(match) {
                    return numberMap[match];
                });
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                });
            },
            meridiemParse: /啶班ぞ啶む啶班|啶膏啶距こ啷€|啶︵啶ぞ啶班|啶膏ぞ啶啶曕ぞ啶赤/,
            meridiemHour: function(hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === "啶班ぞ啶む啶班") {
                    return hour < 4 ? hour : hour + 12;
                } else if (meridiem === "啶膏啶距こ啷€") {
                    return hour;
                } else if (meridiem === "啶︵啶ぞ啶班") {
                    return hour >= 10 ? hour : hour + 12;
                } else if (meridiem === "啶膏ぞ啶啶曕ぞ啶赤") {
                    return hour + 12;
                }
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "啶班ぞ啶む啶班";
                } else if (hour < 10) {
                    return "啶膏啶距こ啷€";
                } else if (hour < 17) {
                    return "啶︵啶ぞ啶班";
                } else if (hour < 20) {
                    return "啶膏ぞ啶啶曕ぞ啶赤";
                } else {
                    return "啶班ぞ啶む啶班";
                }
            },
            week: {
                dow: 0,
                doy: 6
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("ms-my", {
            months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
            monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
            weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
            weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
            weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "LT.ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [pukul] LT",
                LLLL: "dddd, D MMMM YYYY [pukul] LT"
            },
            meridiemParse: /pagi|tengahari|petang|malam/,
            meridiemHour: function(hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === "pagi") {
                    return hour;
                } else if (meridiem === "tengahari") {
                    return hour >= 11 ? hour : hour + 12;
                } else if (meridiem === "petang" || meridiem === "malam") {
                    return hour + 12;
                }
            },
            meridiem: function(hours, minutes, isLower) {
                if (hours < 11) {
                    return "pagi";
                } else if (hours < 15) {
                    return "tengahari";
                } else if (hours < 19) {
                    return "petang";
                } else {
                    return "malam";
                }
            },
            calendar: {
                sameDay: "[Hari ini pukul] LT",
                nextDay: "[Esok pukul] LT",
                nextWeek: "dddd [pukul] LT",
                lastDay: "[Kelmarin pukul] LT",
                lastWeek: "dddd [lepas pukul] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dalam %s",
                past: "%s yang lepas",
                s: "beberapa saat",
                m: "seminit",
                mm: "%d minit",
                h: "sejam",
                hh: "%d jam",
                d: "sehari",
                dd: "%d hari",
                M: "sebulan",
                MM: "%d bulan",
                y: "setahun",
                yy: "%d tahun"
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "醽�",
            "2": "醽�",
            "3": "醽�",
            "4": "醽�",
            "5": "醽�",
            "6": "醽�",
            "7": "醽�",
            "8": "醽�",
            "9": "醽�",
            "0": "醽€"
        }, numberMap = {
            "醽�": "1",
            "醽�": "2",
            "醽�": "3",
            "醽�": "4",
            "醽�": "5",
            "醽�": "6",
            "醽�": "7",
            "醽�": "8",
            "醽�": "9",
            "醽€": "0"
        };
        return moment.defineLocale("my", {
            months: "醼囜€斸€横€斸€濁€€涐€甠醼栣€贬€栣€贬€€横€濁€€涐€甠醼欋€愥€篲醼п€曖€坚€甠醼欋€盻醼囜€结€斸€篲醼囜€搬€溼€€€勧€篲醼炨€坚€傖€€愥€篲醼呩€€醼横€愥€勧€横€樶€琠醼♂€贬€€€醼横€愥€€€樶€琠醼斸€€€濁€勧€横€樶€琠醼掅€€囜€勧€横€樶€�".split("_"),
            monthsShort: "醼囜€斸€篲醼栣€盻醼欋€愥€篲醼曖€坚€甠醼欋€盻醼囜€结€斸€篲醼溼€€€勧€篲醼炨€糭醼呩€€醼篲醼♂€贬€€€醼篲醼斸€€痏醼掅€�".split("_"),
            weekdays: "醼愥€斸€勧€横€贯€傖€斸€结€盻醼愥€斸€勧€横€贯€溼€琠醼♂€勧€横€贯€傖€玙醼椺€€掅€贯€撫€熱€搬€竉醼€醼坚€€炨€曖€愥€贬€竉醼炨€贬€€€醼坚€琠醼呩€斸€�".split("_"),
            weekdaysShort: "醼斸€结€盻醼溼€琠醼勧€横€贯€傖€玙醼熱€搬€竉醼€醼坚€琠醼炨€贬€琠醼斸€�".split("_"),
            weekdaysMin: "醼斸€结€盻醼溼€琠醼勧€横€贯€傖€玙醼熱€搬€竉醼€醼坚€琠醼炨€贬€琠醼斸€�".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[醼氠€斸€�.] LT [醼欋€踞€琞",
                nextDay: "[醼欋€斸€€醼横€栣€坚€斸€篯 LT [醼欋€踞€琞",
                nextWeek: "dddd LT [醼欋€踞€琞",
                lastDay: "[醼欋€斸€�.醼€] LT [醼欋€踞€琞",
                lastWeek: "[醼曖€坚€€羔€佱€册€丰€炨€贬€琞 dddd LT [醼欋€踞€琞",
                sameElse: "L"
            },
            relativeTime: {
                future: "醼溼€€欋€娽€横€� %s 醼欋€踞€�",
                past: "醼溼€结€斸€横€佱€册€丰€炨€贬€� %s 醼€",
                s: "醼呩€€醼贯€€醼斸€�.醼♂€斸€娽€横€羔€勧€氠€�",
                m: "醼愥€呩€横€欋€€斸€呩€�",
                mm: "%d 醼欋€€斸€呩€�",
                h: "醼愥€呩€横€斸€€涐€�",
                hh: "%d 醼斸€€涐€�",
                d: "醼愥€呩€横€涐€€醼�",
                dd: "%d 醼涐€€醼�",
                M: "醼愥€呩€横€�",
                MM: "%d 醼�",
                y: "醼愥€呩€横€斸€踞€呩€�",
                yy: "%d 醼斸€踞€呩€�"
            },
            preparse: function(string) {
                return string.replace(/[醽佱亗醽冡亜醽呩亞醽囜亪醽夅亐]/g, function(match) {
                    return numberMap[match];
                });
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                });
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("nb", {
            months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
            monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
            weekdays: "s酶ndag_mandag_tirsdag_onsdag_torsdag_fredag_l酶rdag".split("_"),
            weekdaysShort: "s酶n_man_tirs_ons_tors_fre_l酶r".split("_"),
            weekdaysMin: "s酶_ma_ti_on_to_fr_l酶".split("_"),
            longDateFormat: {
                LT: "H.mm",
                LTS: "LT.ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY [kl.] LT",
                LLLL: "dddd D. MMMM YYYY [kl.] LT"
            },
            calendar: {
                sameDay: "[i dag kl.] LT",
                nextDay: "[i morgen kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[i g氓r kl.] LT",
                lastWeek: "[forrige] dddd [kl.] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "for %s siden",
                s: "noen sekunder",
                m: "ett minutt",
                mm: "%d minutter",
                h: "en time",
                hh: "%d timer",
                d: "en dag",
                dd: "%d dager",
                M: "en m氓ned",
                MM: "%d m氓neder",
                y: "ett 氓r",
                yy: "%d 氓r"
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var symbolMap = {
            "1": "啷�",
            "2": "啷�",
            "3": "啷�",
            "4": "啷�",
            "5": "啷�",
            "6": "啷�",
            "7": "啷�",
            "8": "啷�",
            "9": "啷�",
            "0": "啷�"
        }, numberMap = {
            "啷�": "1",
            "啷�": "2",
            "啷�": "3",
            "啷�": "4",
            "啷�": "5",
            "啷�": "6",
            "啷�": "7",
            "啷�": "8",
            "啷�": "9",
            "啷�": "0"
        };
        return moment.defineLocale("ne", {
            months: "啶溹え啶掂ぐ啷€_啶啶啶班啶掂ぐ啷€_啶ぞ啶班啶歘啶呧お啷嵿ぐ啶苦げ_啶_啶溹啶╛啶溹啶侧ぞ啶坃啶呧啶粪啶焈啶膏啶啶熰啶啶ぐ_啶呧啷嵿啷嬥が啶癬啶ㄠ啶啶啶ぐ_啶∴た啶膏啶啶ぐ".split("_"),
            monthsShort: "啶溹え._啶啶啶班._啶ぞ啶班啶歘啶呧お啷嵿ぐ啶�._啶_啶溹啶╛啶溹啶侧ぞ啶�._啶呧._啶膏啶啶�._啶呧啷嵿啷�._啶ㄠ啶._啶∴た啶膏.".split("_"),
            weekdays: "啶嗋啶むが啶距ぐ_啶膏啶が啶距ぐ_啶啷嵿啶侧が啶距ぐ_啶啶оが啶距ぐ_啶た啶灌た啶ぞ啶癬啶多啶曕啶班が啶距ぐ_啶多え啶苦が啶距ぐ".split("_"),
            weekdaysShort: "啶嗋啶�._啶膏啶�._啶啷嵿啶�._啶啶�._啶た啶灌た._啶多啶曕啶�._啶多え啶�.".split("_"),
            weekdaysMin: "啶嗋._啶膏._啶啷峗啶._啶た._啶多._啶�.".split("_"),
            longDateFormat: {
                LT: "A啶曕 h:mm 啶啷�",
                LTS: "A啶曕 h:mm:ss 啶啷�",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, LT",
                LLLL: "dddd, D MMMM YYYY, LT"
            },
            preparse: function(string) {
                return string.replace(/[啷оエ啷┼オ啷ガ啷ギ啷ウ]/g, function(match) {
                    return numberMap[match];
                });
            },
            postformat: function(string) {
                return string.replace(/\d/g, function(match) {
                    return symbolMap[match];
                });
            },
            meridiemParse: /啶班ぞ啶む|啶た啶灌ぞ啶▅啶︵た啶夃啶膏|啶啶侧啶曕ぞ|啶膏ぞ啶佮|啶班ぞ啶む/,
            meridiemHour: function(hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === "啶班ぞ啶む") {
                    return hour < 3 ? hour : hour + 12;
                } else if (meridiem === "啶た啶灌ぞ啶�") {
                    return hour;
                } else if (meridiem === "啶︵た啶夃啶膏") {
                    return hour >= 10 ? hour : hour + 12;
                } else if (meridiem === "啶啶侧啶曕ぞ" || meridiem === "啶膏ぞ啶佮") {
                    return hour + 12;
                }
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 3) {
                    return "啶班ぞ啶む";
                } else if (hour < 10) {
                    return "啶た啶灌ぞ啶�";
                } else if (hour < 15) {
                    return "啶︵た啶夃啶膏";
                } else if (hour < 18) {
                    return "啶啶侧啶曕ぞ";
                } else if (hour < 20) {
                    return "啶膏ぞ啶佮";
                } else {
                    return "啶班ぞ啶む";
                }
            },
            calendar: {
                sameDay: "[啶嗋] LT",
                nextDay: "[啶啶侧] LT",
                nextWeek: "[啶嗋啶佮う啷媇 dddd[,] LT",
                lastDay: "[啶灌た啶溹] LT",
                lastWeek: "[啶椸啶曕] dddd[,] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s啶ぞ",
                past: "%s 啶呧啶距ぁ啷€",
                s: "啶曕啶灌 啶膏ぎ啶�",
                m: "啶忇 啶た啶ㄠ啶�",
                mm: "%d 啶た啶ㄠ啶�",
                h: "啶忇 啶樴ぃ啷嵿啶�",
                hh: "%d 啶樴ぃ啷嵿啶�",
                d: "啶忇 啶︵た啶�",
                dd: "%d 啶︵た啶�",
                M: "啶忇 啶す啶苦え啶�",
                MM: "%d 啶す啶苦え啶�",
                y: "啶忇 啶ぐ啷嵿し",
                yy: "%d 啶ぐ啷嵿し"
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var monthsShortWithDots = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_");
        return moment.defineLocale("nl", {
            months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
            monthsShort: function(m, format) {
                if (/-MMM-/.test(format)) {
                    return monthsShortWithoutDots[m.month()];
                } else {
                    return monthsShortWithDots[m.month()];
                }
            },
            weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
            weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
            weekdaysMin: "Zo_Ma_Di_Wo_Do_Vr_Za".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD-MM-YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[vandaag om] LT",
                nextDay: "[morgen om] LT",
                nextWeek: "dddd [om] LT",
                lastDay: "[gisteren om] LT",
                lastWeek: "[afgelopen] dddd [om] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "over %s",
                past: "%s geleden",
                s: "een paar seconden",
                m: "茅茅n minuut",
                mm: "%d minuten",
                h: "茅茅n uur",
                hh: "%d uur",
                d: "茅茅n dag",
                dd: "%d dagen",
                M: "茅茅n maand",
                MM: "%d maanden",
                y: "茅茅n jaar",
                yy: "%d jaar"
            },
            ordinalParse: /\d{1,2}(ste|de)/,
            ordinal: function(number) {
                return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("nn", {
            months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
            monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
            weekdays: "sundag_m氓ndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),
            weekdaysShort: "sun_m氓n_tys_ons_tor_fre_lau".split("_"),
            weekdaysMin: "su_m氓_ty_on_to_fr_l酶".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[I dag klokka] LT",
                nextDay: "[I morgon klokka] LT",
                nextWeek: "dddd [klokka] LT",
                lastDay: "[I g氓r klokka] LT",
                lastWeek: "[F酶reg氓ande] dddd [klokka] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "for %s sidan",
                s: "nokre sekund",
                m: "eit minutt",
                mm: "%d minutt",
                h: "ein time",
                hh: "%d timar",
                d: "ein dag",
                dd: "%d dagar",
                M: "ein m氓nad",
                MM: "%d m氓nader",
                y: "eit 氓r",
                yy: "%d 氓r"
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var monthsNominative = "stycze艅_luty_marzec_kwiecie艅_maj_czerwiec_lipiec_sierpie艅_wrzesie艅_pa藕dziernik_listopad_grudzie艅".split("_"), monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrze艣nia_pa藕dziernika_listopada_grudnia".split("_");
        function plural(n) {
            return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
        }
        function translate(number, withoutSuffix, key) {
            var result = number + " ";
            switch (key) {
              case "m":
                return withoutSuffix ? "minuta" : "minut臋";

              case "mm":
                return result + (plural(number) ? "minuty" : "minut");

              case "h":
                return withoutSuffix ? "godzina" : "godzin臋";

              case "hh":
                return result + (plural(number) ? "godziny" : "godzin");

              case "MM":
                return result + (plural(number) ? "miesi膮ce" : "miesi臋cy");

              case "yy":
                return result + (plural(number) ? "lata" : "lat");
            }
        }
        return moment.defineLocale("pl", {
            months: function(momentToFormat, format) {
                if (/D MMMM/.test(format)) {
                    return monthsSubjective[momentToFormat.month()];
                } else {
                    return monthsNominative[momentToFormat.month()];
                }
            },
            monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa藕_lis_gru".split("_"),
            weekdays: "niedziela_poniedzia艂ek_wtorek_艣roda_czwartek_pi膮tek_sobota".split("_"),
            weekdaysShort: "nie_pon_wt_艣r_czw_pt_sb".split("_"),
            weekdaysMin: "N_Pn_Wt_艢r_Cz_Pt_So".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Dzi艣 o] LT",
                nextDay: "[Jutro o] LT",
                nextWeek: "[W] dddd [o] LT",
                lastDay: "[Wczoraj o] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[W zesz艂膮 niedziel臋 o] LT";

                      case 3:
                        return "[W zesz艂膮 艣rod臋 o] LT";

                      case 6:
                        return "[W zesz艂膮 sobot臋 o] LT";

                      default:
                        return "[W zesz艂y] dddd [o] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "%s temu",
                s: "kilka sekund",
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: "1 dzie艅",
                dd: "%d dni",
                M: "miesi膮c",
                MM: translate,
                y: "rok",
                yy: translate
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("pt-br", {
            months: "janeiro_fevereiro_mar莽o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
            monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
            weekdays: "domingo_segunda-feira_ter莽a-feira_quarta-feira_quinta-feira_sexta-feira_s谩bado".split("_"),
            weekdaysShort: "dom_seg_ter_qua_qui_sex_s谩b".split("_"),
            weekdaysMin: "dom_2陋_3陋_4陋_5陋_6陋_s谩b".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY [脿s] LT",
                LLLL: "dddd, D [de] MMMM [de] YYYY [脿s] LT"
            },
            calendar: {
                sameDay: "[Hoje 脿s] LT",
                nextDay: "[Amanh茫 脿s] LT",
                nextWeek: "dddd [脿s] LT",
                lastDay: "[Ontem 脿s] LT",
                lastWeek: function() {
                    return this.day() === 0 || this.day() === 6 ? "[脷ltimo] dddd [脿s] LT" : "[脷ltima] dddd [脿s] LT";
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "em %s",
                past: "%s atr谩s",
                s: "segundos",
                m: "um minuto",
                mm: "%d minutos",
                h: "uma hora",
                hh: "%d horas",
                d: "um dia",
                dd: "%d dias",
                M: "um m锚s",
                MM: "%d meses",
                y: "um ano",
                yy: "%d anos"
            },
            ordinalParse: /\d{1,2}潞/,
            ordinal: "%d潞"
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("pt", {
            months: "janeiro_fevereiro_mar莽o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
            monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
            weekdays: "domingo_segunda-feira_ter莽a-feira_quarta-feira_quinta-feira_sexta-feira_s谩bado".split("_"),
            weekdaysShort: "dom_seg_ter_qua_qui_sex_s谩b".split("_"),
            weekdaysMin: "dom_2陋_3陋_4陋_5陋_6陋_s谩b".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY LT",
                LLLL: "dddd, D [de] MMMM [de] YYYY LT"
            },
            calendar: {
                sameDay: "[Hoje 脿s] LT",
                nextDay: "[Amanh茫 脿s] LT",
                nextWeek: "dddd [脿s] LT",
                lastDay: "[Ontem 脿s] LT",
                lastWeek: function() {
                    return this.day() === 0 || this.day() === 6 ? "[脷ltimo] dddd [脿s] LT" : "[脷ltima] dddd [脿s] LT";
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "em %s",
                past: "h谩 %s",
                s: "segundos",
                m: "um minuto",
                mm: "%d minutos",
                h: "uma hora",
                hh: "%d horas",
                d: "um dia",
                dd: "%d dias",
                M: "um m锚s",
                MM: "%d meses",
                y: "um ano",
                yy: "%d anos"
            },
            ordinalParse: /\d{1,2}潞/,
            ordinal: "%d潞",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function relativeTimeWithPlural(number, withoutSuffix, key) {
            var format = {
                mm: "minute",
                hh: "ore",
                dd: "zile",
                MM: "luni",
                yy: "ani"
            }, separator = " ";
            if (number % 100 >= 20 || number >= 100 && number % 100 === 0) {
                separator = " de ";
            }
            return number + separator + format[key];
        }
        return moment.defineLocale("ro", {
            months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),
            monthsShort: "ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),
            weekdays: "duminic膬_luni_mar葲i_miercuri_joi_vineri_s芒mb膬t膬".split("_"),
            weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_S芒m".split("_"),
            weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_S芒".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY H:mm",
                LLLL: "dddd, D MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[azi la] LT",
                nextDay: "[m芒ine la] LT",
                nextWeek: "dddd [la] LT",
                lastDay: "[ieri la] LT",
                lastWeek: "[fosta] dddd [la] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "peste %s",
                past: "%s 卯n urm膬",
                s: "c芒teva secunde",
                m: "un minut",
                mm: relativeTimeWithPlural,
                h: "o or膬",
                hh: relativeTimeWithPlural,
                d: "o zi",
                dd: relativeTimeWithPlural,
                M: "o lun膬",
                MM: relativeTimeWithPlural,
                y: "un an",
                yy: relativeTimeWithPlural
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function plural(word, num) {
            var forms = word.split("_");
            return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
        }
        function relativeTimeWithPlural(number, withoutSuffix, key) {
            var format = {
                mm: withoutSuffix ? "屑懈薪褍褌邪_屑懈薪褍褌褘_屑懈薪褍褌" : "屑懈薪褍褌褍_屑懈薪褍褌褘_屑懈薪褍褌",
                hh: "褔邪褋_褔邪褋邪_褔邪褋芯胁",
                dd: "写械薪褜_写薪褟_写薪械泄",
                MM: "屑械褋褟褑_屑械褋褟褑邪_屑械褋褟褑械胁",
                yy: "谐芯写_谐芯写邪_谢械褌"
            };
            if (key === "m") {
                return withoutSuffix ? "屑懈薪褍褌邪" : "屑懈薪褍褌褍";
            } else {
                return number + " " + plural(format[key], +number);
            }
        }
        function monthsCaseReplace(m, format) {
            var months = {
                nominative: "褟薪胁邪褉褜_褎械胁褉邪谢褜_屑邪褉褌_邪锌褉械谢褜_屑邪泄_懈褞薪褜_懈褞谢褜_邪胁谐褍褋褌_褋械薪褌褟斜褉褜_芯泻褌褟斜褉褜_薪芯褟斜褉褜_写械泻邪斜褉褜".split("_"),
                accusative: "褟薪胁邪褉褟_褎械胁褉邪谢褟_屑邪褉褌邪_邪锌褉械谢褟_屑邪褟_懈褞薪褟_懈褞谢褟_邪胁谐褍褋褌邪_褋械薪褌褟斜褉褟_芯泻褌褟斜褉褟_薪芯褟斜褉褟_写械泻邪斜褉褟".split("_")
            }, nounCase = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(format) ? "accusative" : "nominative";
            return months[nounCase][m.month()];
        }
        function monthsShortCaseReplace(m, format) {
            var monthsShort = {
                nominative: "褟薪胁_褎械胁_屑邪褉褌_邪锌褉_屑邪泄_懈褞薪褜_懈褞谢褜_邪胁谐_褋械薪_芯泻褌_薪芯褟_写械泻".split("_"),
                accusative: "褟薪胁_褎械胁_屑邪褉_邪锌褉_屑邪褟_懈褞薪褟_懈褞谢褟_邪胁谐_褋械薪_芯泻褌_薪芯褟_写械泻".split("_")
            }, nounCase = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(format) ? "accusative" : "nominative";
            return monthsShort[nounCase][m.month()];
        }
        function weekdaysCaseReplace(m, format) {
            var weekdays = {
                nominative: "胁芯褋泻褉械褋械薪褜械_锌芯薪械写械谢褜薪懈泻_胁褌芯褉薪懈泻_褋褉械写邪_褔械褌胁械褉谐_锌褟褌薪懈褑邪_褋褍斜斜芯褌邪".split("_"),
                accusative: "胁芯褋泻褉械褋械薪褜械_锌芯薪械写械谢褜薪懈泻_胁褌芯褉薪懈泻_褋褉械写褍_褔械褌胁械褉谐_锌褟褌薪懈褑褍_褋褍斜斜芯褌褍".split("_")
            }, nounCase = /\[ ?[袙胁] ?(?:锌褉芯褕谢褍褞|褋谢械写褍褞褖褍褞|褝褌褍)? ?\] ?dddd/.test(format) ? "accusative" : "nominative";
            return weekdays[nounCase][m.day()];
        }
        return moment.defineLocale("ru", {
            months: monthsCaseReplace,
            monthsShort: monthsShortCaseReplace,
            weekdays: weekdaysCaseReplace,
            weekdaysShort: "胁褋_锌薪_胁褌_褋褉_褔褌_锌褌_褋斜".split("_"),
            weekdaysMin: "胁褋_锌薪_胁褌_褋褉_褔褌_锌褌_褋斜".split("_"),
            monthsParse: [ /^褟薪胁/i, /^褎械胁/i, /^屑邪褉/i, /^邪锌褉/i, /^屑邪[泄|褟]/i, /^懈褞薪/i, /^懈褞谢/i, /^邪胁谐/i, /^褋械薪/i, /^芯泻褌/i, /^薪芯褟/i, /^写械泻/i ],
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY 谐.",
                LLL: "D MMMM YYYY 谐., LT",
                LLLL: "dddd, D MMMM YYYY 谐., LT"
            },
            calendar: {
                sameDay: "[小械谐芯写薪褟 胁] LT",
                nextDay: "[袟邪胁褌褉邪 胁] LT",
                lastDay: "[袙褔械褉邪 胁] LT",
                nextWeek: function() {
                    return this.day() === 2 ? "[袙芯] dddd [胁] LT" : "[袙] dddd [胁] LT";
                },
                lastWeek: function(now) {
                    if (now.week() !== this.week()) {
                        switch (this.day()) {
                          case 0:
                            return "[袙 锌褉芯褕谢芯械] dddd [胁] LT";

                          case 1:
                          case 2:
                          case 4:
                            return "[袙 锌褉芯褕谢褘泄] dddd [胁] LT";

                          case 3:
                          case 5:
                          case 6:
                            return "[袙 锌褉芯褕谢褍褞] dddd [胁] LT";
                        }
                    } else {
                        if (this.day() === 2) {
                            return "[袙芯] dddd [胁] LT";
                        } else {
                            return "[袙] dddd [胁] LT";
                        }
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "褔械褉械蟹 %s",
                past: "%s 薪邪蟹邪写",
                s: "薪械褋泻芯谢褜泻芯 褋械泻褍薪写",
                m: relativeTimeWithPlural,
                mm: relativeTimeWithPlural,
                h: "褔邪褋",
                hh: relativeTimeWithPlural,
                d: "写械薪褜",
                dd: relativeTimeWithPlural,
                M: "屑械褋褟褑",
                MM: relativeTimeWithPlural,
                y: "谐芯写",
                yy: relativeTimeWithPlural
            },
            meridiemParse: /薪芯褔懈|褍褌褉邪|写薪褟|胁械褔械褉邪/i,
            isPM: function(input) {
                return /^(写薪褟|胁械褔械褉邪)$/.test(input);
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "薪芯褔懈";
                } else if (hour < 12) {
                    return "褍褌褉邪";
                } else if (hour < 17) {
                    return "写薪褟";
                } else {
                    return "胁械褔械褉邪";
                }
            },
            ordinalParse: /\d{1,2}-(泄|谐芯|褟)/,
            ordinal: function(number, period) {
                switch (period) {
                  case "M":
                  case "d":
                  case "DDD":
                    return number + "-泄";

                  case "D":
                    return number + "-谐芯";

                  case "w":
                  case "W":
                    return number + "-褟";

                  default:
                    return number;
                }
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var months = "janu谩r_febru谩r_marec_apr铆l_m谩j_j煤n_j煤l_august_september_okt贸ber_november_december".split("_"), monthsShort = "jan_feb_mar_apr_m谩j_j煤n_j煤l_aug_sep_okt_nov_dec".split("_");
        function plural(n) {
            return n > 1 && n < 5;
        }
        function translate(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            switch (key) {
              case "s":
                return withoutSuffix || isFuture ? "p谩r sek煤nd" : "p谩r sekundami";

              case "m":
                return withoutSuffix ? "min煤ta" : isFuture ? "min煤tu" : "min煤tou";

              case "mm":
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "min煤ty" : "min煤t");
                } else {
                    return result + "min煤tami";
                }
                break;

              case "h":
                return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

              case "hh":
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "hodiny" : "hod铆n");
                } else {
                    return result + "hodinami";
                }
                break;

              case "d":
                return withoutSuffix || isFuture ? "de艌" : "d艌om";

              case "dd":
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "dni" : "dn铆");
                } else {
                    return result + "d艌ami";
                }
                break;

              case "M":
                return withoutSuffix || isFuture ? "mesiac" : "mesiacom";

              case "MM":
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "mesiace" : "mesiacov");
                } else {
                    return result + "mesiacmi";
                }
                break;

              case "y":
                return withoutSuffix || isFuture ? "rok" : "rokom";

              case "yy":
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? "roky" : "rokov");
                } else {
                    return result + "rokmi";
                }
                break;
            }
        }
        return moment.defineLocale("sk", {
            months: months,
            monthsShort: monthsShort,
            monthsParse: function(months, monthsShort) {
                var i, _monthsParse = [];
                for (i = 0; i < 12; i++) {
                    _monthsParse[i] = new RegExp("^" + months[i] + "$|^" + monthsShort[i] + "$", "i");
                }
                return _monthsParse;
            }(months, monthsShort),
            weekdays: "nede木a_pondelok_utorok_streda_拧tvrtok_piatok_sobota".split("_"),
            weekdaysShort: "ne_po_ut_st_拧t_pi_so".split("_"),
            weekdaysMin: "ne_po_ut_st_拧t_pi_so".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[dnes o] LT",
                nextDay: "[zajtra o] LT",
                nextWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[v nede木u o] LT";

                      case 1:
                      case 2:
                        return "[v] dddd [o] LT";

                      case 3:
                        return "[v stredu o] LT";

                      case 4:
                        return "[vo 拧tvrtok o] LT";

                      case 5:
                        return "[v piatok o] LT";

                      case 6:
                        return "[v sobotu o] LT";
                    }
                },
                lastDay: "[v膷era o] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[minul煤 nede木u o] LT";

                      case 1:
                      case 2:
                        return "[minul媒] dddd [o] LT";

                      case 3:
                        return "[minul煤 stredu o] LT";

                      case 4:
                      case 5:
                        return "[minul媒] dddd [o] LT";

                      case 6:
                        return "[minul煤 sobotu o] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "pred %s",
                s: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function translate(number, withoutSuffix, key) {
            var result = number + " ";
            switch (key) {
              case "m":
                return withoutSuffix ? "ena minuta" : "eno minuto";

              case "mm":
                if (number === 1) {
                    result += "minuta";
                } else if (number === 2) {
                    result += "minuti";
                } else if (number === 3 || number === 4) {
                    result += "minute";
                } else {
                    result += "minut";
                }
                return result;

              case "h":
                return withoutSuffix ? "ena ura" : "eno uro";

              case "hh":
                if (number === 1) {
                    result += "ura";
                } else if (number === 2) {
                    result += "uri";
                } else if (number === 3 || number === 4) {
                    result += "ure";
                } else {
                    result += "ur";
                }
                return result;

              case "dd":
                if (number === 1) {
                    result += "dan";
                } else {
                    result += "dni";
                }
                return result;

              case "MM":
                if (number === 1) {
                    result += "mesec";
                } else if (number === 2) {
                    result += "meseca";
                } else if (number === 3 || number === 4) {
                    result += "mesece";
                } else {
                    result += "mesecev";
                }
                return result;

              case "yy":
                if (number === 1) {
                    result += "leto";
                } else if (number === 2) {
                    result += "leti";
                } else if (number === 3 || number === 4) {
                    result += "leta";
                } else {
                    result += "let";
                }
                return result;
            }
        }
        return moment.defineLocale("sl", {
            months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),
            monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),
            weekdays: "nedelja_ponedeljek_torek_sreda_膷etrtek_petek_sobota".split("_"),
            weekdaysShort: "ned._pon._tor._sre._膷et._pet._sob.".split("_"),
            weekdaysMin: "ne_po_to_sr_膷e_pe_so".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD. MM. YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[danes ob] LT",
                nextDay: "[jutri ob] LT",
                nextWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[v] [nedeljo] [ob] LT";

                      case 3:
                        return "[v] [sredo] [ob] LT";

                      case 6:
                        return "[v] [soboto] [ob] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[v] dddd [ob] LT";
                    }
                },
                lastDay: "[v膷eraj ob] LT",
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                      case 3:
                      case 6:
                        return "[prej拧nja] dddd [ob] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[prej拧nji] dddd [ob] LT";
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "膷ez %s",
                past: "%s nazaj",
                s: "nekaj sekund",
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: "en dan",
                dd: translate,
                M: "en mesec",
                MM: translate,
                y: "eno leto",
                yy: translate
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("sq", {
            months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_N毛ntor_Dhjetor".split("_"),
            monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_N毛n_Dhj".split("_"),
            weekdays: "E Diel_E H毛n毛_E Mart毛_E M毛rkur毛_E Enjte_E Premte_E Shtun毛".split("_"),
            weekdaysShort: "Die_H毛n_Mar_M毛r_Enj_Pre_Sht".split("_"),
            weekdaysMin: "D_H_Ma_M毛_E_P_Sh".split("_"),
            meridiemParse: /PD|MD/,
            isPM: function(input) {
                return input.charAt(0) === "M";
            },
            meridiem: function(hours, minutes, isLower) {
                return hours < 12 ? "PD" : "MD";
            },
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Sot n毛] LT",
                nextDay: "[Nes毛r n毛] LT",
                nextWeek: "dddd [n毛] LT",
                lastDay: "[Dje n毛] LT",
                lastWeek: "dddd [e kaluar n毛] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "n毛 %s",
                past: "%s m毛 par毛",
                s: "disa sekonda",
                m: "nj毛 minut毛",
                mm: "%d minuta",
                h: "nj毛 or毛",
                hh: "%d or毛",
                d: "nj毛 dit毛",
                dd: "%d dit毛",
                M: "nj毛 muaj",
                MM: "%d muaj",
                y: "nj毛 vit",
                yy: "%d vite"
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var translator = {
            words: {
                m: [ "褬械写邪薪 屑懈薪褍褌", "褬械写薪械 屑懈薪褍褌械" ],
                mm: [ "屑懈薪褍褌", "屑懈薪褍褌械", "屑懈薪褍褌邪" ],
                h: [ "褬械写邪薪 褋邪褌", "褬械写薪芯谐 褋邪褌邪" ],
                hh: [ "褋邪褌", "褋邪褌邪", "褋邪褌懈" ],
                dd: [ "写邪薪", "写邪薪邪", "写邪薪邪" ],
                MM: [ "屑械褋械褑", "屑械褋械褑邪", "屑械褋械褑懈" ],
                yy: [ "谐芯写懈薪邪", "谐芯写懈薪械", "谐芯写懈薪邪" ]
            },
            correctGrammaticalCase: function(number, wordKey) {
                return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
            },
            translate: function(number, withoutSuffix, key) {
                var wordKey = translator.words[key];
                if (key.length === 1) {
                    return withoutSuffix ? wordKey[0] : wordKey[1];
                } else {
                    return number + " " + translator.correctGrammaticalCase(number, wordKey);
                }
            }
        };
        return moment.defineLocale("sr-cyrl", {
            months: [ "褬邪薪褍邪褉", "褎械斜褉褍邪褉", "屑邪褉褌", "邪锌褉懈谢", "屑邪褬", "褬褍薪", "褬褍谢", "邪胁谐褍褋褌", "褋械锌褌械屑斜邪褉", "芯泻褌芯斜邪褉", "薪芯胁械屑斜邪褉", "写械褑械屑斜邪褉" ],
            monthsShort: [ "褬邪薪.", "褎械斜.", "屑邪褉.", "邪锌褉.", "屑邪褬", "褬褍薪", "褬褍谢", "邪胁谐.", "褋械锌.", "芯泻褌.", "薪芯胁.", "写械褑." ],
            weekdays: [ "薪械写械褭邪", "锌芯薪械写械褭邪泻", "褍褌芯褉邪泻", "褋褉械写邪", "褔械褌胁褉褌邪泻", "锌械褌邪泻", "褋褍斜芯褌邪" ],
            weekdaysShort: [ "薪械写.", "锌芯薪.", "褍褌芯.", "褋褉械.", "褔械褌.", "锌械褌.", "褋褍斜." ],
            weekdaysMin: [ "薪械", "锌芯", "褍褌", "褋褉", "褔械", "锌械", "褋褍" ],
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD. MM. YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[写邪薪邪褋 褍] LT",
                nextDay: "[褋褍褌褉邪 褍] LT",
                nextWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[褍] [薪械写械褭褍] [褍] LT";

                      case 3:
                        return "[褍] [褋褉械写褍] [褍] LT";

                      case 6:
                        return "[褍] [褋褍斜芯褌褍] [褍] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[褍] dddd [褍] LT";
                    }
                },
                lastDay: "[褬褍褔械 褍] LT",
                lastWeek: function() {
                    var lastWeekDays = [ "[锌褉芯褕谢械] [薪械写械褭械] [褍] LT", "[锌褉芯褕谢芯谐] [锌芯薪械写械褭泻邪] [褍] LT", "[锌褉芯褕谢芯谐] [褍褌芯褉泻邪] [褍] LT", "[锌褉芯褕谢械] [褋褉械写械] [褍] LT", "[锌褉芯褕谢芯谐] [褔械褌胁褉褌泻邪] [褍] LT", "[锌褉芯褕谢芯谐] [锌械褌泻邪] [褍] LT", "[锌褉芯褕谢械] [褋褍斜芯褌械] [褍] LT" ];
                    return lastWeekDays[this.day()];
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "蟹邪 %s",
                past: "锌褉械 %s",
                s: "薪械泻芯谢懈泻芯 褋械泻褍薪写懈",
                m: translator.translate,
                mm: translator.translate,
                h: translator.translate,
                hh: translator.translate,
                d: "写邪薪",
                dd: translator.translate,
                M: "屑械褋械褑",
                MM: translator.translate,
                y: "谐芯写懈薪褍",
                yy: translator.translate
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var translator = {
            words: {
                m: [ "jedan minut", "jedne minute" ],
                mm: [ "minut", "minute", "minuta" ],
                h: [ "jedan sat", "jednog sata" ],
                hh: [ "sat", "sata", "sati" ],
                dd: [ "dan", "dana", "dana" ],
                MM: [ "mesec", "meseca", "meseci" ],
                yy: [ "godina", "godine", "godina" ]
            },
            correctGrammaticalCase: function(number, wordKey) {
                return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
            },
            translate: function(number, withoutSuffix, key) {
                var wordKey = translator.words[key];
                if (key.length === 1) {
                    return withoutSuffix ? wordKey[0] : wordKey[1];
                } else {
                    return number + " " + translator.correctGrammaticalCase(number, wordKey);
                }
            }
        };
        return moment.defineLocale("sr", {
            months: [ "januar", "februar", "mart", "april", "maj", "jun", "jul", "avgust", "septembar", "oktobar", "novembar", "decembar" ],
            monthsShort: [ "jan.", "feb.", "mar.", "apr.", "maj", "jun", "jul", "avg.", "sep.", "okt.", "nov.", "dec." ],
            weekdays: [ "nedelja", "ponedeljak", "utorak", "sreda", "膷etvrtak", "petak", "subota" ],
            weekdaysShort: [ "ned.", "pon.", "uto.", "sre.", "膷et.", "pet.", "sub." ],
            weekdaysMin: [ "ne", "po", "ut", "sr", "膷e", "pe", "su" ],
            longDateFormat: {
                LT: "H:mm",
                LTS: "LT:ss",
                L: "DD. MM. YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY LT",
                LLLL: "dddd, D. MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[danas u] LT",
                nextDay: "[sutra u] LT",
                nextWeek: function() {
                    switch (this.day()) {
                      case 0:
                        return "[u] [nedelju] [u] LT";

                      case 3:
                        return "[u] [sredu] [u] LT";

                      case 6:
                        return "[u] [subotu] [u] LT";

                      case 1:
                      case 2:
                      case 4:
                      case 5:
                        return "[u] dddd [u] LT";
                    }
                },
                lastDay: "[ju膷e u] LT",
                lastWeek: function() {
                    var lastWeekDays = [ "[pro拧le] [nedelje] [u] LT", "[pro拧log] [ponedeljka] [u] LT", "[pro拧log] [utorka] [u] LT", "[pro拧le] [srede] [u] LT", "[pro拧log] [膷etvrtka] [u] LT", "[pro拧log] [petka] [u] LT", "[pro拧le] [subote] [u] LT" ];
                    return lastWeekDays[this.day()];
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "pre %s",
                s: "nekoliko sekundi",
                m: translator.translate,
                mm: translator.translate,
                h: translator.translate,
                hh: translator.translate,
                d: "dan",
                dd: translator.translate,
                M: "mesec",
                MM: translator.translate,
                y: "godinu",
                yy: translator.translate
            },
            ordinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("sv", {
            months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),
            monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
            weekdays: "s枚ndag_m氓ndag_tisdag_onsdag_torsdag_fredag_l枚rdag".split("_"),
            weekdaysShort: "s枚n_m氓n_tis_ons_tor_fre_l枚r".split("_"),
            weekdaysMin: "s枚_m氓_ti_on_to_fr_l枚".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "YYYY-MM-DD",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[Idag] LT",
                nextDay: "[Imorgon] LT",
                lastDay: "[Ig氓r] LT",
                nextWeek: "dddd LT",
                lastWeek: "[F枚rra] dddd[en] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "f枚r %s sedan",
                s: "n氓gra sekunder",
                m: "en minut",
                mm: "%d minuter",
                h: "en timme",
                hh: "%d timmar",
                d: "en dag",
                dd: "%d dagar",
                M: "en m氓nad",
                MM: "%d m氓nader",
                y: "ett 氓r",
                yy: "%d 氓r"
            },
            ordinalParse: /\d{1,2}(e|a)/,
            ordinal: function(number) {
                var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "e" : b === 1 ? "a" : b === 2 ? "a" : b === 3 ? "e" : "e";
                return number + output;
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("ta", {
            months: "喈溹喈掂喈縚喈喈瘝喈班喈班_喈喈班瘝喈氞瘝_喈忇喁嵿喈侧瘝_喈瘒_喈溹瘋喈┼瘝_喈溹瘋喈侧瘓_喈嗋畷喈膏瘝喈熰瘝_喈氞瘑喈瘝喈熰瘑喈瘝喈喁峗喈呧畷喁嵿疅喁囙喈喁峗喈ㄠ喈瘝喈喁峗喈熰喈氞喁嵿喈班瘝".split("_"),
            monthsShort: "喈溹喈掂喈縚喈喈瘝喈班喈班_喈喈班瘝喈氞瘝_喈忇喁嵿喈侧瘝_喈瘒_喈溹瘋喈┼瘝_喈溹瘋喈侧瘓_喈嗋畷喈膏瘝喈熰瘝_喈氞瘑喈瘝喈熰瘑喈瘝喈喁峗喈呧畷喁嵿疅喁囙喈喁峗喈ㄠ喈瘝喈喁峗喈熰喈氞喁嵿喈班瘝".split("_"),
            weekdays: "喈炧喈喈编瘝喈编瘉喈曕瘝喈曕喈脆喁坃喈む喈權瘝喈曕疅喁嵿畷喈苦喈瘓_喈氞瘑喈掂瘝喈掂喈瘝喈曕喈脆喁坃喈瘉喈む喁嵿畷喈苦喈瘓_喈掂喈喈脆畷喁嵿畷喈苦喈瘓_喈掂瘑喈赤瘝喈赤喈曕瘝喈曕喈脆喁坃喈氞喈苦畷喁嵿畷喈苦喈瘓".split("_"),
            weekdaysShort: "喈炧喈喈编瘉_喈む喈權瘝喈曕喁峗喈氞瘑喈掂瘝喈掂喈瘝_喈瘉喈む喁峗喈掂喈喈脆喁峗喈掂瘑喈赤瘝喈赤_喈氞喈�".split("_"),
            weekdaysMin: "喈炧_喈む_喈氞瘑_喈瘉_喈掂_喈掂瘑_喈�".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, LT",
                LLLL: "dddd, D MMMM YYYY, LT"
            },
            calendar: {
                sameDay: "[喈囙喁嵿喁乚 LT",
                nextDay: "[喈ㄠ喈赤瘓] LT",
                nextWeek: "dddd, LT",
                lastDay: "[喈ㄠ瘒喈编瘝喈编瘉] LT",
                lastWeek: "[喈曕疅喈ㄠ瘝喈� 喈掂喈班喁峕 dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s 喈囙喁�",
                past: "%s 喈瘉喈┼瘝",
                s: "喈掄喁� 喈氞喈� 喈掂喈ㄠ喈熰喈曕喁�",
                m: "喈掄喁� 喈ㄠ喈喈熰喁�",
                mm: "%d 喈ㄠ喈喈熰畽喁嵿畷喈赤瘝",
                h: "喈掄喁� 喈喈� 喈ㄠ瘒喈班喁�",
                hh: "%d 喈喈� 喈ㄠ瘒喈班喁�",
                d: "喈掄喁� 喈ㄠ喈赤瘝",
                dd: "%d 喈ㄠ喈熰瘝喈曕喁�",
                M: "喈掄喁� 喈喈む喁�",
                MM: "%d 喈喈む畽喁嵿畷喈赤瘝",
                y: "喈掄喁� 喈掂喁佮疅喈瘝",
                yy: "%d 喈嗋喁嵿疅喁佮畷喈赤瘝"
            },
            ordinalParse: /\d{1,2}喈掂喁�/,
            ordinal: function(number) {
                return number + "喈掂喁�";
            },
            meridiemParse: /喈喈喁峾喈掂瘓喈曕喁坾喈曕喈侧瘓|喈ㄠ喁嵿喈曕喁峾喈庎喁嵿喈距疅喁亅喈喈侧瘓/,
            meridiem: function(hour, minute, isLower) {
                if (hour < 2) {
                    return " 喈喈喁�";
                } else if (hour < 6) {
                    return " 喈掂瘓喈曕喁�";
                } else if (hour < 10) {
                    return " 喈曕喈侧瘓";
                } else if (hour < 14) {
                    return " 喈ㄠ喁嵿喈曕喁�";
                } else if (hour < 18) {
                    return " 喈庎喁嵿喈距疅喁�";
                } else if (hour < 22) {
                    return " 喈喈侧瘓";
                } else {
                    return " 喈喈喁�";
                }
            },
            meridiemHour: function(hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === "喈喈喁�") {
                    return hour < 2 ? hour : hour + 12;
                } else if (meridiem === "喈掂瘓喈曕喁�" || meridiem === "喈曕喈侧瘓") {
                    return hour;
                } else if (meridiem === "喈ㄠ喁嵿喈曕喁�") {
                    return hour >= 10 ? hour : hour + 12;
                } else {
                    return hour + 12;
                }
            },
            week: {
                dow: 0,
                doy: 6
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("th", {
            months: "喔∴竵喔｀覆喔勦浮_喔佮父喔∴笭喔侧笧喔编笝喔樴箤_喔∴傅喔權覆喔勦浮_喙€喔∴俯喔侧涪喔檁喔炧袱喔┼笭喔侧竸喔喔∴复喔栢父喔權覆喔⑧笝_喔佮福喔佮笌喔侧竸喔喔复喔囙斧喔侧竸喔喔佮副喔權涪喔侧涪喔檁喔曕父喔ム覆喔勦浮_喔炧袱喔ㄠ笀喔脆竵喔侧涪喔檁喔樴副喔權抚喔侧竸喔�".split("_"),
            monthsShort: "喔∴竵喔｀覆_喔佮父喔∴笭喔瞋喔∴傅喔權覆_喙€喔∴俯喔瞋喔炧袱喔┼笭喔瞋喔∴复喔栢父喔權覆_喔佮福喔佮笌喔瞋喔复喔囙斧喔瞋喔佮副喔權涪喔瞋喔曕父喔ム覆_喔炧袱喔ㄠ笀喔脆竵喔瞋喔樴副喔權抚喔�".split("_"),
            weekdays: "喔覆喔椸复喔曕涪喙宊喔堗副喔權笚喔｀箤_喔副喔囙竸喔侧福_喔炧父喔榑喔炧袱喔副喔笟喔斷傅_喔ㄠ父喔佮福喙宊喙€喔覆喔｀箤".split("_"),
            weekdaysShort: "喔覆喔椸复喔曕涪喙宊喔堗副喔權笚喔｀箤_喔副喔囙竸喔侧福_喔炧父喔榑喔炧袱喔副喔猒喔ㄠ父喔佮福喙宊喙€喔覆喔｀箤".split("_"),
            weekdaysMin: "喔覆._喔�._喔�._喔�._喔炧袱._喔�._喔�.".split("_"),
            longDateFormat: {
                LT: "H 喔權覆喔复喔佮覆 m 喔權覆喔椸傅",
                LTS: "LT s 喔о复喔權覆喔椸傅",
                L: "YYYY/MM/DD",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY 喙€喔о弗喔� LT",
                LLLL: "喔о副喔檇ddd喔椸傅喙� D MMMM YYYY 喙€喔о弗喔� LT"
            },
            meridiemParse: /喔佮箞喔笝喙€喔椸傅喙堗涪喔噟喔弗喔编竾喙€喔椸傅喙堗涪喔�/,
            isPM: function(input) {
                return input === "喔弗喔编竾喙€喔椸傅喙堗涪喔�";
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 12) {
                    return "喔佮箞喔笝喙€喔椸傅喙堗涪喔�";
                } else {
                    return "喔弗喔编竾喙€喔椸傅喙堗涪喔�";
                }
            },
            calendar: {
                sameDay: "[喔о副喔權笝喔掂箟 喙€喔о弗喔瞉 LT",
                nextDay: "[喔炧福喔膏箞喔囙笝喔掂箟 喙€喔о弗喔瞉 LT",
                nextWeek: "dddd[喔笝喙夃覆 喙€喔о弗喔瞉 LT",
                lastDay: "[喙€喔∴阜喙堗腑喔о覆喔權笝喔掂箟 喙€喔о弗喔瞉 LT",
                lastWeek: "[喔о副喔橾dddd[喔椸傅喙堗箒喔ム箟喔� 喙€喔о弗喔瞉 LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "喔傅喔� %s",
                past: "%s喔椸傅喙堗箒喔ム箟喔�",
                s: "喙勦浮喙堗竵喔掂箞喔о复喔權覆喔椸傅",
                m: "1 喔權覆喔椸傅",
                mm: "%d 喔權覆喔椸傅",
                h: "1 喔娻副喙堗抚喙傕浮喔�",
                hh: "%d 喔娻副喙堗抚喙傕浮喔�",
                d: "1 喔о副喔�",
                dd: "%d 喔о副喔�",
                M: "1 喙€喔斷阜喔笝",
                MM: "%d 喙€喔斷阜喔笝",
                y: "1 喔涏傅",
                yy: "%d 喔涏傅"
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("tl-ph", {
            months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
            monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
            weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
            weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
            weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "MM/D/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY LT",
                LLLL: "dddd, MMMM DD, YYYY LT"
            },
            calendar: {
                sameDay: "[Ngayon sa] LT",
                nextDay: "[Bukas sa] LT",
                nextWeek: "dddd [sa] LT",
                lastDay: "[Kahapon sa] LT",
                lastWeek: "dddd [huling linggo] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "sa loob ng %s",
                past: "%s ang nakalipas",
                s: "ilang segundo",
                m: "isang minuto",
                mm: "%d minuto",
                h: "isang oras",
                hh: "%d oras",
                d: "isang araw",
                dd: "%d araw",
                M: "isang buwan",
                MM: "%d buwan",
                y: "isang taon",
                yy: "%d taon"
            },
            ordinalParse: /\d{1,2}/,
            ordinal: function(number) {
                return number;
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        var suffixes = {
            1: "'inci",
            5: "'inci",
            8: "'inci",
            70: "'inci",
            80: "'inci",
            2: "'nci",
            7: "'nci",
            20: "'nci",
            50: "'nci",
            3: "'眉nc眉",
            4: "'眉nc眉",
            100: "'眉nc眉",
            6: "'nc谋",
            9: "'uncu",
            10: "'uncu",
            30: "'uncu",
            60: "'谋nc谋",
            90: "'谋nc谋"
        };
        return moment.defineLocale("tr", {
            months: "Ocak_艦ubat_Mart_Nisan_May谋s_Haziran_Temmuz_A臒ustos_Eyl眉l_Ekim_Kas谋m_Aral谋k".split("_"),
            monthsShort: "Oca_艦ub_Mar_Nis_May_Haz_Tem_A臒u_Eyl_Eki_Kas_Ara".split("_"),
            weekdays: "Pazar_Pazartesi_Sal谋_脟ar艧amba_Per艧embe_Cuma_Cumartesi".split("_"),
            weekdaysShort: "Paz_Pts_Sal_脟ar_Per_Cum_Cts".split("_"),
            weekdaysMin: "Pz_Pt_Sa_脟a_Pe_Cu_Ct".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[bug眉n saat] LT",
                nextDay: "[yar谋n saat] LT",
                nextWeek: "[haftaya] dddd [saat] LT",
                lastDay: "[d眉n] LT",
                lastWeek: "[ge莽en hafta] dddd [saat] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s sonra",
                past: "%s 枚nce",
                s: "birka莽 saniye",
                m: "bir dakika",
                mm: "%d dakika",
                h: "bir saat",
                hh: "%d saat",
                d: "bir g眉n",
                dd: "%d g眉n",
                M: "bir ay",
                MM: "%d ay",
                y: "bir y谋l",
                yy: "%d y谋l"
            },
            ordinalParse: /\d{1,2}'(inci|nci|眉nc眉|nc谋|uncu|谋nc谋)/,
            ordinal: function(number) {
                if (number === 0) {
                    return number + "'谋nc谋";
                }
                var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
                return number + (suffixes[a] || suffixes[b] || suffixes[c]);
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("tzm-latn", {
            months: "innayr_br摔ayr摔_mar摔s摔_ibrir_mayyw_ywnyw_ywlywz_桑w拧t_拧wtanbir_kt摔wbr摔_nwwanbir_dwjnbir".split("_"),
            monthsShort: "innayr_br摔ayr摔_mar摔s摔_ibrir_mayyw_ywnyw_ywlywz_桑w拧t_拧wtanbir_kt摔wbr摔_nwwanbir_dwjnbir".split("_"),
            weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asi岣峺as".split("_"),
            weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asi岣峺as".split("_"),
            weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asi岣峺as".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[asdkh g] LT",
                nextDay: "[aska g] LT",
                nextWeek: "dddd [g] LT",
                lastDay: "[assant g] LT",
                lastWeek: "dddd [g] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dadkh s yan %s",
                past: "yan %s",
                s: "imik",
                m: "minu岣�",
                mm: "%d minu岣�",
                h: "sa蓻a",
                hh: "%d tassa蓻in",
                d: "ass",
                dd: "%d ossan",
                M: "ayowr",
                MM: "%d iyyirn",
                y: "asgas",
                yy: "%d isgasn"
            },
            week: {
                dow: 6,
                doy: 12
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("tzm", {
            months: "獾夆祻獾忊窗獾⑩禂_獯扁禃獯扳耽獾昣獾庘窗獾曗禋_獾夆幢獾斺祲獾擾獾庘窗獾⑩耽獾揰獾⑩祿獾忊耽獾揰獾⑩祿獾嶁耽獾撯担_獾栤祿獾涒禍_獾涒祿獾溾窗獾忊幢獾夆禂_獯解禑獾撯幢獾昣獾忊祿獾♀窗獾忊幢獾夆禂_獯封祿獾娾祻獯扁祲獾�".split("_"),
            monthsShort: "獾夆祻獾忊窗獾⑩禂_獯扁禃獯扳耽獾昣獾庘窗獾曗禋_獾夆幢獾斺祲獾擾獾庘窗獾⑩耽獾揰獾⑩祿獾忊耽獾揰獾⑩祿獾嶁耽獾撯担_獾栤祿獾涒禍_獾涒祿獾溾窗獾忊幢獾夆禂_獯解禑獾撯幢獾昣獾忊祿獾♀窗獾忊幢獾夆禂_獯封祿獾娾祻獯扁祲獾�".split("_"),
            weekdays: "獯扳禉獯扳祹獯扳禉_獯扳耽獾忊窗獾檁獯扳禉獾夆祻獯扳禉_獯扳唇獾斺窗獾檁獯扳唇獾♀窗獾檁獯扳禉獾夆祹獾♀窗獾檁獯扳禉獾夆垂獾⑩窗獾�".split("_"),
            weekdaysShort: "獯扳禉獯扳祹獯扳禉_獯扳耽獾忊窗獾檁獯扳禉獾夆祻獯扳禉_獯扳唇獾斺窗獾檁獯扳唇獾♀窗獾檁獯扳禉獾夆祹獾♀窗獾檁獯扳禉獾夆垂獾⑩窗獾�".split("_"),
            weekdaysMin: "獯扳禉獯扳祹獯扳禉_獯扳耽獾忊窗獾檁獯扳禉獾夆祻獯扳禉_獯扳唇獾斺窗獾檁獯扳唇獾♀窗獾檁獯扳禉獾夆祹獾♀窗獾檁獯扳禉獾夆垂獾⑩窗獾�".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd D MMMM YYYY LT"
            },
            calendar: {
                sameDay: "[獯扳禉獯封祬 獯碷 LT",
                nextDay: "[獯扳禉獯解窗 獯碷 LT",
                nextWeek: "dddd [獯碷 LT",
                lastDay: "[獯扳禋獯扳祻獾� 獯碷 LT",
                lastWeek: "dddd [獯碷 LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "獯封窗獯封祬 獾� 獾⑩窗獾� %s",
                past: "獾⑩窗獾� %s",
                s: "獾夆祹獾夆唇",
                m: "獾庘祲獾忊祿獯�",
                mm: "%d 獾庘祲獾忊祿獯�",
                h: "獾欌窗獾勨窗",
                hh: "%d 獾溾窗獾欌禉獯扳祫獾夆祻",
                d: "獯扳禉獾�",
                dd: "%d o獾欌禉獯扳祻",
                M: "獯扳耽o獾撯禂",
                MM: "%d 獾夆耽獾⑩祲獾斺祻",
                y: "獯扳禉獯斥窗獾�",
                yy: "%d 獾夆禉獯斥窗獾欌祻"
            },
            week: {
                dow: 6,
                doy: 12
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        function plural(word, num) {
            var forms = word.split("_");
            return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
        }
        function relativeTimeWithPlural(number, withoutSuffix, key) {
            var format = {
                mm: "褏胁懈谢懈薪邪_褏胁懈谢懈薪懈_褏胁懈谢懈薪",
                hh: "谐芯写懈薪邪_谐芯写懈薪懈_谐芯写懈薪",
                dd: "写械薪褜_写薪褨_写薪褨胁",
                MM: "屑褨褋褟褑褜_屑褨褋褟褑褨_屑褨褋褟褑褨胁",
                yy: "褉褨泻_褉芯泻懈_褉芯泻褨胁"
            };
            if (key === "m") {
                return withoutSuffix ? "褏胁懈谢懈薪邪" : "褏胁懈谢懈薪褍";
            } else if (key === "h") {
                return withoutSuffix ? "谐芯写懈薪邪" : "谐芯写懈薪褍";
            } else {
                return number + " " + plural(format[key], +number);
            }
        }
        function monthsCaseReplace(m, format) {
            var months = {
                nominative: "褋褨褔械薪褜_谢褞褌懈泄_斜械褉械蟹械薪褜_泻胁褨褌械薪褜_褌褉邪胁械薪褜_褔械褉胁械薪褜_谢懈锌械薪褜_褋械褉锌械薪褜_胁械褉械褋械薪褜_卸芯胁褌械薪褜_谢懈褋褌芯锌邪写_谐褉褍写械薪褜".split("_"),
                accusative: "褋褨褔薪褟_谢褞褌芯谐芯_斜械褉械蟹薪褟_泻胁褨褌薪褟_褌褉邪胁薪褟_褔械褉胁薪褟_谢懈锌薪褟_褋械褉锌薪褟_胁械褉械褋薪褟_卸芯胁褌薪褟_谢懈褋褌芯锌邪写邪_谐褉褍写薪褟".split("_")
            }, nounCase = /D[oD]? *MMMM?/.test(format) ? "accusative" : "nominative";
            return months[nounCase][m.month()];
        }
        function weekdaysCaseReplace(m, format) {
            var weekdays = {
                nominative: "薪械写褨谢褟_锌芯薪械写褨谢芯泻_胁褨胁褌芯褉芯泻_褋械褉械写邪_褔械褌胁械褉_锌鈥櫻徰傂叫秆喲廮褋褍斜芯褌邪".split("_"),
                accusative: "薪械写褨谢褞_锌芯薪械写褨谢芯泻_胁褨胁褌芯褉芯泻_褋械褉械写褍_褔械褌胁械褉_锌鈥櫻徰傂叫秆喲巁褋褍斜芯褌褍".split("_"),
                genitive: "薪械写褨谢褨_锌芯薪械写褨谢泻邪_胁褨胁褌芯褉泻邪_褋械褉械写懈_褔械褌胁械褉谐邪_锌鈥櫻徰傂叫秆喲朹褋褍斜芯褌懈".split("_")
            }, nounCase = /(\[[袙胁校褍]\]) ?dddd/.test(format) ? "accusative" : /\[?(?:屑懈薪褍谢芯褩|薪邪褋褌褍锌薪芯褩)? ?\] ?dddd/.test(format) ? "genitive" : "nominative";
            return weekdays[nounCase][m.day()];
        }
        function processHoursFunction(str) {
            return function() {
                return str + "芯" + (this.hours() === 11 ? "斜" : "") + "] LT";
            };
        }
        return moment.defineLocale("uk", {
            months: monthsCaseReplace,
            monthsShort: "褋褨褔_谢褞褌_斜械褉_泻胁褨褌_褌褉邪胁_褔械褉胁_谢懈锌_褋械褉锌_胁械褉_卸芯胁褌_谢懈褋褌_谐褉褍写".split("_"),
            weekdays: weekdaysCaseReplace,
            weekdaysShort: "薪写_锌薪_胁褌_褋褉_褔褌_锌褌_褋斜".split("_"),
            weekdaysMin: "薪写_锌薪_胁褌_褋褉_褔褌_锌褌_褋斜".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY 褉.",
                LLL: "D MMMM YYYY 褉., LT",
                LLLL: "dddd, D MMMM YYYY 褉., LT"
            },
            calendar: {
                sameDay: processHoursFunction("[小褜芯谐芯写薪褨 "),
                nextDay: processHoursFunction("[袟邪胁褌褉邪 "),
                lastDay: processHoursFunction("[袙褔芯褉邪 "),
                nextWeek: processHoursFunction("[校] dddd ["),
                lastWeek: function() {
                    switch (this.day()) {
                      case 0:
                      case 3:
                      case 5:
                      case 6:
                        return processHoursFunction("[袦懈薪褍谢芯褩] dddd [").call(this);

                      case 1:
                      case 2:
                      case 4:
                        return processHoursFunction("[袦懈薪褍谢芯谐芯] dddd [").call(this);
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "蟹邪 %s",
                past: "%s 褌芯屑褍",
                s: "写械泻褨谢褜泻邪 褋械泻褍薪写",
                m: relativeTimeWithPlural,
                mm: relativeTimeWithPlural,
                h: "谐芯写懈薪褍",
                hh: relativeTimeWithPlural,
                d: "写械薪褜",
                dd: relativeTimeWithPlural,
                M: "屑褨褋褟褑褜",
                MM: relativeTimeWithPlural,
                y: "褉褨泻",
                yy: relativeTimeWithPlural
            },
            meridiemParse: /薪芯褔褨|褉邪薪泻褍|写薪褟|胁械褔芯褉邪/,
            isPM: function(input) {
                return /^(写薪褟|胁械褔芯褉邪)$/.test(input);
            },
            meridiem: function(hour, minute, isLower) {
                if (hour < 4) {
                    return "薪芯褔褨";
                } else if (hour < 12) {
                    return "褉邪薪泻褍";
                } else if (hour < 17) {
                    return "写薪褟";
                } else {
                    return "胁械褔芯褉邪";
                }
            },
            ordinalParse: /\d{1,2}-(泄|谐芯)/,
            ordinal: function(number, period) {
                switch (period) {
                  case "M":
                  case "d":
                  case "DDD":
                  case "w":
                  case "W":
                    return number + "-泄";

                  case "D":
                    return number + "-谐芯";

                  default:
                    return number;
                }
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("uz", {
            months: "褟薪胁邪褉褜_褎械胁褉邪谢褜_屑邪褉褌_邪锌褉械谢褜_屑邪泄_懈褞薪褜_懈褞谢褜_邪胁谐褍褋褌_褋械薪褌褟斜褉褜_芯泻褌褟斜褉褜_薪芯褟斜褉褜_写械泻邪斜褉褜".split("_"),
            monthsShort: "褟薪胁_褎械胁_屑邪褉_邪锌褉_屑邪泄_懈褞薪_懈褞谢_邪胁谐_褋械薪_芯泻褌_薪芯褟_写械泻".split("_"),
            weekdays: "携泻褕邪薪斜邪_袛褍褕邪薪斜邪_小械褕邪薪斜邪_效芯褉褕邪薪斜邪_袩邪泄褕邪薪斜邪_袞褍屑邪_楔邪薪斜邪".split("_"),
            weekdaysShort: "携泻褕_袛褍褕_小械褕_效芯褉_袩邪泄_袞褍屑_楔邪薪".split("_"),
            weekdaysMin: "携泻_袛褍_小械_效芯_袩邪_袞褍_楔邪".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "D MMMM YYYY, dddd LT"
            },
            calendar: {
                sameDay: "[袘褍谐褍薪 褋芯邪褌] LT [写邪]",
                nextDay: "[协褉褌邪谐邪] LT [写邪]",
                nextWeek: "dddd [泻褍薪懈 褋芯邪褌] LT [写邪]",
                lastDay: "[袣械褔邪 褋芯邪褌] LT [写邪]",
                lastWeek: "[校褌谐邪薪] dddd [泻褍薪懈 褋芯邪褌] LT [写邪]",
                sameElse: "L"
            },
            relativeTime: {
                future: "携泻懈薪 %s 懈褔懈写邪",
                past: "袘懈褉 薪械褔邪 %s 芯谢写懈薪",
                s: "褎褍褉褋邪褌",
                m: "斜懈褉 写邪泻懈泻邪",
                mm: "%d 写邪泻懈泻邪",
                h: "斜懈褉 褋芯邪褌",
                hh: "%d 褋芯邪褌",
                d: "斜懈褉 泻褍薪",
                dd: "%d 泻褍薪",
                M: "斜懈褉 芯泄",
                MM: "%d 芯泄",
                y: "斜懈褉 泄懈谢",
                yy: "%d 泄懈谢"
            },
            week: {
                dow: 1,
                doy: 7
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("vi", {
            months: "th谩ng 1_th谩ng 2_th谩ng 3_th谩ng 4_th谩ng 5_th谩ng 6_th谩ng 7_th谩ng 8_th谩ng 9_th谩ng 10_th谩ng 11_th谩ng 12".split("_"),
            monthsShort: "Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12".split("_"),
            weekdays: "ch峄� nh岷璽_th峄� hai_th峄� ba_th峄� t瓢_th峄� n膬m_th峄� s谩u_th峄� b岷".split("_"),
            weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"),
            weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "LT:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM [n膬m] YYYY",
                LLL: "D MMMM [n膬m] YYYY LT",
                LLLL: "dddd, D MMMM [n膬m] YYYY LT",
                l: "DD/M/YYYY",
                ll: "D MMM YYYY",
                lll: "D MMM YYYY LT",
                llll: "ddd, D MMM YYYY LT"
            },
            calendar: {
                sameDay: "[H么m nay l煤c] LT",
                nextDay: "[Ng脿y mai l煤c] LT",
                nextWeek: "dddd [tu岷 t峄沬 l煤c] LT",
                lastDay: "[H么m qua l煤c] LT",
                lastWeek: "dddd [tu岷 r峄搃 l煤c] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s t峄沬",
                past: "%s tr瓢峄沜",
                s: "v脿i gi芒y",
                m: "m峄檛 ph煤t",
                mm: "%d ph煤t",
                h: "m峄檛 gi峄�",
                hh: "%d gi峄�",
                d: "m峄檛 ng脿y",
                dd: "%d ng脿y",
                M: "m峄檛 th谩ng",
                MM: "%d th谩ng",
                y: "m峄檛 n膬m",
                yy: "%d n膬m"
            },
            ordinalParse: /\d{1,2}/,
            ordinal: function(number) {
                return number;
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("zh-cn", {
            months: "涓€鏈坃浜屾湀_涓夋湀_鍥涙湀_浜旀湀_鍏湀_涓冩湀_鍏湀_涔濇湀_鍗佹湀_鍗佷竴鏈坃鍗佷簩鏈�".split("_"),
            monthsShort: "1鏈坃2鏈坃3鏈坃4鏈坃5鏈坃6鏈坃7鏈坃8鏈坃9鏈坃10鏈坃11鏈坃12鏈�".split("_"),
            weekdays: "鏄熸湡鏃鏄熸湡涓€_鏄熸湡浜宊鏄熸湡涓塤鏄熸湡鍥沖鏄熸湡浜擾鏄熸湡鍏�".split("_"),
            weekdaysShort: "鍛ㄦ棩_鍛ㄤ竴_鍛ㄤ簩_鍛ㄤ笁_鍛ㄥ洓_鍛ㄤ簲_鍛ㄥ叚".split("_"),
            weekdaysMin: "鏃涓€_浜宊涓塤鍥沖浜擾鍏�".split("_"),
            longDateFormat: {
                LT: "Ah鐐筸m",
                LTS: "Ah鐐筸鍒唖绉�",
                L: "YYYY-MM-DD",
                LL: "YYYY骞碝MMD鏃�",
                LLL: "YYYY骞碝MMD鏃T",
                LLLL: "YYYY骞碝MMD鏃dddLT",
                l: "YYYY-MM-DD",
                ll: "YYYY骞碝MMD鏃�",
                lll: "YYYY骞碝MMD鏃T",
                llll: "YYYY骞碝MMD鏃dddLT"
            },
            meridiemParse: /鍑屾櫒|鏃╀笂|涓婂崍|涓崍|涓嬪崍|鏅氫笂/,
            meridiemHour: function(hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === "鍑屾櫒" || meridiem === "鏃╀笂" || meridiem === "涓婂崍") {
                    return hour;
                } else if (meridiem === "涓嬪崍" || meridiem === "鏅氫笂") {
                    return hour + 12;
                } else {
                    return hour >= 11 ? hour : hour + 12;
                }
            },
            meridiem: function(hour, minute, isLower) {
                var hm = hour * 100 + minute;
                if (hm < 600) {
                    return "鍑屾櫒";
                } else if (hm < 900) {
                    return "鏃╀笂";
                } else if (hm < 1130) {
                    return "涓婂崍";
                } else if (hm < 1230) {
                    return "涓崍";
                } else if (hm < 1800) {
                    return "涓嬪崍";
                } else {
                    return "鏅氫笂";
                }
            },
            calendar: {
                sameDay: function() {
                    return this.minutes() === 0 ? "[浠婂ぉ]Ah[鐐规暣]" : "[浠婂ぉ]LT";
                },
                nextDay: function() {
                    return this.minutes() === 0 ? "[鏄庡ぉ]Ah[鐐规暣]" : "[鏄庡ぉ]LT";
                },
                lastDay: function() {
                    return this.minutes() === 0 ? "[鏄ㄥぉ]Ah[鐐规暣]" : "[鏄ㄥぉ]LT";
                },
                nextWeek: function() {
                    var startOfWeek, prefix;
                    startOfWeek = moment().startOf("week");
                    prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? "[涓媇" : "[鏈琞";
                    return this.minutes() === 0 ? prefix + "dddAh鐐规暣" : prefix + "dddAh鐐筸m";
                },
                lastWeek: function() {
                    var startOfWeek, prefix;
                    startOfWeek = moment().startOf("week");
                    prefix = this.unix() < startOfWeek.unix() ? "[涓奭" : "[鏈琞";
                    return this.minutes() === 0 ? prefix + "dddAh鐐规暣" : prefix + "dddAh鐐筸m";
                },
                sameElse: "LL"
            },
            ordinalParse: /\d{1,2}(鏃鏈坾鍛�)/,
            ordinal: function(number, period) {
                switch (period) {
                  case "d":
                  case "D":
                  case "DDD":
                    return number + "鏃�";

                  case "M":
                    return number + "鏈�";

                  case "w":
                  case "W":
                    return number + "鍛�";

                  default:
                    return number;
                }
            },
            relativeTime: {
                future: "%s鍐�",
                past: "%s鍓�",
                s: "鍑犵",
                m: "1鍒嗛挓",
                mm: "%d鍒嗛挓",
                h: "1灏忔椂",
                hh: "%d灏忔椂",
                d: "1澶�",
                dd: "%d澶�",
                M: "1涓湀",
                MM: "%d涓湀",
                y: "1骞�",
                yy: "%d骞�"
            },
            week: {
                dow: 1,
                doy: 4
            }
        });
    });
    (function(factory) {
        factory(moment);
    })(function(moment) {
        return moment.defineLocale("zh-tw", {
            months: "涓€鏈坃浜屾湀_涓夋湀_鍥涙湀_浜旀湀_鍏湀_涓冩湀_鍏湀_涔濇湀_鍗佹湀_鍗佷竴鏈坃鍗佷簩鏈�".split("_"),
            monthsShort: "1鏈坃2鏈坃3鏈坃4鏈坃5鏈坃6鏈坃7鏈坃8鏈坃9鏈坃10鏈坃11鏈坃12鏈�".split("_"),
            weekdays: "鏄熸湡鏃鏄熸湡涓€_鏄熸湡浜宊鏄熸湡涓塤鏄熸湡鍥沖鏄熸湡浜擾鏄熸湡鍏�".split("_"),
            weekdaysShort: "閫辨棩_閫变竴_閫变簩_閫变笁_閫卞洓_閫变簲_閫卞叚".split("_"),
            weekdaysMin: "鏃涓€_浜宊涓塤鍥沖浜擾鍏�".split("_"),
            longDateFormat: {
                LT: "Ah榛瀖m",
                LTS: "Ah榛瀖鍒唖绉�",
                L: "YYYY骞碝MMD鏃�",
                LL: "YYYY骞碝MMD鏃�",
                LLL: "YYYY骞碝MMD鏃T",
                LLLL: "YYYY骞碝MMD鏃dddLT",
                l: "YYYY骞碝MMD鏃�",
                ll: "YYYY骞碝MMD鏃�",
                lll: "YYYY骞碝MMD鏃T",
                llll: "YYYY骞碝MMD鏃dddLT"
            },
            meridiemParse: /鏃╀笂|涓婂崍|涓崍|涓嬪崍|鏅氫笂/,
            meridiemHour: function(hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === "鏃╀笂" || meridiem === "涓婂崍") {
                    return hour;
                } else if (meridiem === "涓崍") {
                    return hour >= 11 ? hour : hour + 12;
                } else if (meridiem === "涓嬪崍" || meridiem === "鏅氫笂") {
                    return hour + 12;
                }
            },
            meridiem: function(hour, minute, isLower) {
                var hm = hour * 100 + minute;
                if (hm < 900) {
                    return "鏃╀笂";
                } else if (hm < 1130) {
                    return "涓婂崍";
                } else if (hm < 1230) {
                    return "涓崍";
                } else if (hm < 1800) {
                    return "涓嬪崍";
                } else {
                    return "鏅氫笂";
                }
            },
            calendar: {
                sameDay: "[浠婂ぉ]LT",
                nextDay: "[鏄庡ぉ]LT",
                nextWeek: "[涓媇ddddLT",
                lastDay: "[鏄ㄥぉ]LT",
                lastWeek: "[涓奭ddddLT",
                sameElse: "L"
            },
            ordinalParse: /\d{1,2}(鏃鏈坾閫�)/,
            ordinal: function(number, period) {
                switch (period) {
                  case "d":
                  case "D":
                  case "DDD":
                    return number + "鏃�";

                  case "M":
                    return number + "鏈�";

                  case "w":
                  case "W":
                    return number + "閫�";

                  default:
                    return number;
                }
            },
            relativeTime: {
                future: "%s鍏�",
                past: "%s鍓�",
                s: "骞剧",
                m: "涓€鍒嗛悩",
                mm: "%d鍒嗛悩",
                h: "涓€灏忔檪",
                hh: "%d灏忔檪",
                d: "涓€澶�",
                dd: "%d澶�",
                M: "涓€鍊嬫湀",
                MM: "%d鍊嬫湀",
                y: "涓€骞�",
                yy: "%d骞�"
            }
        });
    });
    moment.locale("en");
    function makeGlobal(shouldDeprecate) {
        if (typeof ender !== "undefined") {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate("Accessing Moment through the global scope is " + "deprecated, and will be removed in an upcoming " + "release.", moment);
        } else {
            globalScope.moment = moment;
        }
    }
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === "function" && define.amd) {
        define("moment", [ "require", "exports", "module" ], function(require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                globalScope.moment = oldGlobalMoment;
            }
            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);

(function($) {
    jQuery.fn.LinberShare = function(options) {
        options = $.extend({
            params: {
                url: location.href
            },
            socials: [ "vk", "facebook" ],
            onClick: function() {}
        }, options);
        var socials = {
            vk: {
                url: "http://vkontakte.ru/share.php",
                pattern: "?url={url}"
            },
            facebook: {
                url: "http://www.facebook.com/sharer/sharer.php",
                pattern: "?u={url}"
            },
            twitter: {
                url: "https://twitter.com/share",
                pattern: "?url={url}"
            },
            mail: {
                url: "http://connect.mail.ru/share",
                pattern: "?url={url}"
            },
            ok: {
                url: "https://connect.ok.ru/dk?st.cmd=WidgetSharePreview",
                pattern: "&st.shareUrl={url}"
            },
            google: {
                url: "https://plus.google.com/share",
                pattern: "?url={url}"
            },
            tumblr: {
                url: "https://www.tumblr.com/widgets/share/tool",
                pattern: "?shareSource=legacy&url={url}"
            },
            pinterest: {
                url: "http://pinterest.com/pin/create/button/",
                pattern: "?url={url}&media={image}"
            },
            reddit: {
                url: "https://www.reddit.com/submit",
                pattern: "?url={url}"
            },
            viber: {
                url: "viber://forward",
                pattern: "?text={url}"
            },
            whatsapp: {
                url: "whatsapp://send",
                pattern: "?text={url}"
            },
            telegram: {
                url: "https://telegram.me/share/url",
                pattern: "?url={url}"
            },
            skype: {
                url: "https://web.skype.com/share",
                pattern: "?url={url}"
            }
        };
        function popup(url) {
            window.open(url, "", "toolbar=0,status=0,width=626,height=436");
        }
        var make = function() {
            var $ul = $("<ul/>");
            var listItems = [];
            for (var socialIndex in options.socials) {
                var socialName = options.socials[socialIndex];
                if (!socials.hasOwnProperty(socialName)) {
                    continue;
                }
                var pattern = socials[socialName].pattern;
                var url = socials[socialName].url;
                for (var paramName in options.params) {
                    pattern = pattern.replace("{" + paramName + "}", encodeURIComponent(options.params[paramName]));
                }
                url = url + pattern;
                listItems.push('<li class="' + socialName + '"><a href="' + url + '" target="_blank"></a></li>');
            }
            $ul.html(listItems.join(""));
            $ul.find("a").on("click", function() {
                var social = $(this).parent().attr("class");
                var url = $(this).attr("href");
                popup(url);
                if (options.onClick) {
                    options.onClick(social);
                }
                return false;
            });
            $(this).html($ul);
            $(this).addClass("LinberShare");
        };
        return this.each(make);
    };
})(jQuery);

define("linberShare", [ "jquery" ], function() {});

define("ui/js/models/urlInfoModel", [ "app", "underscore", "backbone" ], function(App, _, Backbone) {
    "use strict";
    return Backbone.Model.extend({
        url: function() {
            return App.Config.Urls.ApiCreateUrlInfo;
        }
    });
});

define("ui/js/models/downloadModel", [ "app", "underscore", "backbone" ], function(App, _, Backbone) {
    "use strict";
    return Backbone.Model.extend({
        url: function() {
            return App.Config.Urls.ApiCreateDownload;
        }
    });
});

define("shared/js/models/balanceModel", [ "app", "underscore", "backbone" ], function(App, _, Backbone) {
    "use strict";
    return Backbone.Model.extend({
        defaults: {
            units: 0
        },
        url: function() {
            return App.Config.Urls.ApiGetBalance;
        },
        parse: function(raw) {
            this.attributes.units = raw.Units;
            return raw;
        }
    });
});

define("text", [ "module" ], function(module) {
    "use strict";
    var text, fs, Cc, Ci, xpcIsWindows, progIds = [ "Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0" ], xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im, hasLocation = typeof location !== "undefined" && location.href, defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ""), defaultHostName = hasLocation && location.hostname, defaultPort = hasLocation && (location.port || undefined), buildMap = {}, masterConfig = module.config && module.config() || {};
    function useDefault(value, defaultValue) {
        return value === undefined || value === "" ? defaultValue : value;
    }
    function isSamePort(protocol1, port1, protocol2, port2) {
        if (port1 === port2) {
            return true;
        } else if (protocol1 === protocol2) {
            if (protocol1 === "http") {
                return useDefault(port1, "80") === useDefault(port2, "80");
            } else if (protocol1 === "https") {
                return useDefault(port1, "443") === useDefault(port2, "443");
            }
        }
        return false;
    }
    text = {
        version: "2.0.15",
        strip: function(content) {
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },
        jsEscape: function(content) {
            return content.replace(/(['\\])/g, "\\$1").replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r").replace(/[\u2028]/g, "\\u2028").replace(/[\u2029]/g, "\\u2029");
        },
        createXhr: masterConfig.createXhr || function() {
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}
                    if (xhr) {
                        progIds = [ progId ];
                        break;
                    }
                }
            }
            return xhr;
        },
        parseName: function(name) {
            var modName, ext, temp, strip = false, index = name.lastIndexOf("."), isRelative = name.indexOf("./") === 0 || name.indexOf("../") === 0;
            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1);
            } else {
                modName = name;
            }
            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }
            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },
        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,
        useXhr: function(url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort, match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];
            uHostName = uHostName.split(":");
            uPort = uHostName[1];
            uHostName = uHostName[0];
            return (!uProtocol || uProtocol === protocol) && (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) && (!uPort && !uHostName || isSamePort(uProtocol, uPort, protocol, port));
        },
        finishLoad: function(name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },
        load: function(name, req, onLoad, config) {
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }
            masterConfig.isBuild = config && config.isBuild;
            var parsed = text.parseName(name), nonStripName = parsed.moduleName + (parsed.ext ? "." + parsed.ext : ""), url = req.toUrl(nonStripName), useXhr = masterConfig.useXhr || text.useXhr;
            if (url.indexOf("empty:") === 0) {
                onLoad();
                return;
            }
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function(content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function(err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                req([ nonStripName ], function(content) {
                    text.finishLoad(parsed.moduleName + "." + parsed.ext, parsed.strip, content, onLoad);
                });
            }
        },
        write: function(pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName, "define(function () { return '" + content + "';});\n");
            }
        },
        writeFile: function(pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName), extPart = parsed.ext ? "." + parsed.ext : "", nonStripName = parsed.moduleName + extPart, fileName = req.toUrl(parsed.moduleName + extPart) + ".js";
            text.load(nonStripName, req, function(value) {
                var textWrite = function(contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function(moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };
                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };
    if (masterConfig.env === "node" || !masterConfig.env && typeof process !== "undefined" && process.versions && !!process.versions.node && !process.versions["node-webkit"] && !process.versions["atom-shell"]) {
        fs = require.nodeRequire("fs");
        text.get = function(url, callback, errback) {
            try {
                var file = fs.readFileSync(url, "utf8");
                if (file[0] === "\ufeff") {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === "xhr" || !masterConfig.env && text.createXhr()) {
        text.get = function(url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open("GET", url, true);
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }
            xhr.onreadystatechange = function(evt) {
                var status, err;
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        err = new Error(url + " HTTP status: " + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }
                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === "rhino" || !masterConfig.env && typeof Packages !== "undefined" && typeof java !== "undefined") {
        text.get = function(url, callback) {
            var stringBuffer, line, encoding = "utf-8", file = new java.io.File(url), lineSeparator = java.lang.System.getProperty("line.separator"), input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)), content = "";
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();
                if (line && line.length() && line.charAt(0) === 65279) {
                    line = line.substring(1);
                }
                if (line !== null) {
                    stringBuffer.append(line);
                }
                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                content = String(stringBuffer.toString());
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === "xpconnect" || !masterConfig.env && typeof Components !== "undefined" && Components.classes && Components.interfaces) {
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils["import"]("resource://gre/modules/FileUtils.jsm");
        xpcIsWindows = "@mozilla.org/windows-registry-key;1" in Cc;
        text.get = function(url, callback) {
            var inStream, convertStream, fileObj, readData = {};
            if (xpcIsWindows) {
                url = url.replace(/\//g, "\\");
            }
            fileObj = new FileUtils.File(url);
            try {
                inStream = Cc["@mozilla.org/network/file-input-stream;1"].createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);
                convertStream = Cc["@mozilla.org/intl/converter-input-stream;1"].createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(), Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);
                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || "") + ": " + e);
            }
        };
    }
    return text;
});

define("text!ui/views/mediaRowView/main.html", [], function() {
    return '\r\n<div class="w-jm-popup__button w-jm-popup__wrap__content-row__link\r\n     {{#data.downloaded}}\r\n        w-jm-popup__button--2 w-jm-popup__wrap__content-row__link--downloaded\r\n     {{/data.downloaded}}\r\n     ">\r\n    {{#t}}Skachat{{/t}}\r\n</div>\r\n<div class="w-jm-popup__wrap__content-row__info-media">\r\n    <div class="w-jm-popup__wrap__content-row__info-media__name">\r\n        {{#data.displayName}}\r\n        {{data.displayName}}\r\n        {{/data.displayName}}\r\n        {{^data.displayName}}\r\n        {{#t}}Bez_nazvaniya{{/t}}\r\n        {{/data.displayName}}\r\n    </div>\r\n    <div class="w-jm-popup__wrap__content-row__info-media__type">\r\n        \r\n        {{#conditions.isAudio}}\r\n            {{#t}}Audio{{/t}}\r\n        {{/conditions.isAudio}}\r\n        {{^conditions.isAudio}}\r\n            {{#t}}Video{{/t}}\r\n        {{/conditions.isAudio}}\r\n\r\n        {{#data.size}}\r\n        -\r\n        {{#roundSize}}{{/roundSize}} {{#t}}Mb{{/t}}\r\n\r\n        {{/data.size}}\r\n\r\n        {{#data.duration}}\r\n        / {{durationString}} / {{data.bitrate}} kbps\r\n        {{/data.duration}}\r\n    </div>\r\n    <div class="w-jm-popup__wrap__content-row__info-media__time-container">\r\n        <div class="w-jm-popup__wrap__content-row__info-media__time"></div>\r\n        {{#conditions.showPreview}}\r\n        <div class="\r\n             {{#data.showPreview}}\r\n             w-jm-flaticon-pause51\r\n             {{/data.showPreview}}\r\n             {{^data.showPreview}}\r\n             w-jm-flaticon-play127\r\n             {{/data.showPreview}}\r\n             w-jm-popup__wrap__content-row__info-media__preview"\r\n             title="{{#data.showPreview}} {{#t}}Priostanovit_proigryvaniye{{/t}} {{/data.showPreview}} {{^data.showPreview}} {{#t}}Proigrat_v_brauzere{{/t}} {{/data.showPreview}}">\r\n\r\n        </div>\r\n        {{/conditions.showPreview}}\r\n        <div class="w-jm-flaticon-cancel29 w-jm-popup__wrap__content-row__info-media__remove" title="{{#t}}Udalit{{/t}}"></div>\r\n    </div>\r\n</div>\r\n<div class="w-jm-popup__wrap__content-row__preview" {{#data.showPreview}} style="display: block" {{/data.showPreview}}>\r\n    {{#data.showPreview}}\r\n        {{#conditions.isAudio}}\r\n        <audio src="{{playUrl}}" controls preload="none"></audio>\r\n        {{/conditions.isAudio}}\r\n        {{^conditions.isAudio}}\r\n        <video src="{{playUrl}}" controls preload="none"></video>\r\n        {{/conditions.isAudio}}\r\n    {{/data.showPreview}}\r\n</div>\r\n';
});

define("ui/js/views/mediaRowView", [ "app", "jquery", "underscore", "backbone", "i18n", "mustache", "moment", "text!../../views/mediaRowView/main.html" ], function(App, $, _, Backbone, I18n, Mustache, Moment, MediaRowTmpl) {
    "use strict";
    return Backbone.View.extend({
        className: "w-jm-popup__wrap__content-row",
        events: {
            "click .w-jm-popup__wrap__content-row__link": "downloadFile",
            "click .w-jm-popup__wrap__content-row__info-media__remove": function() {
                if (this.model.collection) {
                    this.model.collection.remove(this.model);
                }
                this.model.destroy();
            },
            "click .w-jm-popup__wrap__content-row__info-media__preview": function(e) {
                var $el = $(e.currentTarget);
                if ($(".w-jm-popup").hasClass("empty-balance")) {
                    App.MessageBind.trigger("ShowBalanceWindow");
                    return false;
                }
                if ($el.hasClass("w-jm-flaticon-play127")) {
                    this.model.set("showPreview", true);
                } else {
                    this.model.set("showPreview", false);
                }
            },
            mouseenter: function() {
                this.updateTimeLoaded();
                this.$el.addClass("w-jm-popup__wrap__content-row--hover");
            },
            mouseleave: function() {
                this.$el.removeClass("w-jm-popup__wrap__content-row--hover");
            }
        },
        initialize: function() {
            this.listenTo(this.model, "change", function(model, options) {
                if (!model.hasChanged("downloaded")) {
                    this.render();
                }
            });
            this.listenTo(this.model, "destroy", function() {
                this.destroy();
            });
            this.listenTo(this.model, "change:downloaded", function(model, value) {
                if (value) {
                    this.$(".w-jm-popup__wrap__content-row__link").addClass("w-jm-popup__button--2 w-jm-popup__wrap__content-row__link--downloaded");
                    App.MessageBind.trigger("DownloadedFile", {
                        url: this.model.get("linkUrl")
                    });
                } else {
                    this.$(".w-jm-popup__wrap__content-row__link").removeClass("w-jm-popup__button--2 w-jm-popup__wrap__content-row__link--downloaded");
                }
            });
            this.listenTo(this.model, "change:showPreview", function(model, value) {
                var $preview = this.$(".w-jm-popup__wrap__content-row__preview");
                var $previewButton = this.$(".w-jm-popup__wrap__content-row__info-media__preview");
                if (value) {
                    $previewButton.removeClass("w-jm-flaticon-play127").addClass("w-jm-flaticon-pause51");
                    $previewButton.attr("title", i18n.t("Priostanovit_proigryvaniye"));
                    if ($preview.find("audio").length) {
                        $preview.find("audio").attr("preload", "metadata");
                    } else {
                        $preview.find("video").attr("preload", "metadata");
                    }
                    App.Tracker.sendEvent("袨褌泻褉褘褌懈械 锌褉械写锌褉芯褋谢褍褕懈胁邪薪懈褟 褎邪泄谢邪", location.href);
                    $preview.show();
                } else {
                    $previewButton.removeClass("w-jm-flaticon-pause51").addClass("w-jm-flaticon-play127");
                    $previewButton.attr("title", i18n.t("Proigrat_v_brauzere"));
                    $preview.hide();
                    if ($preview.find("audio").length) {
                        $preview.find("audio").get(0).pause();
                    } else {
                        $preview.find("video").get(0).pause();
                    }
                    App.Tracker.sendEvent("袟邪泻褉褘褌懈械 锌褉械写锌褉芯褋谢褍褕懈胁邪薪懈褟 褎邪泄谢邪", location.href);
                }
            });
            this.render();
            return this;
        },
        destroy: function() {
            this.remove();
        },
        render: function() {
            this.model.set("downloadFileName", this.model.get("downloadFileName") ? this.model.get("downloadFileName").replace('"', "") : "");
            this.$el.html(Mustache.render(MediaRowTmpl, {
                data: this.model.attributes,
                playUrl: this.model.get("linkUrl") + (this.model.get("linkUrl").indexOf("?") > -1 ? "&" : "?") + App.Config.PatternInUrls.IsPlayRequest,
                durationString: $.proxy(function() {
                    if (this.model.get("duration")) {
                        var durationObj = moment.duration(this.model.get("duration"), "seconds");
                        var durationString = (durationObj.seconds().toString().length === 1 ? "0" : "") + durationObj.seconds();
                        durationString = durationObj.minutes() ? durationObj.minutes() + ":" + durationString : "0:" + durationString;
                        durationString = durationObj.hours() ? durationObj.hours() + ":" + durationString : durationString;
                        return durationString;
                    } else {
                        return "";
                    }
                }, this)(),
                conditions: {
                    showPreview: !this.model.get("noPreview") && !this.model.get("errorGetBitrateAndDuration"),
                    isAudio: this.model.get("type") === "audio"
                },
                moment: Moment,
                roundSize: $.proxy(function() {
                    return $.proxy(function(val, render) {
                        return render(App.Helpers.Round(this.model.get("size") / 1024 / 1024, 1));
                    }, this);
                }, this),
                t: function() {
                    return function(val, render) {
                        return render(I18n.t($.trim(val)));
                    };
                }
            }));
            if (!this.model.hasChanged("showPreview")) {
                this.$el.one("webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend", function() {
                    $(this).removeClass("w-jm-popup__wrap__content-row--last-added");
                });
                if (this.$el.is(":visible")) {
                    this.$el.addClass("w-jm-popup__wrap__content-row--last-added");
                }
            }
            return this;
        },
        downloadFile: function(e) {
            if ($(".w-jm-popup").hasClass("empty-balance")) {
                App.MessageBind.trigger("ShowBalanceWindow");
                return false;
            }
            this.model.set("downloaded", true);
            var url = this.model.get("linkUrl");
            var fileName = this.model.get("downloadFileName");
            var urlObj = document.createElement("a");
            urlObj.href = url;
            url = url + (url.indexOf("?") > -1 ? "&" : "?") + App.Config.PatternInUrls.IsDownloadRequest + JSON.stringify({
                tid: this.model.get("tabId"),
                rid: this.model.get("requestId")
            });
            var aObj = document.createElement("a");
            aObj.style.display = "none";
            aObj.download = fileName;
            aObj.href = url;
            aObj.target = "_blank";
            this.$el.append(aObj);
            if (App.Data.CurrentProtocol === "https:" && urlObj.protocol === "http:" && navigator.userAgent.search(/Firefox/) > 0) {
                window.open(aObj.href);
            } else {
                aObj.click();
            }
            setTimeout(function() {
                $(aObj).remove();
            }, 5e3);
            if (aObj.href.indexOf(App.Config.Urls.Site) > -1) {
                window.parent.postMessage(JSON.stringify({
                    source: "MS",
                    type: "DownloadFileClick"
                }), App.Config.Urls.Site);
            }
            return false;
        },
        updateTimeLoaded: function() {
            this.$(".w-jm-popup__wrap__content-row__info-media__time").html(Moment(this.model.get("timeLoad")).fromNow());
        }
    });
});

define("text!ui/views/mediaView/socialShare.html", [], function() {
    return '\r\n<div class="w-jm-popup__wrap__share__td">\r\n    <div class="w-jm-popup__wrap__share__text w-jm-popup__wrap__share__text-normal">\r\n        {{#t}}Vam_nravitsya_nash_plagin{{/t}}\r\n    </div>\r\n    <div class="w-jm-popup__wrap__share__text w-jm-popup__wrap__share__text-blocked">\r\n        {{#t}}Vy_davno_polzuyetes_plaginom{{/t}}\r\n    </div>\r\n    \r\n    <div class="socials small"></div>\r\n    <div class="review" style="display: none">\r\n        <a href="{{reviewLink}}" target="_blank" class="w-jm-popup__button">{{#t}}Review{{/t}}</a>\r\n    </div>\r\n    <div class="w-jm-popup__wrap__share__cancel" title="{{#t}}UI/Close{{/t}}"></div>\r\n</div>\r\n';
});

define("ui/js/views/socialShareView", [ "app", "jquery", "underscore", "backbone", "i18n", "mustache", "text!../../views/mediaView/socialShare.html" ], function(App, $, _, Backbone, I18n, Mustache, ShareTmpl) {
    "use strict";
    return Backbone.View.extend({
        className: "w-jm-popup__wrap__share__table",
        dataShare: {},
        events: {
            "click .w-jm-popup__wrap__share__socials .social": "share"
        },
        initialize: function() {
            $.getJSON(App.Config.Urls.ApiGetUrlShareLink.format([ App.Config.Lang ])).done(function(data) {
                this.dataShare = data;
            }.bind(this)).always(function() {
                this.render();
            }.bind(this));
            return this;
        },
        render: function() {
            this.$el.html(Mustache.render(ShareTmpl, {
                reviewLink: function() {
                    switch (App.Data.Browser) {
                      case "Firefox":
                        {
                            return App.Config.Browser.Firefox.ReviewUrl;
                            break;
                        }

                      case "Opera":
                        {
                            return App.Config.Browser.Opera.ReviewUrl;
                            break;
                        }

                      default:
                        {
                            return App.Config.Browser.Chrome.ReviewUrl;
                            break;
                        }
                    }
                }(),
                t: function() {
                    return function(val, render) {
                        return render(I18n.t($.trim(val)));
                    };
                }
            }));
            this.$(".w-jm-popup__wrap__share__td .socials").LinberShare({
                socials: [ "vk", "facebook", "ok", "mail", "twitter", "google", "tumblr", "pinterest", "reddit" ],
                params: {
                    image: this.dataShare.ImageLink,
                    url: this.dataShare.Link
                },
                onClick: function(social) {
                    App.Helpers.GoogleAnalitycs.SendEvent("锟斤拷锟斤拷锟斤拷", "锟斤拷锟斤拷锟斤拷 锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷 锟� 锟斤拷锟�. 锟斤拷锟斤拷", social);
                }
            });
            return this;
        }
    });
});

define("text!ui/views/mediaView/main.html", [], function() {
    return '<div class="w-jm-popup__wrap">\r\n\r\n    {{#isShowBalance}}\r\n    <div class="w-jm-popup__wrap__button-balance" title="{{#t}}UI/BalanceClickToMore{{/t}}">\r\n        <span class="count">{{balance}}</span>\r\n        <span class="text">{{#t}}UI/downloads({{balance}}){{/t}}</span>\r\n    </div>\r\n    {{/isShowBalance}}\r\n    <div class="w-jm-popup__wrap__button-share" title="{{#t}}UI/Share{{/t}}"></div>\r\n    <div class="w-jm-popup__wrap__button-left" title="{{#t}}Svernut{{/t}}"></div>\r\n    <div class="w-jm-popup__wrap__button-close" title="{{#t}}UI/ClearList{{/t}}"></div>\r\n    <div class="w-jm-popup__wrap__title">\r\n        {{#t}}Obnaruzheny_mediafayly{{/t}} -\r\n        <div class="w-jm-popup__wrap__title__count">{{count}}</div>\r\n\r\n    </div>\r\n    <div class="w-jm-popup__wrap__content"></div>\r\n    <div class="w-jm-popup__wrap__close-info">\r\n        <div class="w-jm-popup__wrap__close-info__text">\r\n            <div class="w-jm-popup__text">{{#t}}Vy_deystvitelno_khotite_otklyuchit_rasshireniye{{/t}}</div>\r\n            <div class="w-jm-popup__subtext">{{#t}}Vy_vsegda_smozhete_vklyuchit_yego{{/t}}</div>\r\n        </div>\r\n        <div class="w-jm-popup__wrap__close-info__button-container">\r\n            <div class="w-jm-popup__button w-jm-popup__wrap__close-info__button-ok">\r\n                {{#t}}Otklyuchit_plagin{{/t}}\r\n            </div>\r\n            <div class="w-jm-popup__button w-jm-popup__button--2 w-jm-popup__wrap__close-info__button-noShowAuto">\r\n                {{#t}}UI/NoShowWindowAutomatically{{/t}}\r\n            </div>\r\n            <div class="w-jm-popup__button w-jm-popup__button--2 w-jm-popup__wrap__close-info__button-turn">\r\n                {{#t}}Svernut{{/t}}\r\n            </div>\r\n            <div class="w-jm-popup__button w-jm-popup__button--2 w-jm-popup__wrap__close-info__button-cancel">\r\n                {{#t}}Otmena{{/t}}\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <div class="w-jm-popup__wrap__share"></div>\r\n\r\n    <div class="w-jm-popup__wrap__balance">\r\n        <div class="icon-close" title="{{#t}}UI/Close{{/t}}"></div>\r\n        <div class="table-wrap">\r\n            <div class="td-wrap">\r\n                <div class="icon-money"></div>\r\n                <div class="text">\r\n                    {{#t}}UI/TheAccountRemains({{balance}}){{/t}}\r\n                </div>\r\n                <div class="w-jm-popup__button payment-button">\r\n                    {{#t}}UI/PayDownloads{{/t}}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <div class="advertise-bottom"></div>\r\n\r\n</div>\r\n\r\n';
});

define("text!ui/views/mediaView/banner.html", [], function() {
    return '<a href="{{url}}" class="banner" target="_blank">\r\n    <img src="{{image}}" alt="" />\r\n</a>\r\n\r\n<div class="disable">\r\n    {{#t}}UI/DisableAd{{/t}}\r\n</div>';
});

define("ui/js/views/mediaView", [ "app", "jquery", "underscore", "backbone", "i18n", "mustache", "moment", "linberShare", "ui/js/models/urlInfoModel", "ui/js/models/downloadModel", "shared/js/models/balanceModel", "ui/js/views/mediaRowView", "ui/js/views/socialShareView", "text!../../views/mediaView/main.html", "text!../../views/mediaView/banner.html" ], function(App, $, _, Backbone, I18n, Mustache, Moment, LinberShare, UrlInfoModel, DownloadModel, BalanceModel, MediaRowView, SocialShareView, MediaViewTmpl, BannerTmpl) {
    "use strict";
    return Backbone.View.extend({
        className: "w-jm-popup",
        balanceModel: null,
        initBalanceValue: null,
        listDownloadedUrls: [],
        listBanners: null,
        intervalChangeBanner: 60 * 1e3,
        timeoutIdChangeBanner: null,
        indexShowBottomBanner: 0,
        events: {
            "click .w-jm-popup__wrap__button-close": function() {
                this.clearListMedia();
            },
            "click .w-jm-popup__bookmark": function() {
                this.model.set("show", true);
            },
            "click .w-jm-popup__wrap__title": function() {
                this.model.set("showContent", true);
                this.model.set("minimized", false);
            },
            "click .w-jm-popup__wrap__button-left": function() {
                if (this.model.get("minimized")) {
                    this.model.set("minimized", false);
                } else {
                    this.model.set("minimized", true);
                }
            },
            "click .w-jm-popup__wrap__close-info__button-cancel": function() {
                this.model.set("showCloseWindow", false);
            },
            "click .w-jm-popup__wrap__close-info__button-ok": function() {
                this.model.set("disableExtensionCurrentSite", true);
                this.model.set("show", false);
            },
            "click .w-jm-popup__wrap__close-info__button-turn": function() {
                this.model.set("minimized", true);
                this.model.set("showCloseWindow", false);
            },
            "click .w-jm-popup__wrap__close-info__button-noShowAuto": function() {
                this.model.set("showWindowAutomatically", false);
                this.model.set("show", false);
            },
            "click .w-jm-popup__wrap__button-share": function() {
                this.showSocialShareWindow();
            },
            "click .w-jm-popup__wrap__share__cancel": function() {
                this.hideSocialShareWindow();
            },
            "click .w-jm-popup__wrap__balance .payment-button": function() {
                window.open("https://mediasave.ru/info/price/");
                return false;
            },
            "click .w-jm-popup__wrap__balance .payment-free": function() {
                window.open("https://mediasave.ru/info/partner/");
                return false;
            },
            "click .w-jm-popup__wrap__balance .icon-close": "hideBalanceWindow",
            "click .w-jm-popup__wrap__button-balance": "showBalanceWindow",
            "click .advertise-bottom .disable": "showBalanceWindow"
        },
        initialize: function() {
            this.backgroundPopupAction();
            this.balanceModel = new BalanceModel();
            this.listenTo(this.balanceModel, "change", this.changeBalanceInView);
            this.listenTo(this.balanceModel, "sync", this.changeBalanceInView);
            this.balanceModel.fetch();
            this.listenTo(this.collection, "change", this.backgroundPopupAction);
            this.listenTo(this.model, "change:disableExtensionCurrentSite", this.backgroundPopupAction);
            App.Helpers.SendMessage("ClearLoadingUrls", [ "background" ], null);
            App.MessageBind.on("AddFile", $.proxy(function(data) {
                var model = _.find(this.collection.models, function(item) {
                    if (item.get("uid") === data.uid) {
                        return true;
                    }
                });
                if (model) {
                    model.save(data);
                } else {
                    model = new this.collection.model(data);
                    model.save();
                    this.collection.add(model);
                }
            }, this));
            App.MessageBind.on("AddedFileChange", $.proxy(function(data) {
                if (!data.isSkipAddUrl) {
                    new UrlInfoModel({
                        url: data.linkUrl,
                        artist: data.artist ? data.artist : "",
                        name: data.name ? data.name : "",
                        duration: parseInt(data.duration),
                        bitrate: parseInt(data.bitrate),
                        isErrorBitrateOrDuration: data.errorGetBitrateAndDuration ? data.errorGetBitrateAndDuration : false,
                        isErrorName: data.errorGetName ? data.errorGetName : false
                    }).save();
                }
                var model = _.find(this.collection.models, function(item) {
                    if (item.get("uid") === data.uid) {
                        return true;
                    }
                });
                if (model) {
                    model.save(data);
                } else {
                    model = new this.collection.model(data);
                    model.save();
                    this.collection.add(model);
                }
            }, this));
            App.MessageBind.on("ChangeExtensionSettings", $.proxy(function(data) {
                if (data.hasOwnProperty("disableExtensionCurrentSite")) {
                    if (data.disableExtensionCurrentSite === "enabled") {
                        this.model.set("disableExtensionCurrentSite", false);
                    } else {
                        this.model.set("disableExtensionCurrentSite", true);
                    }
                }
                if (data.hasOwnProperty("showWindowAutomatically")) {
                    if (data.showWindowAutomatically === "enabled") {
                        this.model.set("showWindowAutomatically", true);
                    } else {
                        this.model.set("showWindowAutomatically", false);
                    }
                }
            }, this));
            App.MessageBind.on("GeMainWindowModelData", $.proxy(function(data) {
                var mainWindow = this.model.attributes;
                var countMedia = this.collection.length;
                App.MessageBind.trigger("GeMainWindowModelDataCallback", {
                    mainWindow: mainWindow,
                    countMedia: countMedia
                });
            }, this));
            App.MessageBind.on("DownloadedFile", $.proxy(function(data) {
                this.model.set("countDownloadedFiles", this.model.get("countDownloadedFiles") + 1);
            }, this));
            App.MessageBind.on("DownloadFileSuccess", function(data) {
                if (this.listDownloadedUrls.indexOf(data.url) === -1 && data.url.indexOf(App.Config.Urls.Site) === -1) {
                    if (App.Data.CurrentTabInfo.id == data.ownerTabId) {
                        var modelDownload = new DownloadModel({
                            SiteUrl: App.Data.CurrentDomain,
                            Url: data.url
                        });
                        modelDownload.save();
                    }
                    this.listDownloadedUrls.push(data.url);
                    var balance = this.balanceModel.get("units");
                    if (balance > 0) {
                        this.balanceModel.set("units", balance - 1);
                    }
                }
            }.bind(this));
            App.MessageBind.on("UpdateBalanceInt", function(balance) {
                this.balanceModel.set("units", balance.Units);
                this.balanceModel.set("Units", balance.Units);
                this.balanceModel.set("Expired", balance.Expired);
                this.balanceModel.set("IsActive", balance.IsActive);
                if (balance.Units > 0 || balance.IsActive) {
                    this.hideBalanceWindow();
                }
            }.bind(this));
            App.MessageBind.on("ShowBalanceWindow", function() {
                this.showBalanceWindow();
            }.bind(this));
            App.MessageBind.on("ShowMainWindow", $.proxy(function(data) {
                this.model.set("show", true);
                this.model.set("showContent", true);
                this.model.set("minimized", false);
            }, this));
            App.MessageBind.on("ChangePositionSetting", $.proxy(function(data) {
                this.model.set("position", data);
            }, this));
            this.listenTo(this.model, "change:disableExtensionCurrentSite", function(model, value) {
                if (value) {
                    model.set("show", false);
                } else if (this.collection.length > 0 && model.get("showWindowAutomatically")) {
                    model.set("show", true);
                    model.set("showContent", true);
                }
            });
            this.listenTo(this.model, "change:showWindowAutomatically", function(model, value) {
                if (!value) {
                    model.set("show", false);
                } else if (this.collection.length > 0 && !model.get("disableExtensionCurrentSite")) {
                    model.set("show", true);
                    model.set("showContent", true);
                }
            });
            this.listenTo(this.model, "change:showCloseWindow", function(model, value) {
                if (value) {
                    this.showCloseWindow();
                } else {
                    this.hideCloseWindow();
                }
            });
            this.listenTo(this.model, "change:show", function(model, value) {
                model.set("showCloseWindow", false);
                if (value) {
                    this.showView();
                } else {
                    this.hideView();
                }
            });
            this.listenTo(this.model, "change:showContent", function(model, value) {
                if (value) {
                    this.$el.addClass("w-jm-popup--window-show-content");
                    if (App.Config.Lang != "ru") {
                        this.renderBottomBanner();
                    }
                } else {
                    this.$el.removeClass("w-jm-popup--window-show-content");
                }
            });
            this.listenTo(this.model, "change:minimized", function(model, value) {
                if (value) {
                    this.$el.addClass("w-jm-popup--turn");
                    this.$(".w-jm-popup__wrap__button-left").attr("title", i18n.t("Razvernut"));
                    App.Tracker.sendEvent("小胁械褉薪褍谢懈 芯泻薪芯", location.href);
                } else {
                    this.$el.removeClass("w-jm-popup--turn");
                    this.$(".w-jm-popup__wrap__button-left").attr("title", i18n.t("Svernut"));
                    App.Tracker.sendEvent("袪邪蟹胁械褉薪褍谢懈 芯泻薪芯", location.href);
                }
            });
            this.listenTo(this.collection, "remove", function(model, collection) {
                this.changeCollection();
            });
            this.listenTo(this.collection, "add", $.proxy(this.renderNewRow, this));
            this.listenTo(this.collection, "sync", $.proxy(this.render, this));
            this.listenTo(this.collection, "error", $.proxy(this.errorLoadCollection, this));
            this.collection.fetch();
            return this;
        },
        render: function() {
            if (navigator.userAgent.indexOf("Firefox") > -1) {
                this.$el.addClass("firefox");
            }
            var viewCollection = $(Mustache.render(MediaViewTmpl, {
                count: this.collection.length,
                balance: this.balanceModel.get("units"),
                isRu: App.Config.Lang == "ru" ? true : false,
                isShowBalance: parseInt(MS.Browser.runtime.getManifest().version.replace(/[^0-9]/g, "")) >= 208,
                t: function() {
                    return function(val, render) {
                        val = $.trim(val);
                        var pos1 = val.indexOf("(");
                        var pos2 = val.indexOf(")", pos1);
                        if (pos1 > -1 && pos2 > -1) {
                            var params = val.substr(pos1 + 1, pos2 - pos1 - 1);
                            val = I18n.t(val.substr(0, pos1));
                            return render(val).format(render(params).split(","));
                        } else {
                            val = I18n.t(val);
                        }
                        return render(val);
                    };
                }
            }));
            _.each(this.collection.models, function(model) {
                var viewModel = new MediaRowView({
                    model: model
                });
                viewCollection.find(".w-jm-popup__wrap__content").append(viewModel.$el);
            });
            this.$el.html(viewCollection);
            this.$(".w-jm-popup__wrap__share").html(new SocialShareView().$el);
            this.changeCollection();
            setTimeout($.proxy(function() {
                if (this.model.get("minimized")) {
                    this.model.trigger("change:minimized", this.model, true);
                }
            }, this), 200);
            return this;
        },
        renderNewRow: function(model) {
            var viewModel = new MediaRowView({
                model: model
            });
            this.$(".w-jm-popup__wrap__content").prepend(viewModel.$el);
            if (this.collection.length > 0 && !this.model.get("disableExtensionCurrentSite") && this.model.get("showWindowAutomatically")) {
                this.model.set("show", true);
                this.model.set("showContent", true);
            }
            this.changeCollection();
            return this;
        },
        backgroundPopupAction: function() {
            App.Helpers.SendMessage("IntervalPopupAction", [ "background" ], {
                count: this.collection.length,
                disabled: this.model.get("disableExtensionCurrentSite")
            });
            return this;
        },
        showView: function() {
            this.$el.removeClass("w-jm-popup--hidden").addClass("w-jm-popup--visible");
        },
        hideView: function() {
            this.$el.removeClass("w-jm-popup--visible").addClass("w-jm-popup--hidden");
        },
        showCloseWindow: function() {
            this.$el.addClass("w-jm-popup--window-close-info");
        },
        hideCloseWindow: function() {
            this.$el.removeClass("w-jm-popup--window-close-info");
        },
        errorLoadCollection: function() {
            return this;
        },
        showSocialShareWindow: function(type) {
            var $el = this.$("#id-w-jm-popup__wrap__share-ya_share");
            this.model.set("timeLastShowShare", App.Helpers.GetUnixTime());
            this.$el.addClass("w-jm-popup--window-share");
            if (type === "blocked") {
                this.$el.addClass("w-jm-popup--window-share--blocked");
            }
        },
        hideSocialShareWindow: function() {
            this.$el.removeClass("w-jm-popup--window-share w-jm-popup--window-share--blocked");
        },
        changeCollection: function() {
            var $elCounter = this.$(".w-jm-popup__wrap__title__count");
            if (!this.collection.length) {
                this.model.set("show", false);
                this.model.set("showContent", false);
            } else {
                this.$(".w-jm-popup__wrap__title__count").html(this.collection.length);
                $elCounter.one("webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend", function() {
                    $(this).removeClass("w-jm-popup__wrap__title__count--animate");
                });
                $elCounter.addClass("w-jm-popup__wrap__title__count--animate");
            }
        },
        clearListMedia: function() {
            var _this = this;
            var arrayModels = [];
            _.each(this.collection.models, function(model) {
                arrayModels.push(model);
            });
            _.each(arrayModels, function(model) {
                _this.collection.remove(model);
                model.destroy();
            });
            return false;
        },
        showBalanceWindow: function() {
            this.$el.addClass("w-jm-popup--window-balance");
        },
        showBalanceWindowNoClose: function() {
            this.showBalanceWindow();
            this.$(".w-jm-popup__wrap__balance").addClass("no-close");
        },
        hideBalanceWindow: function() {
            this.$el.removeClass("w-jm-popup--window-balance");
            this.$(".w-jm-popup__wrap__balance").removeClass("no-close");
        },
        changeBalanceInView: function() {
            var balance = this.balanceModel.get("units");
            var subscriptionIsActive = this.balanceModel.get("IsActive");
            var subscriptionExpiredFormatSmall = Moment(this.balanceModel.get("Expired")).format("ll");
            var subscriptionExpiredFormatFull = Moment(this.balanceModel.get("Expired")).format("LL");
            if (balance > 0) {
                this.$(".w-jm-popup__wrap__button-balance .count").html(balance);
                this.$(".w-jm-popup__wrap__button-balance .text").html(I18n.t("UI/downloads").format([ balance ]));
                this.$(".w-jm-popup__wrap__balance .text").html(I18n.t("UI/TheAccountRemains").format([ balance ]));
                this.$(".w-jm-popup__wrap__balance .description").html(I18n.t("UI/BalanceDescription1"));
            } else {
                this.$(".w-jm-popup__wrap__button-balance .text").html(I18n.t("UI/SubscribeDoTitle").format([ subscriptionExpiredFormatSmall ]));
                if (subscriptionIsActive) {
                    this.$(".w-jm-popup__wrap__button-balance .count").html("").addClass("subscription enable");
                    this.$(".w-jm-popup__wrap__balance .text").html(I18n.t("UI/TheAccountRemainsSubscriptionActive").format([ subscriptionExpiredFormatFull ]));
                } else {
                    this.$(".w-jm-popup__wrap__button-balance .count").html("").addClass("subscription disable");
                    this.$(".w-jm-popup__wrap__balance .text").html(I18n.t("UI/TheAccountRemainsSubscriptionExpired"));
                }
                this.$(".w-jm-popup__wrap__balance .description").html(I18n.t("UI/BalanceDescription2"));
            }
            if (balance <= 0 && !subscriptionIsActive) {
                this.$el.addClass("empty-balance");
            } else {
                this.$el.removeClass("empty-balance");
            }
        },
        renderBottomBanner: function() {
            var _this = this;
            function renderBanner() {
                if (_this.listBanners.length === 0) {
                    return;
                }
                if (_this.timeoutIdChangeBanner !== null) {
                    clearTimeout(_this.timeoutIdChangeBanner);
                }
                if (_this.indexShowBottomBanner === _this.listBanners.length - 1) {
                    _this.indexShowBottomBanner = 0;
                } else {
                    _this.indexShowBottomBanner++;
                }
                _this.$(".advertise-bottom").html(Mustache.render(BannerTmpl, {
                    isImage: true,
                    url: _this.listBanners[_this.indexShowBottomBanner].Url,
                    image: _this.listBanners[_this.indexShowBottomBanner].Image,
                    t: function() {
                        return function(val, render) {
                            return I18n.t(val);
                        };
                    }
                }));
                setTimeout(function() {
                    renderBanner();
                }, _this.intervalChangeBanner);
            }
            if (this.listBanners === null) {
                $.getJSON(App.Config.Urls.ApiGetBanners.format([ App.Config.Lang ])).done(function(data) {
                    _this.listBanners = _.shuffle(data);
                    renderBanner();
                });
            } else {
                renderBanner();
            }
            return this;
        }
    });
});

define("shared/js/models/mainWindowModel", [ "app", "underscore", "backbone" ], function(App, _, Backbone) {
    "use strict";
    return Backbone.Model.extend({
        keySettings: "Settings:Main",
        lastDataToSave: {},
        currentDomain: null,
        defaults: {
            show: false,
            showContent: false,
            minimized: false,
            showCloseWindow: false,
            disableExtensionCurrentSite: false,
            disableExtensionSiteArray: [],
            countDownloadedFiles: 0,
            maxCountDownloadedFilesBeforeShare: 20,
            sharedSocial: false,
            timeLastShowShare: 0,
            position: "bottom-left",
            showWindowAutomatically: true
        },
        initialize: function(options) {
            this.currentDomain = options.currentDomain;
            var storage = App.Helpers.Storage;
            this.on("change:disableExtensionCurrentSite", $.proxy(function(model, value) {
                var arraySitesDisableExtension = this.get("disableExtensionSiteArray");
                _.each(arraySitesDisableExtension, $.proxy(function(domain, index) {
                    if (domain === this.currentDomain) {
                        delete arraySitesDisableExtension[index];
                    }
                }, this));
                if (value) {
                    arraySitesDisableExtension.push(this.currentDomain);
                }
                this.attributes["disableExtensionSiteArray"] = _.compact(arraySitesDisableExtension);
            }, this));
            this.on("change", function() {
                App.Helpers.Log("We try to save the data in the storage");
                try {
                    var dataToSave = _.pick(this.attributes, "minimized", "disableExtensionSiteArray", "countDownloadedFiles", "sharedSocial", "timeLastShowShare", "position", "showWindowAutomatically");
                    if (!_.isEqual(this.lastDataToSave, dataToSave)) {
                        App.Helpers.Log("Save the data in the storage");
                        this.lastDataToSave = JSON.parse(JSON.stringify(dataToSave));
                        storage.Save(this.keySettings, dataToSave);
                    }
                } catch (e) {
                    App.Helpers.Error(e);
                }
            });
            try {
                storage.Get(this.keySettings, $.proxy(function(data) {
                    App.Helpers.Log("Receive data from the storage");
                    if (data) {
                        _.each(data, $.proxy(function(param, index) {
                            this.attributes[index] = param;
                        }, this));
                        if (data.disableExtensionSiteArray && _.size(data.disableExtensionSiteArray) > 0) {
                            _.find(data.disableExtensionSiteArray, $.proxy(function(domain) {
                                if (domain === this.currentDomain) {
                                    this.attributes["disableExtensionCurrentSite"] = true;
                                }
                            }, this));
                        }
                        this.lastDataToSave = JSON.parse(JSON.stringify(data));
                    }
                    options.callbackInit();
                }, this));
            } catch (e) {
                App.Helpers.Error(e);
                options.callbackInit();
            }
        }
    });
});

define("ui/js/models/mediaModel", [ "app", "underscore", "backbone" ], function(App, _, Backbone) {
    "use strict";
    return Backbone.Model.extend({
        defaults: {},
        sync: function(method, model, options) {
            options || (options = {});
            var result = null;
            switch (method) {
              case "create":
                {
                    var id = _.uniqueId("id:");
                    model.id = id;
                    App.DB[model.id] = model.toJSON();
                    options.success(model, null, options);
                    break;
                }

              case "update":
                {
                    result = _.find(App.DB, function(item) {
                        if (item.id === model.id) {
                            return true;
                        }
                        return false;
                    });
                    if (result) {
                        App.DB[result.id] = model.toJSON();
                        options.success(model, null, options);
                    } else {
                        options.error(model, null, options);
                    }
                    break;
                }

              case "delete":
                {
                    delete App.DB[model.id];
                    options.success(model, null, options);
                    break;
                }

              case "read":
                {
                    result = _.find(App.DB, function(item) {
                        if (item.id === model.id) {
                            return true;
                        }
                        return false;
                    });
                    if (result) {
                        options.success(result, null, options);
                    } else {
                        options.error(model, null, options);
                    }
                    break;
                }
            }
        }
    });
});

define("ui/js/collections/mediaCollection", [ "app", "underscore", "backbone", "ui/js/models/mediaModel" ], function(App, _, Backbone, MediaModel) {
    "use strict";
    return Backbone.Collection.extend({
        model: MediaModel,
        sync: function(method, model, options) {
            options || (options = {});
            switch (method) {
              case "read":
                {
                    options.success(_.toArray(App.DB), null, options);
                    break;
                }
            }
        },
        initialize: function() {
            return this;
        }
    });
});

define("ui/js/routers/mainRouter", [ "app", "jquery", "underscore", "backbone", "ui/js/views/mediaView", "shared/js/models/mainWindowModel", "ui/js/collections/mediaCollection" ], function(App, $, _, Backbone, MediaView, MainWindowModel, MediaCollection) {
    "use strict";
    var mainRouter = Backbone.Router.extend({
        $elPage: $("body"),
        LastAction: null,
        options: {},
        routes: {
            "(/)": "index"
        },
        initialize: function(options) {
            this.options = options;
        },
        index: function() {
            var model = null;
            model = new MainWindowModel({
                currentDomain: App.Data.CurrentDomain,
                callbackInit: $.proxy(function() {
                    App.Runtime.Models.MainWindowModel = model;
                    this.LastAction = {
                        ActionName: "index",
                        View: new MediaView({
                            model: model,
                            collection: new MediaCollection()
                        })
                    };
                    this.$elPage.html(this.LastAction.View.$el);
                    this.options.callbackInit();
                }, this)
            });
        }
    });
    var initialize = function(options) {
        var mainRouterObj = new mainRouter(options);
        mainRouterObj.on("beforeRoute", function(actionName) {
            if (this.LastAction && this.LastAction.ActionName !== actionName) {
                if (this.LastAction.View.destroy) {
                    this.LastAction.View.destroy();
                }
            }
        });
        Backbone.history.start({
            pushState: false
        });
    };
    return {
        Initialize: initialize
    };
});

require([ "app", "jquery", "underscore", "ui/js/routers/mainRouter" ], function(App, $, _, MainRouter) {
    App.Initialize();
    function init() {
        MainRouter.Initialize({
            callbackInit: $.proxy(function() {
                (function() {
                    var $content = $("body .w-jm-popup");
                    var content = $content.get(0);
                    function resize() {
                        var offset = $content.offset();
                        window.parent.postMessage(JSON.stringify({
                            from: "MediaSave",
                            to: "Site",
                            event: "ResizeIframe",
                            data: {
                                width: content.offsetWidth + offset.left,
                                height: content.offsetHeight,
                                position: lastPosition
                            }
                        }), "*");
                    }
                    var lastWidth = content.offsetWidth;
                    var lastHeight = content.offsetHeight;
                    var lastPosition = "top-center";
                    setInterval(function() {
                        var width = content.offsetWidth;
                        var height = content.offsetHeight;
                        var position = App.Runtime.Models.MainWindowModel.get("position");
                        if (width !== lastWidth || height !== lastHeight || position !== lastPosition) {
                            lastWidth = width;
                            lastHeight = height;
                            lastPosition = position;
                            resize();
                        }
                    }, 80);
                    resize();
                })();
                (function() {
                    App.Helpers.OnMessage("AddFile", "client", $.proxy(function(data) {
                        App.MessageBind.trigger("AddFile", data);
                    }, this));
                    App.Helpers.OnMessage("AddedFileChange", "client", $.proxy(function(data) {
                        App.MessageBind.trigger("AddedFileChange", data);
                    }, this));
                    App.Helpers.OnMessage("ChangeExtensionSettings", "client", $.proxy(function(data) {
                        App.MessageBind.trigger("ChangeExtensionSettings", data);
                    }, this));
                    App.Helpers.OnMessage("ChangePositionSetting", "client", $.proxy(function(data) {
                        App.MessageBind.trigger("ChangePositionSetting", data);
                    }, this));
                    App.Helpers.OnMessage("GeMainWindowModelData", "client", $.proxy(function(data) {
                        App.MessageBind.trigger("GeMainWindowModelData", data);
                    }, this));
                    App.Helpers.OnMessage("ShowMainWindow", "client", $.proxy(function(data) {
                        App.MessageBind.trigger("ShowMainWindow", data);
                    }, this));
                    App.MessageBind.on("GeMainWindowModelDataCallback", function(data) {
                        App.Helpers.SendMessage("GeMainWindowModelDataCallback", [ "popup" ], data);
                    });
                    App.Helpers.OnMessage("DownloadFileSuccess", "client", function(data) {
                        App.MessageBind.trigger("DownloadFileSuccess", data);
                    }.bind(this));
                    App.Helpers.OnMessage("UpdateBalanceInt", "client", function(data) {
                        App.MessageBind.trigger("UpdateBalanceInt", data);
                    }.bind(this));
                })();
                App.MessageBind.trigger("WindowOnLoad");
            }, this)
        });
    }
    App.Helpers.OnMessage("CurrentTabInfo", "client", function(data) {
        App.Data.CurrentTabInfo = data.tab;
        init();
    });
    if (parseInt(MS.Browser.runtime.getManifest().version.replace(/[^0-9]+/g, "")) <= 207) {
        init();
    } else {
        App.Helpers.SendMessage("GetCurrentTabInfo", [ "background" ], null);
    }
});

define("../app/ui/js/init-ui", function() {});